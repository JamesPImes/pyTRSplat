<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyTRSplat.platsettings.PlatSettings API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyTRSplat.platsettings.PlatSettings</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2020, James P. Imes, all rights reserved.

from PIL import ImageFont
import os


class Settings:
    &#34;&#34;&#34;
    Configure the look and behavior of Plat and MultiPlat objects (e.g.,
    size, colors, fonts, whether to write headers/tracts/etc.). Default
    and presets are available and customizable.

    When a string is passed (as `preset=`) at init, it is assumed to be
    one of two things:
        -- the filepath to a saved .txt file of data that can be read
            into a Settings object, with the `._import_file()` method.
        -- the name of a saved preset (with no file extension), which
            will be loaded with the `._load_preset()` method.
    If neither of those is successful, a default Settings object will be
    initialized instead.

    A Settings object can be saved as a preset with the `.save_preset()`
    method (which will save as a .txt file in the directory stored as
    class variable `Settings.PRESET_DIRECTORY`).
    NOTE: File extension is NOT specified when saving/loading preset
        (the program handles that internally).
    NOTE ALSO: To establish custom presets for a specific project, we
        can change the class variable of Settings.PRESET_DIRECTORY for
        that project in the code before loading any presets.

    A list of currently saved presets can be accessed by calling
    `Settings.list_presets()`.

    A Settings object can be saved to a (non-preset) .txt file at a
    specified filepath with the `.save_to_file()` method.
    NOTE: The file extension MUST BE SPECIFIED when saving/loading to a
        .txt file that is not a preset.

    To change font size and/or typeface, be sure to use `.set_font()`.

    NOTE: If `preset=` is not specified, &#39;default&#39; will be loaded. The
        settings of the &#39;default&#39; preset can be changed by creating a
        Settings object and calling `.save_preset(&#39;default&#39;)`, and then
        these will be the settings loaded by default in the future.
        There is also a hard-coded default, which can be loaded by
        passing `preset=None`, and which can be restored to the
        &#39;default&#39; preset with the method `Settings._restore_default()`.
    &#34;&#34;&#34;

    ####################################################################
    # IMPORTANT: To change font size and/or typeface for a given
    # Settings object, be sure to use `.set_font()`, rather than setting
    # those attributes directly. Otherwise, the ImageFont object (from
    # the PIL module) will not be updated, so the updated size/typeface
    # won&#39;t actually get used.
    #
    # However, the RGBA of the font can be set directly, or with
    # `.set_font()` -- because color does not get encoded in a ImageFont
    # object.
    ####################################################################

    SETTINGS_DIR = os.path.dirname(__file__)

    TYPEFACES = {
        # &#39;Arial&#39;-like font
        &#39;Sans-Serif&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Regular.ttf&#39;,
        &#39;Sans-Serif (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Bold.ttf&#39;,
        &#39;Sans-Serif (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-BoldItalic.ttf&#39;,
        &#39;Sans-Serif (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Italic.ttf&#39;,

        # &#39;Times New Roman&#39;-like font
        &#39;Serif&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Regular.ttf&#39;,
        &#39;Serif (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Bold.ttf&#39;,
        &#39;Serif (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-BoldItalic.ttf&#39;,
        &#39;Serif (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Italic.ttf&#39;,

        # &#39;Courier&#39;-like font
        &#39;Mono&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Regular.ttf&#39;,
        &#39;Mono (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Bold.ttf&#39;,
        &#39;Mono (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-BoldItalic.ttf&#39;,
        &#39;Mono (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Italic.ttf&#39;
    }

    DEFAULT_TYPEFACE = TYPEFACES[&#39;Sans-Serif&#39;]

    # Where we&#39;ll look for .txt files of preset data.
    PRESET_DIRECTORY = f&#39;{SETTINGS_DIR}\\_presets\\&#39;

    # Default page-size dimensions.
    LETTER_72ppi = (612, 792)
    LETTER_200ppi = (1700, 2200)
    LETTER_300ppi = (1700, 3300)
    LEGAL_72ppi = (612, 1008)
    LEGAL_200ppi = (1700, 2800)
    LEGAL_300ppi = (2550, 4200)

    # These are fully opaque
    RGBA_RED = (255, 0, 0, 255)
    RGBA_GREEN = (0, 255, 0, 255)
    RGBA_BLUE = (0, 0, 255, 255)
    RGBA_BLACK = (0, 0, 0, 255)
    RGBA_WHITE = (255, 255, 255, 255)

    # These are partially translucent:
    RGBA_RED_OVERLAY = (255, 0, 0, 100)
    RGBA_GREEN_OVERLAY = (0, 255, 0, 100)
    RGBA_BLUE_OVERLAY = (0, 0, 255, 100)
    RGBA_BLACK_OVERLAY = (0, 0, 0, 100)
    RGBA_WHITE_OVERLAY = (255, 255, 255, 100)

    # These attributes are string-type. When creating a Settings object
    # from a text file (or saving one to a text file), that data will
    # also be stored as text. But we don&#39;t want to interpret any other
    # attributes as strings, so we keep track here of the only attribs
    # that SHOULD be strings.
    __stringTypeAtts__ = [
        &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;
    ]

    # We want to strip `SETTINGS_DIR` from the filepath of typefaces
    # when saving presets / to custom file, and reattach it when reading
    # from file, so keep track of typefaces
    __typefaceAtts__ = [
        &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;
    ]

    # These are the attributes that will get included when outputting a
    # Settings object to text file (i.e. creating a preset).
    __setAtts__ = [
        &#39;dim&#39;, &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;, &#39;headerfont_size&#39;, &#39;tractfont_size&#39;, &#39;secfont_size&#39;,
        &#39;lotfont_size&#39;, &#39;headerfont_RGBA&#39;, &#39;tractfont_RGBA&#39;, &#39;secfont_RGBA&#39;,
        &#39;lotfont_RGBA&#39;, &#39;y_top_marg&#39;,&#39;y_bottom_marg&#39;, &#39;y_header_marg&#39;,
        &#39;x_text_left_marg&#39;, &#39;x_text_right_marg&#39;, &#39;y_px_before_tracts&#39;,
        &#39;y_px_between_tracts&#39;, &#39;qq_side&#39;, &#39;sec_line_stroke&#39;, &#39;ql_stroke&#39;,
        &#39;qql_stroke&#39;, &#39;sec_line_RGBA&#39;, &#39;ql_RGBA&#39;, &#39;qql_RGBA&#39;, &#39;qq_fill_RGBA&#39;,
        &#39;centerbox_wh&#39;, &#39;lot_num_offset_px&#39;, &#39;write_header&#39;, &#39;write_tracts&#39;,
        &#39;write_section_numbers&#39;, &#39;write_lot_numbers&#39;, &#39;paragraph_indent&#39;,
        &#39;new_line_indent&#39;, &#39;justify_tract_text&#39;, &#39;warningfont_RGBA&#39;
    ]

    def __init__(self, preset=&#39;default&#39;):

        # If the &#39;default&#39; preset was deleted or can&#39;t be accessed, try
        # resetting the &#39;default&#39; preset to the original, hard-coded
        # default (i.e. `preset=None`). If that fails, then we set
        # `preset` to `None`, which will bypass trying to import from
        # .txt file altogether and just return the hard-coded defaults.
        if preset == &#39;default&#39;:
            try:
                if &#39;default&#39; not in Settings.list_presets():
                    Settings._restore_default()
            except:
                preset = None

        # Dimensions of the image.
        self.dim = Settings.LETTER_200ppi

        # Font typeface, size, and RGBA values.
        # IMPORTANT: To change font size and/or typeface, be sure to use
        # `.set_font()`, because it creates a new ImageFont object.
        # (RGBA can be set directly, or with `.set_font()` -- because
        # color is not encoded in a ImageFont object)
        self.headerfont_typeface = Settings.DEFAULT_TYPEFACE
        self.tractfont_typeface = Settings.DEFAULT_TYPEFACE
        self.secfont_typeface = Settings.DEFAULT_TYPEFACE
        self.lotfont_typeface = Settings.DEFAULT_TYPEFACE
        self.headerfont_size = 64
        self.tractfont_size = 28
        self.secfont_size = 36
        self.lotfont_size = 12
        self.headerfont_RGBA = Settings.RGBA_BLACK
        self.tractfont_RGBA = Settings.RGBA_BLACK
        self.secfont_RGBA = Settings.RGBA_BLACK
        self.lotfont_RGBA = Settings.RGBA_BLACK
        # Color to use to write warnings/errors (not tied to any specific font)
        self.warningfont_RGBA = Settings.RGBA_RED

        # Default font objects will be set by `._update_fonts()` shortly.
        self.headerfont = None
        self.tractfont = None
        self.secfont = None
        self.lotfont = None

        # Construct ImageFont objects from the above settings:
        self._update_fonts()

        # Distance between top of image and top of first row of sections.
        self.y_top_marg = 180

        # Distance between top section line and the T&amp;R written above it.
        self.y_header_marg = 15

        # Bottom margin below which tracts cannot be written
        self.y_bottom_marg = 80

        # px indent for tract text (from the left side of the image).
        self.x_text_left_marg = 100

        # px for tract text right margin (distance from right side of image
        # that we can write up to).
        self.x_text_right_marg = 100

        # Distance between bottom section line and the first tract text written.
        self.y_px_before_tracts = 40

        # Distance between lines of text when writing tracts.
        self.y_px_between_tracts = 10

        # Spaces to indent on new lines in tract text
        self.new_line_indent = 8

        self.qq_side = 50  # length of each side for a QQ in px
        self.sec_line_stroke = 3  # section-line stroke width in px
        self.ql_stroke = 2  # quarter line stroke width in px
        self.qql_stroke = 1  # quarter-quarter line stroke width in px

        # RGBA values for color of various sec/Q lines
        self.sec_line_RGBA = Settings.RGBA_BLACK
        self.ql_RGBA = Settings.RGBA_BLACK
        self.qql_RGBA = (128, 128, 128, 100)

        # RGBA value for QQ fill
        self.qq_fill_RGBA = Settings.RGBA_BLUE_OVERLAY

        # How wide the whited-out centerbox in each section should be:
        self.centerbox_wh = 60

        # How many px set in from top-left corner of QQ box to write lot numbers
        self.lot_num_offset_px = 6

        # Whether to write these labels / text:
        self.write_header = True
        self.write_tracts = True
        self.write_section_numbers = True
        self.write_lot_numbers = False

        # Tract-writing indents, in terms of spaces (characters, not px):
        self.paragraph_indent = 0
        self.new_line_indent = 8

        # Whether tract text should be justified
        self.justify_tract_text = True

        # If `preset` is specified as a string, we assume it is a preset
        # and attempt to load it as Settings data.
        if isinstance(preset, str):
            self._import_preset(preset)

    def deduce_biggest_char(self, font_purpose=&#39;tract&#39;) -&gt; str:
        &#34;&#34;&#34;
        Deduce which character is the widest, when written with the font
        currently set for the specified `font_purpose` (i.e. &#39;header&#39;,
        &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;). Returns that character.
        &#34;&#34;&#34;

        # Confirm it&#39;s a legal font_purpose
        purposes = [&#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, &#39;lot&#39;]
        if font_purpose not in purposes:
            raise ValueError(f&#34;Possible `font_purposes` are: &#34;
                             f&#34;{&#39;, &#39;.join(purposes)}; &#34;
                             f&#34;Attempted to check width of character in &#34;
                             f&#34;font for purpose &#39;{font_purpose}&#39;&#34;)

        # Pull the specified font
        font = getattr(self, f&#34;{font_purpose}font&#34;)

        # Get a dummy ImageDraw object
        from PIL import Image, ImageDraw
        test = Image.new(&#39;RGBA&#39;, (1,1))
        test_draw = ImageDraw.Draw(test, &#39;RGBA&#39;)

        # Check every char to see if it&#39;s the widest currently known
        consideration_set = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=&#39;
        biggest_width = 0
        biggest_char = None
        for char in consideration_set:
            w, h = test_draw.textsize(text=char, font=font)
            if w &gt; biggest_width:
                biggest_width = w
                biggest_char = char

        return biggest_char

    def set_font(self, purpose: str, size=None, typeface=None, RGBA=None):
        &#34;&#34;&#34;Set the font for the specified purpose:
            `purpose` -&gt; &#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;
            `size` -&gt; int of font size
            `typeface` -&gt; A string specifying which typeface to use,
            specified as any of:
            -- relative path (str) to a stock font (extension: .ttf)
                located in the `pyTRSplat/platsettings/` directory.
                    ex:  &#39;_fonts/LiberationSans-Bold.ttf&#39;
            -- absolute path (str) to a font (extension: .ttf) located
                anywhere.
            -- A key (str) to the Settings.TYPEFACES dict (which
                contains absolute paths to .ttf fonts)
                    ex:  &#39;Sans-Serif (Bold)&#39;
            `RGBA` -&gt; 4-item tuple of RGBA color to use for the font
                (each element in the tuple must be an int 0 to 255).
            (Any unspecified parameters will remain unchanged for the
                specified `purpose`.)

            ex: settingsObj.set_font(&#39;header&#39;, size=112)
                    -&gt; The header will be written with size 112 font,
                        using the same typeface as before.
            ex: settingsObj.set_font(
                    &#39;header&#39;, typeface=r&#39;C:/plats/fonts/customfont.ttf&#39;)
                    -&gt; The header will be written with the typeface at
                        the specified filepath, using the same size as
                        before.
            (Or specify `size`, `typeface`, and/or `RGBA` at one time.)&#34;&#34;&#34;

        purpose = purpose.lower()

        # Confirm it&#39;s a legal font `purpose`
        Settings._font_purpose_error_check(purpose)

        # Check for errors in the specified `RGBA`, and then set it.
        if RGBA is not None:
            if not isinstance(RGBA, tuple):
                raise TypeError(&#39;`RGBA` must be tuple containing 4 ints from &#39;
                                f&#39;0 to 255. (Argument of type \&#39;{type(RGBA)}\&#39; &#39;
                                &#39;was passed)&#39;)
            elif len(RGBA) != 4:
                raise ValueError(f&#34;`RGBA` must be tuple containing 4 ints from &#34;
                                 f&#34;0 to 255. &#34;
                                 f&#34;(Passed tuple contained {len(RGBA)} elements.&#34;)
            for val in RGBA:
                if not isinstance(val, int):
                    raise TypeError(&#39;`RGBA` must be tuple containing 4 ints &#39;
                                    &#39;from 0 to 255. (Passed tuple contained &#39;
                                    f&#39;element of type \&#39;{type(val)}\&#39;)&#39;)
                if val &lt; 0 or val &gt; 255:
                    raise ValueError(&#39;`RGBA` must contain ints from 0 to 255. &#39;
                                     f&#39;(Passed tuple contained int {val})&#39;)
            # If it passes the checks, set it.
            setattr(self, f&#34;{purpose}font_RGBA&#34;, RGBA)

        # If `typeface` and `size` are BOTH None, then the ImageFont
        # object won&#39;t change. So if we don&#39;t need to create a new
        # ImageFont obj, we can return now. (RGBA does not get encoded
        # in an ImageFont obj)
        if typeface is None and size is None:
            return

        if typeface is None:
            typeface = getattr(self, f&#34;{purpose}font_typeface&#34;)

        if size is None:
            size = getattr(self, f&#34;{purpose}font_size&#34;)

        # If typeface was passed as font name (i.e. Settings.TYPEFACES
        # key), set it to the corresponding absolute path now
        if typeface in Settings.TYPEFACES.keys():
            typeface = Settings.TYPEFACES[typeface]

        try:
            # Trying as though `typeface` is an absolute filepath
            self._create_set_font(purpose, size, typeface)
        except OSError as no_font_error:
            # If the user did not provide a valid (absolute) path to a
            # .ttf file, try it as a relative path to one of the fonts
            # in the stock `pyTRSplat\platsettings\_fonts\` dir
            candidate_abs_path = _rel_path_to_abs(typeface)
            if os.path.isfile(candidate_abs_path):
                typeface = candidate_abs_path
            else:
                # If it&#39;s also not a relative path, raise the original error
                raise no_font_error
            self._create_set_font(purpose, size, typeface)

        # We only want to change the respective typeface attribute AFTER
        # creating an ImageFont object, so that that has now had the
        # chance to raise any appropriate errors.
        setattr(self, f&#34;{purpose}font_size&#34;, size)
        setattr(self, f&#34;{purpose}font_typeface&#34;, typeface)

    @staticmethod
    def _font_purpose_error_check(purpose: str) -&gt; bool:
        &#34;&#34;&#34;Confirm the specified `purpose` is legal. If so, return
        `True`. Otherwise, raise a ValueError.&#34;&#34;&#34;
        purposes = [&#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, &#39;lot&#39;]
        if purpose not in purposes:
            raise ValueError(f&#34;May customize font size and typeface for these &#34;
                             f&#34;purposes: {&#39;, &#39;.join(purposes)}; &#34;
                             f&#34;Attempted to set font for purpose &#39;{purpose}&#39;&#34;)
        else:
            return True

    def _create_set_font(self, purpose: str, size: int, typeface: str):
        &#34;&#34;&#34;Construct an ImageFont object from the specified `size` and
        `typeface` (a filepath to a .ttf file), and set it for the
        specified `purpose` (being &#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;).&#34;&#34;&#34;

        purpose = purpose.lower()

        # Confirm it&#39;s a legal font `purpose`
        Settings._font_purpose_error_check(purpose)
        try:
            # Try as absolute path first
            fnt = ImageFont.truetype(typeface, size)
        except OSError as no_font_error:
            # If no good, try as relative path, within &#39;pyTRSplat/platsettings/&#39;
            try:
                fnt = ImageFont.truetype(_rel_path_to_abs(typeface), size)
            except OSError:
                raise no_font_error
        setattr(self, f&#39;{purpose}font&#39;, fnt)

    def _update_fonts(self):
        &#34;&#34;&#34;Construct ImageFont objects from the current font settings,
        and set them to the appropriate attributes.&#34;&#34;&#34;

        self._create_set_font(&#39;header&#39;, self.headerfont_size, self.headerfont_typeface)
        self._create_set_font(&#39;tract&#39;, self.tractfont_size, self.tractfont_typeface)
        self._create_set_font(&#39;sec&#39;, self.secfont_size, self.secfont_typeface)
        self._create_set_font(&#39;lot&#39;, self.lotfont_size, self.lotfont_typeface)

    @staticmethod
    def from_file(fp):
        &#34;&#34;&#34;Compile and return a Settings object from .txt file at
        filepath `fp`.&#34;&#34;&#34;

        setObj = Settings()
        setObj._import_file(fp)
        return setObj

    def _import_file(self, fp):
        &#34;&#34;&#34;Read settings from a .txt file at filepath `fp` into this
        Settings object.&#34;&#34;&#34;
        # Return codes:
        # 0 --&gt; success
        # 1 --&gt; Filename with extension other than `.txt` entered
        # 2 --&gt; Could not open file at `filepath`

        if not fp.lower().endswith(&#39;.txt&#39;):
            raise ValueError(&#34;Filename must end in &#39;.txt&#39;&#34;)

        with open(fp, &#39;r&#39;) as file:
            setting_lines = file.readlines()

        self._parse_text_to_settings(setting_lines)

    def _parse_text_to_settings(self, text):
        &#34;&#34;&#34;
        INTERNAL USE:
        Parse appropriately formatted text into Settings attributes.

        :param text: Either a block of text (a string) of attribute data
        separated by linebreaks, or a list of already-separated
        attribute data (i.e. a list of strings).
        :return: Returns nothing, but sets the appropriate attributes to
        this Settings object.
        &#34;&#34;&#34;
        setting_lines = text
        if isinstance(text, str):
            setting_lines = text.split(&#39;\n&#39;)

        for line in setting_lines:
            # Ignore data stored in angle brackets
            if len(line) == 0:
                continue
            if line[0] == &#39;&lt;&#39;:
                continue

            # For each line, parse the &#39;attrib=val&#39; pair, and commit to
            # the setObj, using ._set_str_to_values()
            self._set_str_to_val(line.strip(&#39;\n&#39;))

        # Remember to construct the font objects.
        self._update_fonts()

        # Success code:
        return 0

    def _set_str_to_val(self, attrib_val):
        &#34;&#34;&#34;Take in a string of an attribute/value pair (in the format
        &#39;attribute=value&#39;) and set the appropriate value of the
        attribute. (Expects the format generated by `.save_to_file()`
        method.)&#34;&#34;&#34;

        def try_2_4_tuple(text):
            &#34;&#34;&#34;Check if the text represents a 2-item or 4-item tuple of ints.
            If so, return that tuple. If not, return None.&#34;&#34;&#34;
            txt = text.replace(&#39; &#39;, &#39;&#39;)
            txtlist = txt.split(&#39;,&#39;)

            # If len is neither 2 nor 4, we can rule out this attempt.
            if len(txtlist) not in [2, 4]:
                return None

            # If any element cannot be converted to an int, we can rule
            # out this attempt.
            tl_ints = []
            try:
                for txt in txtlist:
                    tl_ints.append(int(txt))
            except ValueError:
                return None

            # Success. This was a 2-item or 4-item tuple of ints
            return tuple(tl_ints)

        def try_int(text):
            &#34;&#34;&#34;Check if the text represents an int. If so, return that int.
            If not, return None.&#34;&#34;&#34;
            try:
                return int(text)
            except ValueError:
                return None

        def try_bool(text):
            &#34;&#34;&#34;Convert string to its appropriate bool (i.e. &#39;True&#39; -&gt; True).
            Returns None if neither True nor False.&#34;&#34;&#34;
            if text == &#39;True&#39;:
                return True
            elif text == &#39;False&#39;:
                return False
            else:
                return None

        # split attribute/value pair by &#39;=&#39;
        components = attrib_val.split(&#39;=&#39;, maxsplit=1)

        # If only one component was found in the text, the input was
        # improperly formatted, and we return without setting anything.
        try:
            if components[1] == &#39;&#39;:
                return None
        except IndexError:
            if len(components) == 1:
                return None

        att_name, val_text = components

        # If this is a string-type attribute (e.g., filepath to font
        # typefaces), set the val_text to the attribute, and return 0.
        if att_name in Settings.__stringTypeAtts__:
            setattr(self, att_name, val_text)
            return 0

        # Run each of our &#39;try&#39; functions on `val_text` until we get a
        # hit, at which point, we set the converted value to the
        # att_name and return 0.
        for attempt in [try_2_4_tuple, try_int, try_bool]:
            val = attempt(val_text)
            if val is not None:
                setattr(self, att_name, val)
                return 0

        # If we haven&#39;t set our attribute/value by now, return error code -1
        return -1

    def save_to_file(self, filepath):
        &#34;&#34;&#34;Output the data in this Settings object to .txt file at
        filepath `fp`.&#34;&#34;&#34;
        # Returns 0 if success.

        if filepath[-4:].lower() != &#39;.txt&#39;:
            raise ValueError(&#34;filename must end in &#39;.txt&#39;&#34;)

        # try:
        #     file = open(filepath, &#39;w&#39;)
        # except IOError:
        #     print(f&#39;Could not open file: {filepath}.&#39;)
        #     return 2
        file = open(filepath, &#39;w&#39;)

        # These are the attributes we&#39;ll write to the file:
        attsToWrite = Settings.__setAtts__

        def attrib_text(att):
            &#34;&#34;&#34;Get the output text for the attribute (`att`) from `self`&#34;&#34;&#34;
            val = getattr(self, att, None)
            if val is None:
                return &#39;&#39;

            if att in Settings.__typefaceAtts__:
                # Strip out the SETTINGS_DIR from the filepath of the
                # typefaces (leaving only the relative filepath to _fonts\)
                val.replace(Settings.SETTINGS_DIR + &#39;\\&#39;, &#39;&#39;)

            if isinstance(val, int):
                val = str(val)
            elif isinstance(val, (tuple, list)):
                # Convert each element of list/tuple to string; join w/ commas
                val_joiner = []
                for elem in val:
                    val_joiner.append(str(elem))
                val = &#39;,&#39;.join(val_joiner)

            text = f&#34;{att}={val}\n&#34;

            return text

        for att in attsToWrite:
            file.write(attrib_text(att))

        file.close()
        return 0

    def _import_preset(self, name: str):
        &#34;&#34;&#34;Load a saved preset into the current Settings object. The
        specified `name` must exist in the presets, which can be listed
        with `Settings.list_presets()`.&#34;&#34;&#34;

        presets = Settings.list_presets()
        if name.lower() in presets:
            fp = f&#34;{Settings.PRESET_DIRECTORY}\\{name}.txt&#34;
            return self._import_file(fp)
        else:
            raise ValueError(
                f&#34;&#39;{name}&#39; is not a saved Settings preset.&#34;
                f&#34;\nCurrent presets directory: {Settings.PRESET_DIRECTORY}&#34;
                f&#34;\nCurrent presets: {&#39;, &#39;. join(Settings.list_presets())}&#34;)

    @staticmethod
    def list_presets() -&gt; list:
        &#34;&#34;&#34;Return a sorted list of current presets in the preset directory
        (each returned as all lowercase).&#34;&#34;&#34;

        import os
        files = os.listdir(Settings.PRESET_DIRECTORY)
        presets = []
        for f in files:
            if f.lower().endswith(&#39;.txt&#39;):
                presets.append(f.lower()[:-4])
        presets.sort()
        return presets

    def save_preset(self, name: str):
        &#34;&#34;&#34;Save this Settings object as a preset (with the name first
        converted to all lowercase).&#34;&#34;&#34;

        fp = f&#34;{Settings.PRESET_DIRECTORY}\\{name.lower()}.txt&#34;
        self.save_to_file(fp)

    @staticmethod
    def _restore_default():
        &#34;&#34;&#34;
        Restore the &#39;default&#39; preset Setting object to the original,
        hard-coded default.
        &#34;&#34;&#34;
        st = Settings(preset=None)
        st.save_preset(&#39;default&#39;)



def _abs_path_to_rel(fp: str):
    &#34;&#34;&#34;
    INTERNAL USE:
    Convert an absolute path that points to a file or directory within
    this package, into a relative path -- i.e. relative to the
    &#39;pyTRSplat/platsettings/&#39; dir.

    If `fp` is already a relative filepath, or is an absolute filepath
    to a different directory, this will return the original `fp`.

    :param fp: Filepath to convert to relative filepath.
    :return: The filepath (str), relative to &#39;pyTRSplat/platsettings/&#39;
    (i.e. relative to the directory for this package).
    &#34;&#34;&#34;
    if fp.startswith(Settings.SETTINGS_DIR):
        fp.replace(Settings.SETTINGS_DIR + &#39;\\&#39;, &#39;&#39;)
    return fp


def _rel_path_to_abs(fp: str):
    &#34;&#34;&#34;
    INTERNAL USE:
    Convert a relative path (a path within the `pyTRSplat/platsettings/&#39;
    dir) to an absolute path, per the path of this package.
    :param fp: Relative filepath to convert to an absolute path.
    :return:
    &#34;&#34;&#34;
    return f&#34;{Settings.SETTINGS_DIR}\\{fp}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings"><code class="flex name class">
<span>class <span class="ident">Settings</span></span>
<span>(</span><span>preset='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the look and behavior of Plat and MultiPlat objects (e.g.,
size, colors, fonts, whether to write headers/tracts/etc.). Default
and presets are available and customizable.</p>
<p>When a string is passed (as <code>preset=</code>) at init, it is assumed to be
one of two things:
&ndash; the filepath to a saved .txt file of data that can be read
into a Settings object, with the <code>._import_file()</code> method.
&ndash; the name of a saved preset (with no file extension), which
will be loaded with the <code>._load_preset()</code> method.
If neither of those is successful, a default Settings object will be
initialized instead.</p>
<p>A Settings object can be saved as a preset with the <code>.save_preset()</code>
method (which will save as a .txt file in the directory stored as
class variable <code><a title="pyTRSplat.platsettings.PlatSettings.Settings.PRESET_DIRECTORY" href="#pyTRSplat.platsettings.PlatSettings.Settings.PRESET_DIRECTORY">Settings.PRESET_DIRECTORY</a></code>).
NOTE: File extension is NOT specified when saving/loading preset
(the program handles that internally).
NOTE ALSO: To establish custom presets for a specific project, we
can change the class variable of Settings.PRESET_DIRECTORY for
that project in the code before loading any presets.</p>
<p>A list of currently saved presets can be accessed by calling
<code><a title="pyTRSplat.platsettings.PlatSettings.Settings.list_presets" href="#pyTRSplat.platsettings.PlatSettings.Settings.list_presets">Settings.list_presets()</a></code>.</p>
<p>A Settings object can be saved to a (non-preset) .txt file at a
specified filepath with the <code>.save_to_file()</code> method.
NOTE: The file extension MUST BE SPECIFIED when saving/loading to a
.txt file that is not a preset.</p>
<p>To change font size and/or typeface, be sure to use <code>.set_font()</code>.</p>
<p>NOTE: If <code>preset=</code> is not specified, 'default' will be loaded. The
settings of the 'default' preset can be changed by creating a
Settings object and calling <code>.save_preset('default')</code>, and then
these will be the settings loaded by default in the future.
There is also a hard-coded default, which can be loaded by
passing <code>preset=None</code>, and which can be restored to the
'default' preset with the method <code>Settings._restore_default()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Settings:
    &#34;&#34;&#34;
    Configure the look and behavior of Plat and MultiPlat objects (e.g.,
    size, colors, fonts, whether to write headers/tracts/etc.). Default
    and presets are available and customizable.

    When a string is passed (as `preset=`) at init, it is assumed to be
    one of two things:
        -- the filepath to a saved .txt file of data that can be read
            into a Settings object, with the `._import_file()` method.
        -- the name of a saved preset (with no file extension), which
            will be loaded with the `._load_preset()` method.
    If neither of those is successful, a default Settings object will be
    initialized instead.

    A Settings object can be saved as a preset with the `.save_preset()`
    method (which will save as a .txt file in the directory stored as
    class variable `Settings.PRESET_DIRECTORY`).
    NOTE: File extension is NOT specified when saving/loading preset
        (the program handles that internally).
    NOTE ALSO: To establish custom presets for a specific project, we
        can change the class variable of Settings.PRESET_DIRECTORY for
        that project in the code before loading any presets.

    A list of currently saved presets can be accessed by calling
    `Settings.list_presets()`.

    A Settings object can be saved to a (non-preset) .txt file at a
    specified filepath with the `.save_to_file()` method.
    NOTE: The file extension MUST BE SPECIFIED when saving/loading to a
        .txt file that is not a preset.

    To change font size and/or typeface, be sure to use `.set_font()`.

    NOTE: If `preset=` is not specified, &#39;default&#39; will be loaded. The
        settings of the &#39;default&#39; preset can be changed by creating a
        Settings object and calling `.save_preset(&#39;default&#39;)`, and then
        these will be the settings loaded by default in the future.
        There is also a hard-coded default, which can be loaded by
        passing `preset=None`, and which can be restored to the
        &#39;default&#39; preset with the method `Settings._restore_default()`.
    &#34;&#34;&#34;

    ####################################################################
    # IMPORTANT: To change font size and/or typeface for a given
    # Settings object, be sure to use `.set_font()`, rather than setting
    # those attributes directly. Otherwise, the ImageFont object (from
    # the PIL module) will not be updated, so the updated size/typeface
    # won&#39;t actually get used.
    #
    # However, the RGBA of the font can be set directly, or with
    # `.set_font()` -- because color does not get encoded in a ImageFont
    # object.
    ####################################################################

    SETTINGS_DIR = os.path.dirname(__file__)

    TYPEFACES = {
        # &#39;Arial&#39;-like font
        &#39;Sans-Serif&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Regular.ttf&#39;,
        &#39;Sans-Serif (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Bold.ttf&#39;,
        &#39;Sans-Serif (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-BoldItalic.ttf&#39;,
        &#39;Sans-Serif (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSans-Italic.ttf&#39;,

        # &#39;Times New Roman&#39;-like font
        &#39;Serif&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Regular.ttf&#39;,
        &#39;Serif (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Bold.ttf&#39;,
        &#39;Serif (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-BoldItalic.ttf&#39;,
        &#39;Serif (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationSerif-Italic.ttf&#39;,

        # &#39;Courier&#39;-like font
        &#39;Mono&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Regular.ttf&#39;,
        &#39;Mono (Bold)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Bold.ttf&#39;,
        &#39;Mono (Bold-Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-BoldItalic.ttf&#39;,
        &#39;Mono (Italic)&#39;:
            f&#39;{SETTINGS_DIR}\\_fonts\\LiberationMono-Italic.ttf&#39;
    }

    DEFAULT_TYPEFACE = TYPEFACES[&#39;Sans-Serif&#39;]

    # Where we&#39;ll look for .txt files of preset data.
    PRESET_DIRECTORY = f&#39;{SETTINGS_DIR}\\_presets\\&#39;

    # Default page-size dimensions.
    LETTER_72ppi = (612, 792)
    LETTER_200ppi = (1700, 2200)
    LETTER_300ppi = (1700, 3300)
    LEGAL_72ppi = (612, 1008)
    LEGAL_200ppi = (1700, 2800)
    LEGAL_300ppi = (2550, 4200)

    # These are fully opaque
    RGBA_RED = (255, 0, 0, 255)
    RGBA_GREEN = (0, 255, 0, 255)
    RGBA_BLUE = (0, 0, 255, 255)
    RGBA_BLACK = (0, 0, 0, 255)
    RGBA_WHITE = (255, 255, 255, 255)

    # These are partially translucent:
    RGBA_RED_OVERLAY = (255, 0, 0, 100)
    RGBA_GREEN_OVERLAY = (0, 255, 0, 100)
    RGBA_BLUE_OVERLAY = (0, 0, 255, 100)
    RGBA_BLACK_OVERLAY = (0, 0, 0, 100)
    RGBA_WHITE_OVERLAY = (255, 255, 255, 100)

    # These attributes are string-type. When creating a Settings object
    # from a text file (or saving one to a text file), that data will
    # also be stored as text. But we don&#39;t want to interpret any other
    # attributes as strings, so we keep track here of the only attribs
    # that SHOULD be strings.
    __stringTypeAtts__ = [
        &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;
    ]

    # We want to strip `SETTINGS_DIR` from the filepath of typefaces
    # when saving presets / to custom file, and reattach it when reading
    # from file, so keep track of typefaces
    __typefaceAtts__ = [
        &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;
    ]

    # These are the attributes that will get included when outputting a
    # Settings object to text file (i.e. creating a preset).
    __setAtts__ = [
        &#39;dim&#39;, &#39;headerfont_typeface&#39;, &#39;tractfont_typeface&#39;, &#39;secfont_typeface&#39;,
        &#39;lotfont_typeface&#39;, &#39;headerfont_size&#39;, &#39;tractfont_size&#39;, &#39;secfont_size&#39;,
        &#39;lotfont_size&#39;, &#39;headerfont_RGBA&#39;, &#39;tractfont_RGBA&#39;, &#39;secfont_RGBA&#39;,
        &#39;lotfont_RGBA&#39;, &#39;y_top_marg&#39;,&#39;y_bottom_marg&#39;, &#39;y_header_marg&#39;,
        &#39;x_text_left_marg&#39;, &#39;x_text_right_marg&#39;, &#39;y_px_before_tracts&#39;,
        &#39;y_px_between_tracts&#39;, &#39;qq_side&#39;, &#39;sec_line_stroke&#39;, &#39;ql_stroke&#39;,
        &#39;qql_stroke&#39;, &#39;sec_line_RGBA&#39;, &#39;ql_RGBA&#39;, &#39;qql_RGBA&#39;, &#39;qq_fill_RGBA&#39;,
        &#39;centerbox_wh&#39;, &#39;lot_num_offset_px&#39;, &#39;write_header&#39;, &#39;write_tracts&#39;,
        &#39;write_section_numbers&#39;, &#39;write_lot_numbers&#39;, &#39;paragraph_indent&#39;,
        &#39;new_line_indent&#39;, &#39;justify_tract_text&#39;, &#39;warningfont_RGBA&#39;
    ]

    def __init__(self, preset=&#39;default&#39;):

        # If the &#39;default&#39; preset was deleted or can&#39;t be accessed, try
        # resetting the &#39;default&#39; preset to the original, hard-coded
        # default (i.e. `preset=None`). If that fails, then we set
        # `preset` to `None`, which will bypass trying to import from
        # .txt file altogether and just return the hard-coded defaults.
        if preset == &#39;default&#39;:
            try:
                if &#39;default&#39; not in Settings.list_presets():
                    Settings._restore_default()
            except:
                preset = None

        # Dimensions of the image.
        self.dim = Settings.LETTER_200ppi

        # Font typeface, size, and RGBA values.
        # IMPORTANT: To change font size and/or typeface, be sure to use
        # `.set_font()`, because it creates a new ImageFont object.
        # (RGBA can be set directly, or with `.set_font()` -- because
        # color is not encoded in a ImageFont object)
        self.headerfont_typeface = Settings.DEFAULT_TYPEFACE
        self.tractfont_typeface = Settings.DEFAULT_TYPEFACE
        self.secfont_typeface = Settings.DEFAULT_TYPEFACE
        self.lotfont_typeface = Settings.DEFAULT_TYPEFACE
        self.headerfont_size = 64
        self.tractfont_size = 28
        self.secfont_size = 36
        self.lotfont_size = 12
        self.headerfont_RGBA = Settings.RGBA_BLACK
        self.tractfont_RGBA = Settings.RGBA_BLACK
        self.secfont_RGBA = Settings.RGBA_BLACK
        self.lotfont_RGBA = Settings.RGBA_BLACK
        # Color to use to write warnings/errors (not tied to any specific font)
        self.warningfont_RGBA = Settings.RGBA_RED

        # Default font objects will be set by `._update_fonts()` shortly.
        self.headerfont = None
        self.tractfont = None
        self.secfont = None
        self.lotfont = None

        # Construct ImageFont objects from the above settings:
        self._update_fonts()

        # Distance between top of image and top of first row of sections.
        self.y_top_marg = 180

        # Distance between top section line and the T&amp;R written above it.
        self.y_header_marg = 15

        # Bottom margin below which tracts cannot be written
        self.y_bottom_marg = 80

        # px indent for tract text (from the left side of the image).
        self.x_text_left_marg = 100

        # px for tract text right margin (distance from right side of image
        # that we can write up to).
        self.x_text_right_marg = 100

        # Distance between bottom section line and the first tract text written.
        self.y_px_before_tracts = 40

        # Distance between lines of text when writing tracts.
        self.y_px_between_tracts = 10

        # Spaces to indent on new lines in tract text
        self.new_line_indent = 8

        self.qq_side = 50  # length of each side for a QQ in px
        self.sec_line_stroke = 3  # section-line stroke width in px
        self.ql_stroke = 2  # quarter line stroke width in px
        self.qql_stroke = 1  # quarter-quarter line stroke width in px

        # RGBA values for color of various sec/Q lines
        self.sec_line_RGBA = Settings.RGBA_BLACK
        self.ql_RGBA = Settings.RGBA_BLACK
        self.qql_RGBA = (128, 128, 128, 100)

        # RGBA value for QQ fill
        self.qq_fill_RGBA = Settings.RGBA_BLUE_OVERLAY

        # How wide the whited-out centerbox in each section should be:
        self.centerbox_wh = 60

        # How many px set in from top-left corner of QQ box to write lot numbers
        self.lot_num_offset_px = 6

        # Whether to write these labels / text:
        self.write_header = True
        self.write_tracts = True
        self.write_section_numbers = True
        self.write_lot_numbers = False

        # Tract-writing indents, in terms of spaces (characters, not px):
        self.paragraph_indent = 0
        self.new_line_indent = 8

        # Whether tract text should be justified
        self.justify_tract_text = True

        # If `preset` is specified as a string, we assume it is a preset
        # and attempt to load it as Settings data.
        if isinstance(preset, str):
            self._import_preset(preset)

    def deduce_biggest_char(self, font_purpose=&#39;tract&#39;) -&gt; str:
        &#34;&#34;&#34;
        Deduce which character is the widest, when written with the font
        currently set for the specified `font_purpose` (i.e. &#39;header&#39;,
        &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;). Returns that character.
        &#34;&#34;&#34;

        # Confirm it&#39;s a legal font_purpose
        purposes = [&#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, &#39;lot&#39;]
        if font_purpose not in purposes:
            raise ValueError(f&#34;Possible `font_purposes` are: &#34;
                             f&#34;{&#39;, &#39;.join(purposes)}; &#34;
                             f&#34;Attempted to check width of character in &#34;
                             f&#34;font for purpose &#39;{font_purpose}&#39;&#34;)

        # Pull the specified font
        font = getattr(self, f&#34;{font_purpose}font&#34;)

        # Get a dummy ImageDraw object
        from PIL import Image, ImageDraw
        test = Image.new(&#39;RGBA&#39;, (1,1))
        test_draw = ImageDraw.Draw(test, &#39;RGBA&#39;)

        # Check every char to see if it&#39;s the widest currently known
        consideration_set = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=&#39;
        biggest_width = 0
        biggest_char = None
        for char in consideration_set:
            w, h = test_draw.textsize(text=char, font=font)
            if w &gt; biggest_width:
                biggest_width = w
                biggest_char = char

        return biggest_char

    def set_font(self, purpose: str, size=None, typeface=None, RGBA=None):
        &#34;&#34;&#34;Set the font for the specified purpose:
            `purpose` -&gt; &#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;
            `size` -&gt; int of font size
            `typeface` -&gt; A string specifying which typeface to use,
            specified as any of:
            -- relative path (str) to a stock font (extension: .ttf)
                located in the `pyTRSplat/platsettings/` directory.
                    ex:  &#39;_fonts/LiberationSans-Bold.ttf&#39;
            -- absolute path (str) to a font (extension: .ttf) located
                anywhere.
            -- A key (str) to the Settings.TYPEFACES dict (which
                contains absolute paths to .ttf fonts)
                    ex:  &#39;Sans-Serif (Bold)&#39;
            `RGBA` -&gt; 4-item tuple of RGBA color to use for the font
                (each element in the tuple must be an int 0 to 255).
            (Any unspecified parameters will remain unchanged for the
                specified `purpose`.)

            ex: settingsObj.set_font(&#39;header&#39;, size=112)
                    -&gt; The header will be written with size 112 font,
                        using the same typeface as before.
            ex: settingsObj.set_font(
                    &#39;header&#39;, typeface=r&#39;C:/plats/fonts/customfont.ttf&#39;)
                    -&gt; The header will be written with the typeface at
                        the specified filepath, using the same size as
                        before.
            (Or specify `size`, `typeface`, and/or `RGBA` at one time.)&#34;&#34;&#34;

        purpose = purpose.lower()

        # Confirm it&#39;s a legal font `purpose`
        Settings._font_purpose_error_check(purpose)

        # Check for errors in the specified `RGBA`, and then set it.
        if RGBA is not None:
            if not isinstance(RGBA, tuple):
                raise TypeError(&#39;`RGBA` must be tuple containing 4 ints from &#39;
                                f&#39;0 to 255. (Argument of type \&#39;{type(RGBA)}\&#39; &#39;
                                &#39;was passed)&#39;)
            elif len(RGBA) != 4:
                raise ValueError(f&#34;`RGBA` must be tuple containing 4 ints from &#34;
                                 f&#34;0 to 255. &#34;
                                 f&#34;(Passed tuple contained {len(RGBA)} elements.&#34;)
            for val in RGBA:
                if not isinstance(val, int):
                    raise TypeError(&#39;`RGBA` must be tuple containing 4 ints &#39;
                                    &#39;from 0 to 255. (Passed tuple contained &#39;
                                    f&#39;element of type \&#39;{type(val)}\&#39;)&#39;)
                if val &lt; 0 or val &gt; 255:
                    raise ValueError(&#39;`RGBA` must contain ints from 0 to 255. &#39;
                                     f&#39;(Passed tuple contained int {val})&#39;)
            # If it passes the checks, set it.
            setattr(self, f&#34;{purpose}font_RGBA&#34;, RGBA)

        # If `typeface` and `size` are BOTH None, then the ImageFont
        # object won&#39;t change. So if we don&#39;t need to create a new
        # ImageFont obj, we can return now. (RGBA does not get encoded
        # in an ImageFont obj)
        if typeface is None and size is None:
            return

        if typeface is None:
            typeface = getattr(self, f&#34;{purpose}font_typeface&#34;)

        if size is None:
            size = getattr(self, f&#34;{purpose}font_size&#34;)

        # If typeface was passed as font name (i.e. Settings.TYPEFACES
        # key), set it to the corresponding absolute path now
        if typeface in Settings.TYPEFACES.keys():
            typeface = Settings.TYPEFACES[typeface]

        try:
            # Trying as though `typeface` is an absolute filepath
            self._create_set_font(purpose, size, typeface)
        except OSError as no_font_error:
            # If the user did not provide a valid (absolute) path to a
            # .ttf file, try it as a relative path to one of the fonts
            # in the stock `pyTRSplat\platsettings\_fonts\` dir
            candidate_abs_path = _rel_path_to_abs(typeface)
            if os.path.isfile(candidate_abs_path):
                typeface = candidate_abs_path
            else:
                # If it&#39;s also not a relative path, raise the original error
                raise no_font_error
            self._create_set_font(purpose, size, typeface)

        # We only want to change the respective typeface attribute AFTER
        # creating an ImageFont object, so that that has now had the
        # chance to raise any appropriate errors.
        setattr(self, f&#34;{purpose}font_size&#34;, size)
        setattr(self, f&#34;{purpose}font_typeface&#34;, typeface)

    @staticmethod
    def _font_purpose_error_check(purpose: str) -&gt; bool:
        &#34;&#34;&#34;Confirm the specified `purpose` is legal. If so, return
        `True`. Otherwise, raise a ValueError.&#34;&#34;&#34;
        purposes = [&#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, &#39;lot&#39;]
        if purpose not in purposes:
            raise ValueError(f&#34;May customize font size and typeface for these &#34;
                             f&#34;purposes: {&#39;, &#39;.join(purposes)}; &#34;
                             f&#34;Attempted to set font for purpose &#39;{purpose}&#39;&#34;)
        else:
            return True

    def _create_set_font(self, purpose: str, size: int, typeface: str):
        &#34;&#34;&#34;Construct an ImageFont object from the specified `size` and
        `typeface` (a filepath to a .ttf file), and set it for the
        specified `purpose` (being &#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;).&#34;&#34;&#34;

        purpose = purpose.lower()

        # Confirm it&#39;s a legal font `purpose`
        Settings._font_purpose_error_check(purpose)
        try:
            # Try as absolute path first
            fnt = ImageFont.truetype(typeface, size)
        except OSError as no_font_error:
            # If no good, try as relative path, within &#39;pyTRSplat/platsettings/&#39;
            try:
                fnt = ImageFont.truetype(_rel_path_to_abs(typeface), size)
            except OSError:
                raise no_font_error
        setattr(self, f&#39;{purpose}font&#39;, fnt)

    def _update_fonts(self):
        &#34;&#34;&#34;Construct ImageFont objects from the current font settings,
        and set them to the appropriate attributes.&#34;&#34;&#34;

        self._create_set_font(&#39;header&#39;, self.headerfont_size, self.headerfont_typeface)
        self._create_set_font(&#39;tract&#39;, self.tractfont_size, self.tractfont_typeface)
        self._create_set_font(&#39;sec&#39;, self.secfont_size, self.secfont_typeface)
        self._create_set_font(&#39;lot&#39;, self.lotfont_size, self.lotfont_typeface)

    @staticmethod
    def from_file(fp):
        &#34;&#34;&#34;Compile and return a Settings object from .txt file at
        filepath `fp`.&#34;&#34;&#34;

        setObj = Settings()
        setObj._import_file(fp)
        return setObj

    def _import_file(self, fp):
        &#34;&#34;&#34;Read settings from a .txt file at filepath `fp` into this
        Settings object.&#34;&#34;&#34;
        # Return codes:
        # 0 --&gt; success
        # 1 --&gt; Filename with extension other than `.txt` entered
        # 2 --&gt; Could not open file at `filepath`

        if not fp.lower().endswith(&#39;.txt&#39;):
            raise ValueError(&#34;Filename must end in &#39;.txt&#39;&#34;)

        with open(fp, &#39;r&#39;) as file:
            setting_lines = file.readlines()

        self._parse_text_to_settings(setting_lines)

    def _parse_text_to_settings(self, text):
        &#34;&#34;&#34;
        INTERNAL USE:
        Parse appropriately formatted text into Settings attributes.

        :param text: Either a block of text (a string) of attribute data
        separated by linebreaks, or a list of already-separated
        attribute data (i.e. a list of strings).
        :return: Returns nothing, but sets the appropriate attributes to
        this Settings object.
        &#34;&#34;&#34;
        setting_lines = text
        if isinstance(text, str):
            setting_lines = text.split(&#39;\n&#39;)

        for line in setting_lines:
            # Ignore data stored in angle brackets
            if len(line) == 0:
                continue
            if line[0] == &#39;&lt;&#39;:
                continue

            # For each line, parse the &#39;attrib=val&#39; pair, and commit to
            # the setObj, using ._set_str_to_values()
            self._set_str_to_val(line.strip(&#39;\n&#39;))

        # Remember to construct the font objects.
        self._update_fonts()

        # Success code:
        return 0

    def _set_str_to_val(self, attrib_val):
        &#34;&#34;&#34;Take in a string of an attribute/value pair (in the format
        &#39;attribute=value&#39;) and set the appropriate value of the
        attribute. (Expects the format generated by `.save_to_file()`
        method.)&#34;&#34;&#34;

        def try_2_4_tuple(text):
            &#34;&#34;&#34;Check if the text represents a 2-item or 4-item tuple of ints.
            If so, return that tuple. If not, return None.&#34;&#34;&#34;
            txt = text.replace(&#39; &#39;, &#39;&#39;)
            txtlist = txt.split(&#39;,&#39;)

            # If len is neither 2 nor 4, we can rule out this attempt.
            if len(txtlist) not in [2, 4]:
                return None

            # If any element cannot be converted to an int, we can rule
            # out this attempt.
            tl_ints = []
            try:
                for txt in txtlist:
                    tl_ints.append(int(txt))
            except ValueError:
                return None

            # Success. This was a 2-item or 4-item tuple of ints
            return tuple(tl_ints)

        def try_int(text):
            &#34;&#34;&#34;Check if the text represents an int. If so, return that int.
            If not, return None.&#34;&#34;&#34;
            try:
                return int(text)
            except ValueError:
                return None

        def try_bool(text):
            &#34;&#34;&#34;Convert string to its appropriate bool (i.e. &#39;True&#39; -&gt; True).
            Returns None if neither True nor False.&#34;&#34;&#34;
            if text == &#39;True&#39;:
                return True
            elif text == &#39;False&#39;:
                return False
            else:
                return None

        # split attribute/value pair by &#39;=&#39;
        components = attrib_val.split(&#39;=&#39;, maxsplit=1)

        # If only one component was found in the text, the input was
        # improperly formatted, and we return without setting anything.
        try:
            if components[1] == &#39;&#39;:
                return None
        except IndexError:
            if len(components) == 1:
                return None

        att_name, val_text = components

        # If this is a string-type attribute (e.g., filepath to font
        # typefaces), set the val_text to the attribute, and return 0.
        if att_name in Settings.__stringTypeAtts__:
            setattr(self, att_name, val_text)
            return 0

        # Run each of our &#39;try&#39; functions on `val_text` until we get a
        # hit, at which point, we set the converted value to the
        # att_name and return 0.
        for attempt in [try_2_4_tuple, try_int, try_bool]:
            val = attempt(val_text)
            if val is not None:
                setattr(self, att_name, val)
                return 0

        # If we haven&#39;t set our attribute/value by now, return error code -1
        return -1

    def save_to_file(self, filepath):
        &#34;&#34;&#34;Output the data in this Settings object to .txt file at
        filepath `fp`.&#34;&#34;&#34;
        # Returns 0 if success.

        if filepath[-4:].lower() != &#39;.txt&#39;:
            raise ValueError(&#34;filename must end in &#39;.txt&#39;&#34;)

        # try:
        #     file = open(filepath, &#39;w&#39;)
        # except IOError:
        #     print(f&#39;Could not open file: {filepath}.&#39;)
        #     return 2
        file = open(filepath, &#39;w&#39;)

        # These are the attributes we&#39;ll write to the file:
        attsToWrite = Settings.__setAtts__

        def attrib_text(att):
            &#34;&#34;&#34;Get the output text for the attribute (`att`) from `self`&#34;&#34;&#34;
            val = getattr(self, att, None)
            if val is None:
                return &#39;&#39;

            if att in Settings.__typefaceAtts__:
                # Strip out the SETTINGS_DIR from the filepath of the
                # typefaces (leaving only the relative filepath to _fonts\)
                val.replace(Settings.SETTINGS_DIR + &#39;\\&#39;, &#39;&#39;)

            if isinstance(val, int):
                val = str(val)
            elif isinstance(val, (tuple, list)):
                # Convert each element of list/tuple to string; join w/ commas
                val_joiner = []
                for elem in val:
                    val_joiner.append(str(elem))
                val = &#39;,&#39;.join(val_joiner)

            text = f&#34;{att}={val}\n&#34;

            return text

        for att in attsToWrite:
            file.write(attrib_text(att))

        file.close()
        return 0

    def _import_preset(self, name: str):
        &#34;&#34;&#34;Load a saved preset into the current Settings object. The
        specified `name` must exist in the presets, which can be listed
        with `Settings.list_presets()`.&#34;&#34;&#34;

        presets = Settings.list_presets()
        if name.lower() in presets:
            fp = f&#34;{Settings.PRESET_DIRECTORY}\\{name}.txt&#34;
            return self._import_file(fp)
        else:
            raise ValueError(
                f&#34;&#39;{name}&#39; is not a saved Settings preset.&#34;
                f&#34;\nCurrent presets directory: {Settings.PRESET_DIRECTORY}&#34;
                f&#34;\nCurrent presets: {&#39;, &#39;. join(Settings.list_presets())}&#34;)

    @staticmethod
    def list_presets() -&gt; list:
        &#34;&#34;&#34;Return a sorted list of current presets in the preset directory
        (each returned as all lowercase).&#34;&#34;&#34;

        import os
        files = os.listdir(Settings.PRESET_DIRECTORY)
        presets = []
        for f in files:
            if f.lower().endswith(&#39;.txt&#39;):
                presets.append(f.lower()[:-4])
        presets.sort()
        return presets

    def save_preset(self, name: str):
        &#34;&#34;&#34;Save this Settings object as a preset (with the name first
        converted to all lowercase).&#34;&#34;&#34;

        fp = f&#34;{Settings.PRESET_DIRECTORY}\\{name.lower()}.txt&#34;
        self.save_to_file(fp)

    @staticmethod
    def _restore_default():
        &#34;&#34;&#34;
        Restore the &#39;default&#39; preset Setting object to the original,
        hard-coded default.
        &#34;&#34;&#34;
        st = Settings(preset=None)
        st.save_preset(&#39;default&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.DEFAULT_TYPEFACE"><code class="name">var <span class="ident">DEFAULT_TYPEFACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_200ppi"><code class="name">var <span class="ident">LEGAL_200ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_300ppi"><code class="name">var <span class="ident">LEGAL_300ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_72ppi"><code class="name">var <span class="ident">LEGAL_72ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_200ppi"><code class="name">var <span class="ident">LETTER_200ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_300ppi"><code class="name">var <span class="ident">LETTER_300ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_72ppi"><code class="name">var <span class="ident">LETTER_72ppi</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.PRESET_DIRECTORY"><code class="name">var <span class="ident">PRESET_DIRECTORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK"><code class="name">var <span class="ident">RGBA_BLACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK_OVERLAY"><code class="name">var <span class="ident">RGBA_BLACK_OVERLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE"><code class="name">var <span class="ident">RGBA_BLUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE_OVERLAY"><code class="name">var <span class="ident">RGBA_BLUE_OVERLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN"><code class="name">var <span class="ident">RGBA_GREEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN_OVERLAY"><code class="name">var <span class="ident">RGBA_GREEN_OVERLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED"><code class="name">var <span class="ident">RGBA_RED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED_OVERLAY"><code class="name">var <span class="ident">RGBA_RED_OVERLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE"><code class="name">var <span class="ident">RGBA_WHITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE_OVERLAY"><code class="name">var <span class="ident">RGBA_WHITE_OVERLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.SETTINGS_DIR"><code class="name">var <span class="ident">SETTINGS_DIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.TYPEFACES"><code class="name">var <span class="ident">TYPEFACES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Compile and return a Settings object from .txt file at
filepath <code>fp</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_file(fp):
    &#34;&#34;&#34;Compile and return a Settings object from .txt file at
    filepath `fp`.&#34;&#34;&#34;

    setObj = Settings()
    setObj._import_file(fp)
    return setObj</code></pre>
</details>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.list_presets"><code class="name flex">
<span>def <span class="ident">list_presets</span></span>(<span>) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a sorted list of current presets in the preset directory
(each returned as all lowercase).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def list_presets() -&gt; list:
    &#34;&#34;&#34;Return a sorted list of current presets in the preset directory
    (each returned as all lowercase).&#34;&#34;&#34;

    import os
    files = os.listdir(Settings.PRESET_DIRECTORY)
    presets = []
    for f in files:
        if f.lower().endswith(&#39;.txt&#39;):
            presets.append(f.lower()[:-4])
    presets.sort()
    return presets</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.deduce_biggest_char"><code class="name flex">
<span>def <span class="ident">deduce_biggest_char</span></span>(<span>self, font_purpose='tract') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Deduce which character is the widest, when written with the font
currently set for the specified <code>font_purpose</code> (i.e. 'header',
'tract', 'sec', or 'lot'). Returns that character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deduce_biggest_char(self, font_purpose=&#39;tract&#39;) -&gt; str:
    &#34;&#34;&#34;
    Deduce which character is the widest, when written with the font
    currently set for the specified `font_purpose` (i.e. &#39;header&#39;,
    &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;). Returns that character.
    &#34;&#34;&#34;

    # Confirm it&#39;s a legal font_purpose
    purposes = [&#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, &#39;lot&#39;]
    if font_purpose not in purposes:
        raise ValueError(f&#34;Possible `font_purposes` are: &#34;
                         f&#34;{&#39;, &#39;.join(purposes)}; &#34;
                         f&#34;Attempted to check width of character in &#34;
                         f&#34;font for purpose &#39;{font_purpose}&#39;&#34;)

    # Pull the specified font
    font = getattr(self, f&#34;{font_purpose}font&#34;)

    # Get a dummy ImageDraw object
    from PIL import Image, ImageDraw
    test = Image.new(&#39;RGBA&#39;, (1,1))
    test_draw = ImageDraw.Draw(test, &#39;RGBA&#39;)

    # Check every char to see if it&#39;s the widest currently known
    consideration_set = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=&#39;
    biggest_width = 0
    biggest_char = None
    for char in consideration_set:
        w, h = test_draw.textsize(text=char, font=font)
        if w &gt; biggest_width:
            biggest_width = w
            biggest_char = char

    return biggest_char</code></pre>
</details>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.save_preset"><code class="name flex">
<span>def <span class="ident">save_preset</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save this Settings object as a preset (with the name first
converted to all lowercase).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_preset(self, name: str):
    &#34;&#34;&#34;Save this Settings object as a preset (with the name first
    converted to all lowercase).&#34;&#34;&#34;

    fp = f&#34;{Settings.PRESET_DIRECTORY}\\{name.lower()}.txt&#34;
    self.save_to_file(fp)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.save_to_file"><code class="name flex">
<span>def <span class="ident">save_to_file</span></span>(<span>self, filepath)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the data in this Settings object to .txt file at
filepath <code>fp</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_file(self, filepath):
    &#34;&#34;&#34;Output the data in this Settings object to .txt file at
    filepath `fp`.&#34;&#34;&#34;
    # Returns 0 if success.

    if filepath[-4:].lower() != &#39;.txt&#39;:
        raise ValueError(&#34;filename must end in &#39;.txt&#39;&#34;)

    # try:
    #     file = open(filepath, &#39;w&#39;)
    # except IOError:
    #     print(f&#39;Could not open file: {filepath}.&#39;)
    #     return 2
    file = open(filepath, &#39;w&#39;)

    # These are the attributes we&#39;ll write to the file:
    attsToWrite = Settings.__setAtts__

    def attrib_text(att):
        &#34;&#34;&#34;Get the output text for the attribute (`att`) from `self`&#34;&#34;&#34;
        val = getattr(self, att, None)
        if val is None:
            return &#39;&#39;

        if att in Settings.__typefaceAtts__:
            # Strip out the SETTINGS_DIR from the filepath of the
            # typefaces (leaving only the relative filepath to _fonts\)
            val.replace(Settings.SETTINGS_DIR + &#39;\\&#39;, &#39;&#39;)

        if isinstance(val, int):
            val = str(val)
        elif isinstance(val, (tuple, list)):
            # Convert each element of list/tuple to string; join w/ commas
            val_joiner = []
            for elem in val:
                val_joiner.append(str(elem))
            val = &#39;,&#39;.join(val_joiner)

        text = f&#34;{att}={val}\n&#34;

        return text

    for att in attsToWrite:
        file.write(attrib_text(att))

    file.close()
    return 0</code></pre>
</details>
</dd>
<dt id="pyTRSplat.platsettings.PlatSettings.Settings.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, purpose: str, size=None, typeface=None, RGBA=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the font for the specified purpose:
<code>purpose</code> -&gt; 'header', 'tract', 'sec', or 'lot'
<code>size</code> -&gt; int of font size
<code>typeface</code> -&gt; A string specifying which typeface to use,
specified as any of:
&ndash; relative path (str) to a stock font (extension: .ttf)
located in the <code>pyTRSplat/platsettings/</code> directory.
ex:
'_fonts/LiberationSans-Bold.ttf'
&ndash; absolute path (str) to a font (extension: .ttf) located
anywhere.
&ndash; A key (str) to the Settings.TYPEFACES dict (which
contains absolute paths to .ttf fonts)
ex:
'Sans-Serif (Bold)'
<code>RGBA</code> -&gt; 4-item tuple of RGBA color to use for the font
(each element in the tuple must be an int 0 to 255).
(Any unspecified parameters will remain unchanged for the
specified <code>purpose</code>.)</p>
<p>ex: settingsObj.set_font('header', size=112)
-&gt; The header will be written with size 112 font,
using the same typeface as before.
ex: settingsObj.set_font(
'header', typeface=r'C:/plats/fonts/customfont.ttf')
-&gt; The header will be written with the typeface at
the specified filepath, using the same size as
before.
(Or specify <code>size</code>, <code>typeface</code>, and/or <code>RGBA</code> at one time.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, purpose: str, size=None, typeface=None, RGBA=None):
    &#34;&#34;&#34;Set the font for the specified purpose:
        `purpose` -&gt; &#39;header&#39;, &#39;tract&#39;, &#39;sec&#39;, or &#39;lot&#39;
        `size` -&gt; int of font size
        `typeface` -&gt; A string specifying which typeface to use,
        specified as any of:
        -- relative path (str) to a stock font (extension: .ttf)
            located in the `pyTRSplat/platsettings/` directory.
                ex:  &#39;_fonts/LiberationSans-Bold.ttf&#39;
        -- absolute path (str) to a font (extension: .ttf) located
            anywhere.
        -- A key (str) to the Settings.TYPEFACES dict (which
            contains absolute paths to .ttf fonts)
                ex:  &#39;Sans-Serif (Bold)&#39;
        `RGBA` -&gt; 4-item tuple of RGBA color to use for the font
            (each element in the tuple must be an int 0 to 255).
        (Any unspecified parameters will remain unchanged for the
            specified `purpose`.)

        ex: settingsObj.set_font(&#39;header&#39;, size=112)
                -&gt; The header will be written with size 112 font,
                    using the same typeface as before.
        ex: settingsObj.set_font(
                &#39;header&#39;, typeface=r&#39;C:/plats/fonts/customfont.ttf&#39;)
                -&gt; The header will be written with the typeface at
                    the specified filepath, using the same size as
                    before.
        (Or specify `size`, `typeface`, and/or `RGBA` at one time.)&#34;&#34;&#34;

    purpose = purpose.lower()

    # Confirm it&#39;s a legal font `purpose`
    Settings._font_purpose_error_check(purpose)

    # Check for errors in the specified `RGBA`, and then set it.
    if RGBA is not None:
        if not isinstance(RGBA, tuple):
            raise TypeError(&#39;`RGBA` must be tuple containing 4 ints from &#39;
                            f&#39;0 to 255. (Argument of type \&#39;{type(RGBA)}\&#39; &#39;
                            &#39;was passed)&#39;)
        elif len(RGBA) != 4:
            raise ValueError(f&#34;`RGBA` must be tuple containing 4 ints from &#34;
                             f&#34;0 to 255. &#34;
                             f&#34;(Passed tuple contained {len(RGBA)} elements.&#34;)
        for val in RGBA:
            if not isinstance(val, int):
                raise TypeError(&#39;`RGBA` must be tuple containing 4 ints &#39;
                                &#39;from 0 to 255. (Passed tuple contained &#39;
                                f&#39;element of type \&#39;{type(val)}\&#39;)&#39;)
            if val &lt; 0 or val &gt; 255:
                raise ValueError(&#39;`RGBA` must contain ints from 0 to 255. &#39;
                                 f&#39;(Passed tuple contained int {val})&#39;)
        # If it passes the checks, set it.
        setattr(self, f&#34;{purpose}font_RGBA&#34;, RGBA)

    # If `typeface` and `size` are BOTH None, then the ImageFont
    # object won&#39;t change. So if we don&#39;t need to create a new
    # ImageFont obj, we can return now. (RGBA does not get encoded
    # in an ImageFont obj)
    if typeface is None and size is None:
        return

    if typeface is None:
        typeface = getattr(self, f&#34;{purpose}font_typeface&#34;)

    if size is None:
        size = getattr(self, f&#34;{purpose}font_size&#34;)

    # If typeface was passed as font name (i.e. Settings.TYPEFACES
    # key), set it to the corresponding absolute path now
    if typeface in Settings.TYPEFACES.keys():
        typeface = Settings.TYPEFACES[typeface]

    try:
        # Trying as though `typeface` is an absolute filepath
        self._create_set_font(purpose, size, typeface)
    except OSError as no_font_error:
        # If the user did not provide a valid (absolute) path to a
        # .ttf file, try it as a relative path to one of the fonts
        # in the stock `pyTRSplat\platsettings\_fonts\` dir
        candidate_abs_path = _rel_path_to_abs(typeface)
        if os.path.isfile(candidate_abs_path):
            typeface = candidate_abs_path
        else:
            # If it&#39;s also not a relative path, raise the original error
            raise no_font_error
        self._create_set_font(purpose, size, typeface)

    # We only want to change the respective typeface attribute AFTER
    # creating an ImageFont object, so that that has now had the
    # chance to raise any appropriate errors.
    setattr(self, f&#34;{purpose}font_size&#34;, size)
    setattr(self, f&#34;{purpose}font_typeface&#34;, typeface)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyTRSplat.platsettings" href="index.html">pyTRSplat.platsettings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyTRSplat.platsettings.PlatSettings.Settings" href="#pyTRSplat.platsettings.PlatSettings.Settings">Settings</a></code></h4>
<ul class="two-column">
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.DEFAULT_TYPEFACE" href="#pyTRSplat.platsettings.PlatSettings.Settings.DEFAULT_TYPEFACE">DEFAULT_TYPEFACE</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_200ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_200ppi">LEGAL_200ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_300ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_300ppi">LEGAL_300ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_72ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LEGAL_72ppi">LEGAL_72ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_200ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LETTER_200ppi">LETTER_200ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_300ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LETTER_300ppi">LETTER_300ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.LETTER_72ppi" href="#pyTRSplat.platsettings.PlatSettings.Settings.LETTER_72ppi">LETTER_72ppi</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.PRESET_DIRECTORY" href="#pyTRSplat.platsettings.PlatSettings.Settings.PRESET_DIRECTORY">PRESET_DIRECTORY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK">RGBA_BLACK</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK_OVERLAY" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLACK_OVERLAY">RGBA_BLACK_OVERLAY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE">RGBA_BLUE</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE_OVERLAY" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_BLUE_OVERLAY">RGBA_BLUE_OVERLAY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN">RGBA_GREEN</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN_OVERLAY" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_GREEN_OVERLAY">RGBA_GREEN_OVERLAY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED">RGBA_RED</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED_OVERLAY" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_RED_OVERLAY">RGBA_RED_OVERLAY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE">RGBA_WHITE</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE_OVERLAY" href="#pyTRSplat.platsettings.PlatSettings.Settings.RGBA_WHITE_OVERLAY">RGBA_WHITE_OVERLAY</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.SETTINGS_DIR" href="#pyTRSplat.platsettings.PlatSettings.Settings.SETTINGS_DIR">SETTINGS_DIR</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.TYPEFACES" href="#pyTRSplat.platsettings.PlatSettings.Settings.TYPEFACES">TYPEFACES</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.deduce_biggest_char" href="#pyTRSplat.platsettings.PlatSettings.Settings.deduce_biggest_char">deduce_biggest_char</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.from_file" href="#pyTRSplat.platsettings.PlatSettings.Settings.from_file">from_file</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.list_presets" href="#pyTRSplat.platsettings.PlatSettings.Settings.list_presets">list_presets</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.save_preset" href="#pyTRSplat.platsettings.PlatSettings.Settings.save_preset">save_preset</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.save_to_file" href="#pyTRSplat.platsettings.PlatSettings.Settings.save_to_file">save_to_file</a></code></li>
<li><code><a title="pyTRSplat.platsettings.PlatSettings.Settings.set_font" href="#pyTRSplat.platsettings.PlatSettings.Settings.set_font">set_font</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>