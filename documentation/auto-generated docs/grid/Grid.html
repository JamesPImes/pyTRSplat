<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyTRSplat.grid.Grid API documentation</title>
<meta name="description" content="Grid-based representations of PLSS Sections (i.e. 4x4 grid of QQs) and
Townships (i.e. 6x6 grid of Sections), as well as objects for how
specific lots â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyTRSplat.grid.Grid</code></h1>
</header>
<section id="section-intro">
<p>Grid-based representations of PLSS Sections (i.e. 4x4 grid of QQs) and
Townships (i.e. 6x6 grid of Sections), as well as objects for how
specific lots should be interpreted in terms of QQ(s). Also includes
interpreters for converting parsed pyTRS.PLSSDesc and pyTRS.Tract data
into SectionGrid and TownshipGrid objects.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020, James P. Imes, all rights reserved.

&#34;&#34;&#34;
Grid-based representations of PLSS Sections (i.e. 4x4 grid of QQs) and
Townships (i.e. 6x6 grid of Sections), as well as objects for how
specific lots should be interpreted in terms of QQ(s). Also includes
interpreters for converting parsed pyTRS.PLSSDesc and pyTRS.Tract data
into SectionGrid and TownshipGrid objects.
&#34;&#34;&#34;

from pyTRS import parser as pyTRS
from pyTRSplat.utils import _smooth_QQs, _lot_without_div

class SectionGrid:
    &#34;&#34;&#34;
    A grid of a single Section, divided into standard PLSS aliquot
    quarter-quarters (QQs) -- i.e. 4x4 for a standard section.
    Takes optional `ld=` argument for specifying a LotDefinitions object
    (defaults to a &#39;standard&#39; township layout if not specified -- i.e.
    Sections 1 - 7, 18, 19, 30, and 31 have lots, because they are along
    the northern and/or western boundaries of the township). A
    TwpLotDefinitions object may also be passed, so long as `sec`,
    `twp`, and `rge` are also correctly specified.

    If `sec=&lt;int or str&gt;`, `twp=&lt;str&gt;`, and `rge=&lt;str&gt;` are not
    specified at init, the object may not have full functionality in
    conjunction with other modules.
        --example:
            sg_obj = SectionGrid(`sec=14, twp=&#39;154n&#39;, rge=&#39;97w&#39;)
        --equivalently:
            sg_obj = SectionGrid.from_trs(&#39;154n97w14&#39;)
    (Passing `ld=...` in either example is optional, but advisable.)

    If a lot was not defined for this SectionGrid but the lot is
    incorporated into the SectionGrid anyway, it will not set any hits,
    but the lot will be added to the list in the `.unhandled_lots`
    attribute.

    QQ&#39;s have been assigned these coordinates, with (0,0) being the NWNW
    and (3,3) being the SESE -- i.e. moving from top-to-bottom and
    left-to-right:
    ------------------------------------------------------------------
    | NWNW -&gt; (0,0) | NENW -&gt; (1,0) || NWNE -&gt; (2,0) | NENE -&gt; (3,0) |
    |---------------+---------------++---------------+---------------|
    | SWNW -&gt; (0,1) | SENW -&gt; (1,1) || SWNE -&gt; (2,1) | SENE -&gt; (3,1) |
    |===============+===============++===============+===============|
    | NWSW -&gt; (0,2) | SESW -&gt; (1,2) || NWSE -&gt; (2,2) | NESE -&gt; (3,2) |
    |---------------+---------------++---------------+---------------|
    | SWSW -&gt; (0,3) | SESW -&gt; (1,3) || SWSE -&gt; (2,3) | SESE -&gt; (3,3) |
    ------------------------------------------------------------------
    &#34;&#34;&#34;

    def __init__(
            self, sec=&#39;&#39;, twp=&#39;&#39;, rge=&#39;&#39;, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;

        :param sec: Section number (passed as an int, or as a 2-digit
        string).
        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :param ld: A pyTRSplat.LotDefinitions object, defining how lots
        should be interpreted in this section, in terms of QQs.
        :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
        allowed as a fall-back option, when lots have not been
        explicitly defined for a given section. (Default lots are the
        &#39;usual&#39; lots in Sections 1 - 7, 18, 19, 30, and 31 of a
        &#39;standard&#39; township -- i.e. along the northern and western
        boundaries of a township. Potentially useful as a &#39;better-than-
        nothing&#39; option, but not as reliable as user-specified lot
        definitions.)
        &#34;&#34;&#34;

        # Note: twp and rge should have their direction specified
        #   (&#39;n&#39; or &#39;s&#39; for twp; and &#39;e&#39; or &#39;w&#39; for rge). Without doing
        #   so, various functionality may break.

        twp = twp.lower()
        rge = rge.lower()
        self.twp = twp
        self.rge = rge

        # &#39;secError&#39; can be returned by pyTRS in the event of a flawed
        # parse, so we handle this by setting to 0 (a meaningless number
        # for a section that can&#39;t exist in reality) to avoid causing
        # ValueError when converting to int elsewhere.
        if sec == &#39;secError&#39;:
            sec = 0

        # Ensure sec is formatted as a two digit string -- ex: &#39;01&#39;
        sec = str(int(sec)).rjust(2, &#39;0&#39;)

        self.sec = sec
        self.twprge = twp + rge
        self.trs = f&#34;{twp}{rge}{sec}&#34;.lower()
        self.unhandled_lots = []

        try:
            sec_num = int(sec)
        except ValueError:
            sec_num = 0

        self.ld = {}
        if ld is None and allow_ld_defaults:
            # If ld was not specified, but the user wants to allow
            # defaults (i.e. for Sections 1 - 7, 18, 19, 30, and 31)
            self.ld = LotDefinitions(default=sec_num)
        elif isinstance(ld, LotDefinitions):
            self.ld = ld
        elif isinstance(ld, TwpLotDefinitions):
            # If the user passed a TLD object (which contains LotDefinitions
            # objects), then pull the appropriate LD object (based on the
            # section number); and if it doesn&#39;t exist, create a new (empty)
            # LD object
            self.ld = ld.get(int(sec), LotDefinitions())
        else:
            # Otherwise, an empty LD.
            self.ld = LotDefinitions()

        # A dict for the 16 aliquot divisions of a standard section,
        # with (0, 0) being NWNW and (3, 3) being SESE -- i.e. beginning
        # at the NWNW, and running east and south. The nested dict for
        # each QQ contains the x,y coordinates in the grid, and whether
        # that QQ has been switched `on` -- i.e. &#39;val&#39;, which is either
        # 0 (&#39;nothing&#39;) or 1 (&#39;something&#39;) to track whether the QQ
        # (or equivalent Lot) was identified in the tract description.
        self.QQgrid = {
            &#39;NWNW&#39;: {&#39;coord&#39;: (0, 0), &#39;val&#39;: 0},
            &#39;NENW&#39;: {&#39;coord&#39;: (1, 0), &#39;val&#39;: 0},
            &#39;NWNE&#39;: {&#39;coord&#39;: (2, 0), &#39;val&#39;: 0},
            &#39;NENE&#39;: {&#39;coord&#39;: (3, 0), &#39;val&#39;: 0},
            &#39;SWNW&#39;: {&#39;coord&#39;: (0, 1), &#39;val&#39;: 0},
            &#39;SENW&#39;: {&#39;coord&#39;: (1, 1), &#39;val&#39;: 0},
            &#39;SWNE&#39;: {&#39;coord&#39;: (2, 1), &#39;val&#39;: 0},
            &#39;SENE&#39;: {&#39;coord&#39;: (3, 1), &#39;val&#39;: 0},
            &#39;NWSW&#39;: {&#39;coord&#39;: (0, 2), &#39;val&#39;: 0},
            &#39;NESW&#39;: {&#39;coord&#39;: (1, 2), &#39;val&#39;: 0},
            &#39;NWSE&#39;: {&#39;coord&#39;: (2, 2), &#39;val&#39;: 0},
            &#39;NESE&#39;: {&#39;coord&#39;: (3, 2), &#39;val&#39;: 0},
            &#39;SWSW&#39;: {&#39;coord&#39;: (0, 3), &#39;val&#39;: 0},
            &#39;SESW&#39;: {&#39;coord&#39;: (1, 3), &#39;val&#39;: 0},
            &#39;SWSE&#39;: {&#39;coord&#39;: (2, 3), &#39;val&#39;: 0},
            &#39;SESE&#39;: {&#39;coord&#39;: (3, 3), &#39;val&#39;: 0}
        }

        # Whether this SectionGrid has been &#39;pinged&#39; by a setter (e.g.,
        # by `.incorporate_lot_list()` -- even if no values were
        # actually set, or if values were later reset to 0).
        self._was_pinged = False

    @staticmethod
    def from_trs(trs=&#39;&#39;, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        Create and return a SectionGrid object by passing in a TRS
        (e.g., &#39;154n97w14&#39;), rather than the separate Sec, Twp, Rge
        components. Also takes optional `ld` argument for specifying
        LotDefinitions object.

        All available parameters have the same effect as for vanilla
        __init__(), except:
        :param trs: The Twp/Rge/Sec specified as a single string, in the
        format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
        digits for section).
            ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
        :return: A SectionGrid object.
        &#34;&#34;&#34;
        twp, rge, sec = pyTRS.break_trs(trs)
        return SectionGrid(
            sec, twp, rge, ld=ld, allow_ld_defaults=allow_ld_defaults)

    @staticmethod
    def from_tract(tract : pyTRS.Tract, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        Return a new SectionGrid object created from a parsed
        pyTRS.Tract object and incorporate the lotList and QQList from
        that Tract.

        All available parameters have the same effect as for vanilla
        __init__(), except:
        :param tract: A pyTRS.Tract object (already parsed into lots and
        QQs).
        :return: A SectionGrid object.
        &#34;&#34;&#34;
        twp, rge, sec = tract.twp, tract.rge, tract.sec
        secObj = SectionGrid(
            sec=sec, twp=twp, rge=rge, ld=ld,
            allow_ld_defaults=allow_ld_defaults)
        secObj.incorporate_tract(tract)

        return secObj

    def apply_lddb(self, lddb):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions object from the
        pyTRSplat.LotDefDB object, if such a LD object exists in that
        LDDB. Will not write/overwrite anything if no LD object exists
        for this section in the LDDB.
        :param lddb: A pyTRSplat.LotDefDB object, ideally containing a
        TwpLotDefinitions object for this section&#39;s twprge, which in
        turn contains a LotDefinitions object for this section.
        &#34;&#34;&#34;
        ld = lddb.trs(self.trs)
        if ld is not None:
            self.ld = ld

    def apply_tld(self, tld):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions object from the
        pyTRSplat.TwpLotDefinitions object, if such a LD object exists
        in that TLD. Will not write/overwrite anything if no LD object
        exists for this section in the TLD.
        :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
        containing a LotDefinitions object for this section.
        &#34;&#34;&#34;
        ld = tld.get(int(self.sec), None)
        if ld is not None:
            self.ld = ld

    def lots_by_qq_name(self) -&gt; dict:
        &#34;&#34;&#34;
        Generate a dict, with QQs as keys, and whose values are each a
        list of the lot(s) that correspond with those QQs. Note that it
        is possible for more than 1 lot per QQ, so the values are all
        lists.
        &#34;&#34;&#34;

        # This functionality is handled by LotDefinitions object.
        return self.ld.lots_by_qq_name()

    def lots_by_grid(self) -&gt; list:
        &#34;&#34;&#34;
        Convert the `ld` into a grid (nested list), depicting which lots
        fall within which coordinate. For example, &#39;L1&#39; through &#39;L4&#39;
        in a standard Section 1 correspond to the N2N2 QQ&#39;s,
        respectively -- so this method would output a grid whose
        (0,0), (1,0), (2,0), and (3,0) are filled with [&#39;L4&#39;], [&#39;L3&#39;],
        [&#39;L2&#39;], and [&#39;L1&#39;], respectively.
        &#34;&#34;&#34;

        lots_by_QQname_dict = self.lots_by_qq_name()
        ar = self.output_array()

        for qq_name, dv in self.QQgrid.items():
            x = dv[&#39;coord&#39;][0]
            y = dv[&#39;coord&#39;][1]
            lots = lots_by_QQname_dict.get(qq_name)
            if lots is not None:
                ar[y][x] = lots
            else:
                ar[y][x] = []

        return ar

    def incorporate_tract(self, tract: pyTRS.Tract):
        &#34;&#34;&#34;
        Check the lotList and QQList of a parsed pyTRS.Tract object,
        and incorporate any hits into the grid.
        NOTE: Relies on the LotDefinitions object in `.ld` at the time
        this method is called. Later changes to `.ld` will not
        modify what has already been done here.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        self.incorporate_qq_list(tract.QQList)
        self.incorporate_lot_list(tract.lotList)

    def incorporate_lot_list(self, lotList: list):
        &#34;&#34;&#34;
        Incorporate all lots in the passed `lotList` into the grid.
            ex: Passing [&#39;L1&#39;, &#39;L3&#39;, &#39;L4&#39;, &#39;L5&#39;] might set &#39;NENE&#39;,
                &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; as hits for a hypothetical
                SectionGrid, depending on how lots 1, 3, 4, and 5 are
                defined in LotDefinitions object in the `.ld` attribute
                of the SectionGrid.
        NOTE: Relies on the LotDefinitions object in `.ld` at the time
        this method is called. Later changes to `.ld` will not
        modify what has already been done here.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # QQ equivalents to Lots
        equiv_qq = []

        # Convert each lot to its equivalent QQ, per the ld, and
        # add them to the equiv_qq list.
        for lot in lotList:
            # First remove any divisions in the lot (e.g., &#39;N2 of L1&#39; -&gt; &#39;L1&#39;)
            lot = _lot_without_div(lot)

            eq_qqs_from_lot = self._unpack_ld(lot)
            if eq_qqs_from_lot is None:
                self.unhandled_lots.append(lot)
                continue
            equiv_qq.extend(eq_qqs_from_lot)

        self.incorporate_qq_list(equiv_qq)

    def incorporate_qq_list(self, QQList : list):
        &#34;&#34;&#34;
        Incorporate all QQs in the passed QQList into the grid.
            ex: Passing &#39;NENE&#39;, &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; sets all of
                those QQ&#39;s as hits in a SectionGrid.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # `qq` can be fed in as &#39;NENE&#39; or &#39;NENE,NWNE&#39;. So we need to break it
        # into components before incorporating.
        for qq in QQList:
            for qq_ in qq.replace(&#39; &#39;, &#39;&#39;).split(&#39;,&#39;):
                # Also, ensure we&#39;re only getting 4-characters max -- i.e.
                # &#39;N2NENE&#39; -&gt; &#39;NENE&#39; by passing through `_smooth_QQs()`.
                # That returns a list (should be of 1 element), so get
                # the first (only) element in the returned list.
                qq_ = _smooth_QQs(qq_)[0]
                self.turn_on_qq(qq_)

    def _unpack_ld(self, lot):
        &#34;&#34;&#34;
        INTERNAL USE:
        Pass a lot number (string &#39;L1&#39; or int 1), and get a list of the
        corresponding / properly formatted QQ(s) from the `.ld` of this
        SectionGrid object. Returns None if the lot is undefined, or if
        it was defined with invalid QQ&#39;s.
        &#34;&#34;&#34;

        equiv_aliquots = []
        # Cull lot divisions (i.e. &#39;N2 of L1&#39; to just &#39;L1&#39;)
        lot = _lot_without_div(lot)

        # Get the raw definition from the LotDefinitions object.
        # If undefined in the LD obj, return None.
        raw_ldef = self.ld.get(lot, None)
        if raw_ldef is None:
            return None

        # Ensure the raw lot definition is in the expected format and is
        # broken out into QQ chunks (e.g., a &#39;L1&#39; that is defined as
        # &#39;N2NE4&#39; should be converted to &#39;NENE&#39; and &#39;NWNE&#39;).  And add
        # the resulting QQ(s) to the list of aliquots.
        equiv_aliquots.extend(_smooth_QQs(raw_ldef))

        if len(equiv_aliquots) == 0:
            return None

        return equiv_aliquots

    def output_text_plat(self, include_header=False) -&gt; str:
        &#34;&#34;&#34;
        Output a simple plat (as a string) of the Section grid values.
        &#34;&#34;&#34;

        ar = self.output_array()
        total_columns = len(ar[0])
        total_rows = len(ar)
        box_width = 4
        box_height = 1
        total_width = 1 + total_columns * (box_width + 1)

        header = &#39;=&#39; * total_width + &#39;\n&#39; + self.trs.center(total_width)

        plat_txt = &#39;=&#39; * total_width
        rows_written = 0
        for row in ar:
            drawn_row = &#39;|&#39;
            for col in row:
                draw = &#39; &#39; * box_width
                if col != 0:
                    draw = &#39;X&#39; * box_width

                drawn_row = drawn_row + draw + &#39;|&#39;
            plat_txt = plat_txt + ( &#39;\n&#39; + drawn_row ) * box_height
            rows_written += 1
            if rows_written != total_rows:
                plat_txt = plat_txt + &#39;\n&#39; + &#39;|&#39;
                plat_txt = (
                        plat_txt + (&#39;-&#39; * box_width + &#39;+&#39;) * (total_columns - 1)
                )
                plat_txt = plat_txt + &#39;-&#39; * box_width + &#39;|&#39;

        plat_txt = plat_txt + &#39;\n&#39; + &#39;=&#39; * total_width

        return (header + &#39;\n&#39;) * include_header + plat_txt

    def output_array(self) -&gt; list:
        &#34;&#34;&#34;
        Convert the grid to an array (oriented from NWNW to SESE),
        with resulting coords formatted (y, x).
        ex:
            ar = sg_obj.output_array()
            ar[y][x]  # Accesses the value at (x, y) in `sg_obj.QQgrid`
        &#34;&#34;&#34;

        max_x = 0
        max_y = 0
        for qq in self.QQgrid.values():
            if qq[&#39;coord&#39;][0] &gt; max_x:
                max_x = qq[&#39;coord&#39;][0]
            if qq[&#39;coord&#39;][1] &gt; max_y:
                max_y = qq[&#39;coord&#39;][1]

        # Create an array of all zero-values, with equal dimensions as
        # in the SectionGrid.QQgrid (which is 4x4 in a standard section).
        ar = [[0 for _a in range(max_x + 1)] for _b in range(max_y + 1)]

        for qq in self.QQgrid.values():
            x = qq[&#39;coord&#39;][0]
            y = qq[&#39;coord&#39;][1]
            if qq[&#39;val&#39;] != 0:
                ar[y][x] = qq[&#39;val&#39;]

        return ar

    def turn_off_qq(self, qq: str):
        &#34;&#34;&#34;
        Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 0.
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        &#34;&#34;&#34;
        qq = qq.upper()
        if qq in self.QQgrid.keys():
            self.QQgrid[qq][&#39;val&#39;] = 0

    def turn_on_qq(self, qq: str, custom_val=1):
        &#34;&#34;&#34;
        Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 1.

        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        :param custom_val: Instead of 1, use a different &#39;on&#39; value
        for this QQ.
        WARNING: Using a `custom_val` as anything other than 1 will
        break most functionality in this module, so it should only be
        used if you have a deep understanding of its implications.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # Note: Passing anything other than `1` to `custom_val` will
        # probably cause other current functionality to break. But it
        # might be useful for some purposes (e.g., tracking which
        # PLSS descriptions include that QQ).
        qq = qq.upper()
        if qq in self.QQgrid.keys():
            self.QQgrid[qq][&#39;val&#39;] = custom_val

    def filled_coords(self) -&gt; list:
        &#34;&#34;&#34;
        Return a list of coordinates in the SectionGrid that contain a
        a hit (i.e. anything other than `0` val).
        &#34;&#34;&#34;
        ar = self.output_array()
        filled = []
        for y in range(len(ar)):
            for x in range(len(ar[y])):
                if ar[y][x] != 0:
                    filled.append((x,y))
        return filled

    def filled_qqs(self) -&gt; list:
        &#34;&#34;&#34;
        Return a list of QQs in the SectionGrid that contain a hit.
        &#34;&#34;&#34;
        hits = []
        for qq, v in self.QQgrid.items():
            if v[&#39;val&#39;] != 0:
                hits.append(qq)
        return hits

    def has_any(self):
        &#34;&#34;&#34;
        Return a bool, whether at least one QQ contains a hit anywhere
        in this SectionGrid.
        &#34;&#34;&#34;
        ar = self.output_array()
        for i in ar:
            for j in i:
                if j != 0:
                    return True
        return False


class TownshipGrid:
    &#34;&#34;&#34;
    A grid of a single Township/Range, containing in its `.sections`
    attribute a dict (keyed by integers 1 - 36, inclusive) of a separate
    SectionGrid object for each of its 36 sections. Also contains a dict
    key `0` (i.e. a nonsense &#39;Section 0&#39;), as a &#39;junk drawer&#39; for error-
    ridden sections.
    &#34;&#34;&#34;

    # Sections 1-6, 13-18, and 25-30 (inclusive) are east-to-west (i.e.
    # right-to-left) -- all other sections are left-to-right.
    RIGHT_TO_LEFT_SECTIONS = list(
        range(1, 7)) + list(range(13, 19)) + list(range(25, 31))

    def __init__(self, twp=&#39;&#39;, rge=&#39;&#39;, tld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        A grid of a single Township/Range, containing in its `.sections`
        attribute a dict (keyed by integers 1 - 36, inclusive) of a
        separate SectionGrid object for each of its 36 sections. Also
        contains a dict key `0` (i.e. a nonsense &#39;Section 0&#39;), as a
        &#39;junk drawer&#39; for error- ridden sections.

        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :param tld: A pyTRSplat.TwpLotDefinitions object, defining how
        lots should be interpreted in each respective section, in terms
        of QQs.
        :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
        allowed as a fall-back option, when lots have not been
        explicitly defined for a given section. (Default lots are the
        &#39;usual&#39; lots in Sections 1 - 7, 18, 19, 30, and 31 of a
        &#39;standard&#39; township -- i.e. along the northern and western
        boundaries of a township. Potentially useful as a &#39;better-than-
        nothing&#39; option, but not as reliable as user-specified lot
        definitions.)
        &#34;&#34;&#34;
        # NOTE: `tld` stands for `TwpLotDefinitions`

        total_sections = 36

        self.twp = twp
        self.rge = rge
        self.twprge = twp + rge

        # dict of SectionGrid objects for each section, keyed by ints 1 - 36
        self.sections = {}

        # dict of (x,y) coords for each section in the Twp, keyed by ints 1 - 36
        self.section_coords = {}

        if isinstance(tld, TwpLotDefinitions):
            self.tld = tld
        elif tld is None and allow_ld_defaults:
            self.tld = TwpLotDefinitions(list(range(0, 37)))
        else:
            self.tld = TwpLotDefinitions()

        # Sections &#34;snake&#34; from the NE corner of the township west then
        # down, then they cut back east, then down and west again, etc.,
        # thus:
        #           6   5   4   3   2   1
        #           7   8   9   10  11  12
        #           18  17  16  15  14  13
        #           19  20  21  22  23  24
        #           30  29  28  27  26  25
        #           31  32  33  34  35  36
        #
        # ...so accounting for this is a little trickier:
        for sec_num in range(1, total_sections + 1):
            x = (sec_num - 1) // 6
            if sec_num in TownshipGrid.RIGHT_TO_LEFT_SECTIONS:
                y = -sec_num % 6
            else:
                y = sec_num % 6
            # Pull the LotDefinitions from our TLD, if it&#39;s been set for
            # this section. If not set, check with `allow_ld_defaults`
            # whether to pull a default LD, or to pull an empty LD.
            ld = self.tld.get_ld(
                sec_num, allow_ld_defaults=allow_ld_defaults,
                force_ld_return=True)
            self.sections[sec_num] = SectionGrid(
                sec=sec_num, twp=twp, rge=rge, ld=ld)
            self.section_coords[sec_num] = (x, y)

        # Also add a nonsense &#39;Section 0&#39; (which never actually exists
        # for any real-life township). This way, we can handle section
        # errors (e.g., from a flawed parse by pyTRS, which can generate
        # a section number of &#39;secError&#39;) by changing them to Section 0,
        # without crashing the program, but while also being able to
        # check if there were flaws (e.g., if there are any changes made
        # to this SectionGrid object).
        self.sections[0] = SectionGrid(sec=0, twp=twp, rge=rge)
        self.section_coords[0] = (-1, -1)

    def apply_tld(self, tld):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions objects from the
        pyTRSplat.TwpLotDefinitions object to the respective SectionGrid
        objects in this TownshipGrid (if such LD objects exists in that
        TLD for such sections). Will not write/overwrite anything if no
        LD object exists for a given section in the TLD.

        :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
        containing a LotDefinitions object for each section.
        &#34;&#34;&#34;
        if not isinstance(tld, TwpLotDefinitions):
            raise TypeError(&#39;`tld` must be `TwpLotDefinitions` object.&#39;)
        for key, val in tld.items():
            self.apply_ld(key, val)

    def apply_ld(self, sec_num: int, ld):
        &#34;&#34;&#34;
        Apply a LotDefinitions object (`ld`) to the SectionGrid object
        that is designated by the section number (`sec_num`).
        &#34;&#34;&#34;
        if not isinstance(ld, LotDefinitions):
            raise TypeError(&#39;`ld` must be type `LotDefinitions`&#39;)
        self.sections[int(sec_num)].ld = ld

    def filled_section_grids(self, include_pinged=False) -&gt; list:
        &#34;&#34;&#34;
        Return a list of pyTRSplat.SectionGrid objects that have at
        least one QQ filled.

        :param include_pinged: Optionally, also include all SectionGrid
        objects that were &#39;pinged&#39; by any setter method, even if no
        values were set (e.g., an empty list was passed to the
        `.incorporate_lotlist()` method, resulting in no actually-set
        values. This is potentially useful if a pyTRS.Tract object was
        parsed but did not have any identifiable lots or QQ&#39;s and we
        still want to include the corresponding SectionGrid object here.
        Defaults to False.
        :return: A list of SectionGrid objects.
        &#34;&#34;&#34;
        x_sec = []
        for sec_num, val in self.sections.items():
            if val.has_any() or (val._was_pinged and include_pinged):
                x_sec.append(val)
        return x_sec

    def incorporate_tract(self, tract, sec_num=None):
        &#34;&#34;&#34;
        Check the `.lotList` and `.QQList` attributes of a parsed
        pyTRS.Tract object, and incorporate any hits into the
        appropriate SectionGrid.
        NOTE: Relies on the TwpLotDefinitions object in `.tld` at the
        time this method is called. Later changes to `.tld` will not
        modify what has already been done here.
        :param tract: The pyTRS.Tract object whose lotList and QQList
        should be incorporated into the TownshipGrid.
        :param sec_num: The section number for the Tract being
        incorporated. If not specified, it will pull the `.sec`
        attribute from the Tract object.
        &#34;&#34;&#34;
        if sec_num is None:
            sec_num = tract.sec
        # &#39;secError&#39; can be returned by pyTRS in the event of a flawed
        # parse, so we handle this by setting sec_num to 0 (a section number
        # that can&#39;t exist in reality), before trying to
        # convert `sec` to an int causes a ValueError.
        if sec_num == &#39;secError&#39;:
            sec_num = 0
        sec_num = int(sec_num)
        secGridObj = self.sections[sec_num]
        secGridObj.incorporate_tract(tract)

    def turn_off_qq(self, sec_num: int, qq: str):
        &#34;&#34;&#34;
        For the specified section, set the value of the specified QQ
        (e.g. &#39;NENE&#39;) to 0, in the appropriate SectionGrid in the
        `.sections` attribute of this TownshipGrid object.

        :param sec_num: An integer (1 - 36) for section number. (Use 0
        to throw away into the junk drawer without raising an error.)
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        &#34;&#34;&#34;
        if sec_num in self.sections.keys():
            self.sections[int(sec_num)].turn_on_qq(qq=qq)

    def turn_on_qq(self, sec_num: int, qq: str, custom_val=1):
        &#34;&#34;&#34;
        For the specified section, set the value of the specified QQ
        (e.g. &#39;NENE&#39;) to `1`, in the appropriate SectionGrid in the
        `.sections` attribute of this TownshipGrid object.
        :param sec_num: An integer (1 - 36) for section number. (Use 0
        to throw away into the junk drawer without raising an error.)
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        :param custom_val: Instead of 1, use a different &#39;on&#39; value
        for this QQ.
        WARNING: Using a `custom_val` as anything other than 1 will
        break most functionality in this module, so it should only be
        used if you have a deep understanding of its implications.
        &#34;&#34;&#34;

        # Note: Passing anything other than `1` to `custom_val` will
        # probably cause other current functionality to break. But it
        # might be useful for some purposes (e.g., tracking which
        # PLSS descriptions include that QQ).

        if sec_num in self.sections.keys():
            self.sections[int(sec_num)].turn_on_qq(qq=qq, custom_val=custom_val)


class LotDefinitions(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;ld&#39; or &#39;LD&#39; in code
    comments and documentation) for defining which lots correspond to
    which QQ in a given section. At init, pass in an int 1 - 36
    (inclusive) to set to the /default/ for that section in a STANDARD
    township (i.e. perhaps &#39;better-than-nothing&#39;).

    These objects can also be contained within a TwpLotDefinitions
    object for a 36-section collection of such lot-to-QQ definitions.
    In turn, TwpLotDefinitions can be contained within a LotDefDB
    object for definitions of lots in the sections of any number of
    townships.

    See `LotDefDB.from_csv()` or `TwpLotDefinitions.from_csv()` for
    loading larger databases from .csv files, rather than creating
    LotDefinitions objects individually.

    Additional documentation on LotDefinitions is maintained under
    pyTRSplat.LotDefDB objects, to avoid undue repetition.
    &#34;&#34;&#34;

    # Below are defaults for sections in a &#39;standard&#39; 6x6 Township grid.
    # (Sections along the north and west boundaries of the township have
    # &#39;expected&#39; lot locations. In practice, these might only RARELY be
    # the only lots in a township, and they are not always consistent,
    # even within these sections. Even so, it is better than nothing.)

    DEF_01_to_05 = {
        &#39;L1&#39;: &#39;NENE&#39;,
        &#39;L2&#39;: &#39;NWNE&#39;,
        &#39;L3&#39;: &#39;NENW&#39;,
        &#39;L4&#39;: &#39;NWNW&#39;
    }

    DEF_06 = {
        &#39;L1&#39;: &#39;NENE&#39;,
        &#39;L2&#39;: &#39;NWNE&#39;,
        &#39;L3&#39;: &#39;NENW&#39;,
        &#39;L4&#39;: &#39;NWNW&#39;,
        &#39;L5&#39;: &#39;SWNW&#39;,
        &#39;L6&#39;: &#39;NWSW&#39;,
        &#39;L7&#39;: &#39;SWSW&#39;,
    }

    DEF_07_18_19_30_31 = {
        &#39;L1&#39;: &#39;NWNW&#39;,
        &#39;L2&#39;: &#39;SWNW&#39;,
        &#39;L3&#39;: &#39;NWSW&#39;,
        &#39;L4&#39;: &#39;SWSW&#39;
    }

    # All other sections in a /standard/ Twp have no lots.
    DEF_00 = {}

    def __init__(self, default=None):
        super().__init__()

        # If default is specified, we&#39;ll absorb that standard dict for
        # this LD object.
        if isinstance(default, dict):
            self.absorb_ld(default)
        elif default in [1, 2, 3, 4, 5]:
            self.absorb_ld(LotDefinitions.DEF_01_to_05)
        elif default == 6:
            self.absorb_ld(LotDefinitions.DEF_06)
        elif default in [7, 18, 19, 30, 31]:
            self.absorb_ld(LotDefinitions.DEF_07_18_19_30_31)
        else:
            self.absorb_ld(LotDefinitions.DEF_00)

    def set_lot(self, lot, definition):
        &#34;&#34;&#34;Set definition (value) to lot (key). Overwrite, if already
        exists. Using this method ensures that the resulting format will
        be as expected elsewhere in the program (assuming input format
        is acceptable), by passing definitions through pyTRS parsing.&#34;&#34;&#34;

        # If no leading &#39;L&#39; was fed in, add it now (e.g. 1 -&gt; &#39;L1&#39;)
        if str(lot).upper()[0] != &#39;L&#39;:
            lot = &#39;L&#39; + str(lot).upper()

        # Ensure the definitions are broken down into QQ&#39;s by passing them
        # through pyTRS.Tract parsing, and pulling the resulting QQList.
        qq_list = pyTRS.Tract(
            desc=definition, initParseQQ=True, config=&#39;cleanQQ&#39;).QQList
        self[lot] = &#39;,&#39;.join(qq_list)

    def absorb_ld(self, dct):
        &#34;&#34;&#34;Absorb another LotDefinitions object. Will overwrite existing
        keys, if any. Using this method ensures that the resulting
        format will be as expected elsewhere in the program (assuming
        input format is acceptable), by passing definitions through
        pyTRS parsing.&#34;&#34;&#34;
        for lot, definition in dct.items():
            self.set_lot(lot, definition)

    def lots_by_qq_name(self) -&gt; dict:
        &#34;&#34;&#34;Get a dict, with QQ&#39;s as keys (e.g., &#39;NENE&#39;), and whose
        values are each a list of the lot(s) that correspond with those
        QQ&#39;s (e.g., &#39;L1&#39;). Note that it is possible for more than 1 lot
        per QQ, so each value is a list.&#34;&#34;&#34;
        ret_dict = {}
        for k, v in self.items():
            list_of_qqs = _smooth_QQs(v)
            for qq in list_of_qqs:
                if qq in ret_dict.keys():
                    ret_dict[qq].append(k)
                else:
                    ret_dict[qq] = [k]
        return ret_dict


class TwpLotDefinitions(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;tld&#39; or &#39;TLD&#39; in code
    comments and documentation) of LotDefinition objects (i.e.
    essentially a nested dict) for an entire township. Each key is a
    section number (an int), whose value is a LotDefinition object for
    that section. If a section number (int) or list of section numbers
    (all ints) is passed at init, will create default LotDefinitions
    objects for those sections.

    A pyTRSplat.TwpLotDefinitions object is a nested dict with this
    structure:
    - TwpLotDefinitions - dict, keyed by sec number (int), value-type:
    -- LotDefinitions - dict, keyed by lot name (ex: &#39;L2&#39;), value-type:
    --- a string, being QQ name(s), separated by comma if more than one
            (i.e. how each lot should be interpreted in terms of QQ&#39;s
                ex: &#39;L2&#39; -&gt; &#39;NWNE&#39;)
    Thus, rudimentary access might be:
        tld_obj[1][&#39;L2&#39;] -&gt; &#39;NWNE&#39;
            (i.e. Lot 2, of Sec 1 of this township corresponds with the
            NW/4NE/4 of said section)
    However, see custom getter method `TwpLotDefinitions.get_ld()`,
    which has more robust handling of default / unspecified values.

    IMPORTANT: TwpLotDefinitions objects contain ONLY one element by
    default: Key `0`, whose value is a meaningless LotDefinitions obj,
    used as a &#39;junk drawer&#39; for error-ridden sections. Additional
    LotDefinitions objects can be added with the `.set_section()` method
    or by loading appropriately formatted data from a .csv file with
    `.load_csv()`.

    NOTE: The `.get_ld()` method is recommended over Python&#39;s built-in
    dict getters (i.e. `dct[&#39;key&#39;]` or `dct.get(&#39;key&#39;)`), because it
    adds more specific functionality for handling defaults.

    These objects can be contained within a pyTRSplat.LotDefDB object
    (keyed by T&amp;R, formatted &#39;000x000x&#39; or fewer digits -- e.g.,
    &#39;154n97w&#39; for T154N-R97W) for definitions of lots in the sections of
    any number of townships.

    See `LotDefDB.from_csv()` or `TwpLotDefinitions.from_csv()` for
    loading larger databases from .csv files, rather than creating
    TwpLotDefinitions objects individually.

    Additional documentation on TwpLotDefinitions is maintained under
    pyTRSplat.LotDefDB objects, to avoid undue repetition.
    &#34;&#34;&#34;

    def __init__(self, default_sections=None):
        &#34;&#34;&#34;
        A dict object (which often get abbreviated &#39;tld&#39; or &#39;TLD&#39; in
        code comments and documentation) of LotDefinition objects (i.e.
        essentially a nested dict) for an entire township. Each key is a
        section number (an int), whose value is a LotDefinition object
        for that section. If a section number (int) or list of section
        numbers (all ints) is passed at init, will create default
        LotDefinitions objects for those sections.

        :param default_sections: A single integer, or list of integers,
        for the section(s) for which default LotDefinitions should be
        created at init. Defaults to None.
        &#34;&#34;&#34;
        super().__init__()

        # Initialize an empty LotDef obj for an non-existing &#39;section 0&#39;
        # (for error-handling purposes only -- will not contain
        # meaningful data)
        self[0] = LotDefinitions(None)

        # If we want to use default dicts for any sections, do so now.
        if isinstance(default_sections, int):
            self[default_sections] = LotDefinitions(default_sections)
        elif isinstance(default_sections, list):
            for sec in default_sections:
                self[sec] = LotDefinitions(sec)

    def set_section(self, sec_num: int, lot_defs: LotDefinitions):
        &#34;&#34;&#34;
        Set the LotDefinitions object for a specified section.
        &#34;&#34;&#34;
        # This need not be a defined method, but it&#39;s more intuitively
        # named, so... why not.
        self[sec_num] = lot_defs

    def get_ld(self, sec_num: int, allow_ld_defaults=False,
               force_ld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling LotDefinitions object for the
        requested section, out of this TwpLotDefinitions object. There
        are two parameters to dictate the behavior of this getter, in
        the event that the key (`sec_num`) does not exist in this dict,
        and they apply in order:
        -- `allow_ld_defaults` (defaults to False): If an explicit
        LotDefinitions object does not already exist for the requested
        key (`sec_num`), then create and return a default LotDefinitions
        object, whose lots are defined as defaults according to the
        `sec_num`. In other words, if `sec_num` is an integer of 1 - 7,
        18, 19, 30, or 31, the returned LotDefinitions object will have
        some lots defined (per a &#39;standard&#39; township); but any other
        section number would be an empty LotDefinitions object.
            NOTE: This getter does NOT add the returned default
                LotDefinitions object to the TwpLotDefinitions object!
        -- `force_ld_return` (defaults to False): If an explicit
        LotDefinitions object does not already exist, and the user did
        not want a default LotDefinitions object as a backup, then this
        parameter dictates whether to return None (i.e. `=False`), or to
        return an empty LotDefinitions object (i.e. `=True`).
            NOTE: This getter does NOT add the returned empty
                LotDefinitions object to the TwpLotDefinitions object!

        :param sec_num: The section number, whose LotDefinitions object
        is requested (i.e. the dict key).
        :param allow_ld_defaults: As discussed above.
        :param force_ld_return:  As discussed above.
        :return: If [a] a LotDefinitions object exists for the requested
        section, [b] the user passed `allow_ld_defaults=True`, AND/OR
        [c] the user passed `force_ld_return=True` -- then will return a
        LotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        sec_num = int(sec_num)
        ld = self.get(sec_num, None)
        if ld is not None:
            return ld
        elif allow_ld_defaults:
            # If there was no LD set for this section, but the user wants
            # to allow default LD&#39;s, generate and return a section-default
            # LD now.
            return LotDefinitions(default=sec_num)
        elif force_ld_return:
            # If the LD was not set for this section, and the user
            # prohibited defaults, but the user still wants to receive a
            # LotDefinitions object... we return an empty LD obj.
            return LotDefinitions()
        else:
            return None

    @staticmethod
    def from_csv(fp, twp: str, rge: str):
        &#34;&#34;&#34;
        Generate a TwpLotDefinitions object from a properly formatted**
        .csv file at filepath `fp`. Specify `twp=&lt;str&gt;` and `rge=&lt;str&gt;`
        for which rows should match.
            ex: tld_obj = TwpLotDefinitions.from_csv(
                    r&#39;assets\examples\SAMPLE_LDDB.csv&#39;,
                    twp=&#39;154n&#39;, rge=&#39;97w&#39;)

        **See the docstring for LotDefDB for proper .csv formatting.

        :param fp: Filepath to the .csv file to load.
        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :return: A new TwpLotDefinitions object that has loaded all
        relevant data from the .csv file.
        &#34;&#34;&#34;

        if None in [twp, rge]:
            raise ValueError(&#39;`twp` and `rge` must be specified.&#39;)

        twp = twp.lower()
        rge = rge.lower()

        # Load a full LotDefDB object from .csv file, and then pull our
        # twp+rge from it. If our twp+rge does not exist as a key,
        # return an empty TLD object.
        temp_lddb = LotDefDB(from_csv=fp)
        return temp_lddb.get_tld(
            twp+rge, allow_ld_defaults=False, force_tld_return=True)


class LotDefDB(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;lddb&#39; or &#39;LDDB&#39; in code
    comments and documentation) for defining which lots correspond to
    which QQs, for any number of sections in any number of Twp/Rge&#39;s.
    Keyed by Twp/Rge (as a single string, i.e. &#39;154n97w&#39; for T154N-R97W
    or &#39;1s7e&#39; for T1S-R7E), whose values are a TwpLotDefinition object
    for that Twp/Rge.

    A pyTRSplat.LotDefDB object is a nested dict with this structure:
    - LotDefDB - dict, keyed by Twp/Rge (str), value-type:
    -- TwpLotDefinitions - dict, keyed by sec number (int), value-type:
    --- LotDefinitions - dict, keyed by lot name (ex: &#39;L2&#39;), value-type:
    ---- a string, being QQ name(s), separated by comma if more than one
            (i.e. how each lot should be interpreted in terms of QQ&#39;s
                ex: &#39;L2&#39; -&gt; &#39;NWNE&#39;)
    Thus, rudimentary access might be:
        lddb_obj[&#39;154n97w&#39;][1][&#39;L2&#39;] -&gt; &#39;NWNE&#39;
            (i.e. Lot 2, of Sec 1, T154N-R97W corresponds with the
            NW/4NE/4 of said section)
    However, see custom getter methods `LotDefDB.get_tld()` and
    `LotDefDB.trs()`, which have more robust handling of default /
    unspecified values. (See also `TwpLotDefinitions.get_ld()` method
    for similar reasons.)

    The `.get_tld()` method (for getting TwpLotDefinitions by `twprge`
    key) is recommended over Python&#39;s built-in dict getters (i.e.
    `dct[&#39;key&#39;]` or `dct.get(&#39;key&#39;)`), because it adds more specific
    functionality for handling defaults / key errors.
    There also exists the `.trs()` method, which is a deeper-level
    getter, i.e. it pulls out the (section-level) LotDefinitions object
    from another level down in this dict structure; rather than the
    (Twp/Rge-level) TwpLotDefinitions object, which is stored as a value
    of this dict.

    NOTE: If a string filepath to a properly formatted** .csv file is
    passed as init parameter `from_csv=`, the object will load the data
    represented in the .csv file. (See below for proper formatting.)

    ** For proper .csv formatting, follow these guidelines (and see the
    example `SAMPLE_LDDB.csv` in the documentation):
        1) These 5 headers MUST exist, all lowercase:
                twp, rge, sec, lot, qq
        2) twp must be specified in the format &#39;000x&#39;
            ex: &#39;154n&#39; for Township 154 North; &#39;1s&#39; for Township 7 South
                (without quotation marks)
        3) rge must be specified in the format &#39;000x&#39;
            ex: &#39;97w&#39; for Range 97 West; &#39;6e&#39; for Range 6 East
                (without quotation marks)
        4) sec and lot should integers (non-numeric lots cannot
                currently be handled)
        5) qq should be in the format as follows:
            a) &#39;NENE&#39; for &#39;Northeast Quarter of the Northeast Quarter&#39;;
                    &#39;W2&#39; for &#39;West Half&#39;; &#39;ALL&#39; for &#39;ALL&#39; ...
                        (These get passed through pyTRS parsing, so
                        reasonable abbreviations SHOULD be captured...)
            b) If a lot comprises more than a single QQ, separate QQs by
                    comma (with no space), and/or use larger aliquot
                    divisions as appropriate.
                        ex: Lot 1 that comprises the N/2NE/4 could be
                            specified under the &#39;qq&#39; columns as &#39;N2NE&#39;
                            (without quotation marks)
                        ex: Lot 4 that sprawls across the E/2NW/4 and
                            SW/4NW/4 could be specified under the &#39;qq&#39;
                            column as &#39;E2NW,SWNW&#39; (without quotation
                            marks)
        6) Any other columns (e.g., &#39;COMMENTS&#39;) should be acceptable but
                will be ignored.
        7) Duplicate lot entries will result in only the last-entered
                row being effective. If a lot comprises multiple QQ&#39;s,
                keep it on a single row, and refer to list item #5 above
                on how to handle it.
        8) Keep in mind that extra long .csv files might conceivably
                take a while to process and/or result in a LotDefDB that
                burdens the system&#39;s memory.&#34;&#34;&#34;

    def __init__(self, from_csv=None):
        &#34;&#34;&#34;
        A nested dict of definitions of how specific lots should be
        interpreted, in terms of their QQ counterparts.
        :param from_csv: (Optional) The filepath to a .csv file that
        contains properly formatted data, which can be loaded into this
        LotDefDB object. (See LotDefDB documentation for guidelines on
        how a .csv file must be formatted.)
        &#34;&#34;&#34;
        super().__init__()
        if from_csv is not None:
            self._import_csv(from_csv)

    def _import_csv(self, fp):
        &#34;&#34;&#34;
        Read in a properly formatted** .csv file at filepath `fp`, and
        convert each unique T&amp;R represented in the .csv file into a
        separate TwpLotDefinitions object, keyed by T&amp;R (keys formatted
        &#39;000x000y&#39; or fewer digits -- ex: &#39;154n97w&#39; for T154N-R97W, or
        &#39;1s6e&#39; for T1S-R6E).

        **See the docstring for LotDefDB for proper .csv formatting.
        &#34;&#34;&#34;

        from pathlib import Path

        # Confirm that we&#39;re going to read &#39;.csv&#39; file.
        if Path(fp).suffix.lower() != &#39;.csv&#39;:
            raise ValueError(&#34;Filepath must end in &#39;.csv&#39;&#34;)

        import csv
        f = open(fp, &#39;r&#39;)
        reader = csv.DictReader(f)

        for row in reader:
            twp, rge = row[&#39;twp&#39;].lower(), row[&#39;rge&#39;].lower()
            sec = int(row[&#39;sec&#39;])
            lot, qq = row[&#39;lot&#39;], row[&#39;qq&#39;]
            # If no TLD has yet been created for this T&amp;R, do it now.
            self.setdefault(twp + rge, TwpLotDefinitions())

            # Add this lot/qq definition for the section/twp/rge on this row.
            self[twp + rge].setdefault(sec, LotDefinitions())
            self[twp + rge][sec].set_lot(lot, qq)

    def set_twp(self, twprge, tld_obj):
        &#34;&#34;&#34;
        Set the TwpLotDefinitions object for a specified `twprge`
        (formatted &#39;000x000z&#39; or fewer digits, if not needed).
        &#34;&#34;&#34;
        # This need not be a defined method, but it&#39;s more intuitively
        # named, so... why not.
        self[twprge] = tld_obj

    def get_tld(self, twprge, allow_ld_defaults=False,
                force_tld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling TwpLotDefinitions object for the
        requested `twprge`, out of this LotDefDB object. There are two
        parameters to dictate the behavior of this getter, in the event
        that the key (`twprge`) does not exist in this dict, and they
        apply in order:
        -- `allow_ld_defaults` (defaults to False): If an explicit
        LotDefinitions object does not already exist for the requested
        key (`sec_num`), then create and return a TwpLotDefinitions
        object with default definitions for every section (i.e. sections
        1 - 7, 18, 19, 30, and 31 will have LotDefinitions objects with
        some lots defined (per a &#39;standard&#39; township); but all other
        sections have empty LotDefinitions objects).
            NOTE: This getter does NOT add the returned default
                TwpLotDefinitions object to the LotDefDB object!
        -- `force_tld_return` (defaults to False): If an explicit
        TwpLotDefinitions object does not already exist, and the user
        did not want a default TwpLotDefinitions object as a backup,
        then this parameter dictates whether to return None (i.e.
        `=False`), or to return an empty TwpLotDefinitions object (i.e.
        `=True`).
            NOTE: This getter does NOT add the returned empty
                TwpLotDefinitions object to the LotDefDB object!

        :param twprge: The Twp/Rge combo (e.g. &#39;154n97w&#39;, &#39;1s8e&#39;, etc.),
        whose TwpLotDefinitions object is requested (i.e. the dict key).
        :param allow_ld_defaults: As discussed above.
        :param force_tld_return:  As discussed above.
        :return: If [a] a TwpLotDefinitions object exists for the
        requested twprge, [b] the user passed `allow_ld_defaults=True`,
        AND/OR [c] the user passed `force_tld_return=True` -- then will
        return a TwpLotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        tld = self.get(twprge, None)
        if tld is not None:
            return tld
        elif allow_ld_defaults:
            # If there was no TLD set for this twprge, but the user wants
            # to allow default TLD&#39;s, generate and return one now.
            return TwpLotDefinitions(
                default_sections=[i for i in range(0, 37)])
        elif force_tld_return:
            return TwpLotDefinitions()
        else:
            return None

    def trs(self, trs, allow_ld_defaults=None, force_ld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling the (section-level) LotDefinitions
        object for the specified `trs` (i.e. Twp/Rge/Sec), if one
        exists in this LotDefDB.

        Like the`TwpLotDefinitions.get_ld()`, this has two backup
        parameters that take over if no such LotDefinitions object
        exists, both with equivalent functionality as in that method:
        -- `allow_ld_defaults` (defaults to False)
        -- `force_ld_return` (defaults to False)
        NOTE: This getter will not set the returned default/empty
            LotDefinitions object (if any) to this LotDefDB object!

        :param trs: The Twp/Rge/Sec of the desired section, in the
        format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
        digits for section).
            ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
        :param allow_ld_defaults: As discussed above.
        :param force_ld_return:  As discussed above.
        :return: If [a] a LotDefinitions object exists for the requested
        section, [b] the user passed `allow_ld_defaults=True`, AND/OR
        [c] the user passed `force_ld_return=True` -- then will return a
        LotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        twp, rge, sec = pyTRS.break_trs(trs)
        twprge = twp + rge
        tld = self.get_tld(
            twprge, allow_ld_defaults=allow_ld_defaults,
            force_tld_return=force_ld_return)
        if tld is not None:
            return tld.get_ld(
                sec_num=int(sec), allow_ld_defaults=allow_ld_defaults,
                force_ld_return=force_ld_return)
        else:
            return None


def plssdesc_to_twp_grids(
        plssdesc: pyTRS.PLSSDesc, lddb=None,
        allow_ld_defaults=False) -&gt; dict:
    &#34;&#34;&#34;
    Generate a dict of TownshipGrid objects (keyed by T&amp;R, i.e. up to
    3 digits for township and range number, and a single lowercase
    letter for N/S and E/W -- i.e. &#39;154n97w&#39; for T154N-R97W or &#39;1s7e&#39;
    for T1S-R7E) from a parsed pyTRS.PLSSDesc object.

    :param plssdesc: An already-parsed pyTRS.PLSSDesc object whose
    subordinate pyTRS.Tract objects (which have also been parsed into
    lots and QQs) should be applied to the resulting TownshipGrid
    objects (i.e. incorporating the Tract objects&#39; `.lotList` and
    `.QQList` attributes into the subordinate SectionGrid objects under
    the TownshipGrids).
    :param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
    to a .csv file** that can be loaded into a LotDefDB -- for how every
    lot should be interpreted in terms of its QQ counterpart(s).
    (**See LotDefDB documentation for how to properly format.)
    :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
    allowed as a fall-back option, when lots have not been explicitly
    defined for a given section. (Default lots are the &#39;usual&#39; lots in
    Sections 1 - 7, 18, 19, 30, and 31 of a &#39;standard&#39; township -- i.e.
    along the northern and western boundaries of a township. Potentially
    useful as a &#39;better-than-nothing&#39; option, but not as reliable as
    user-specified lot definitions.)
    :return: A dict (keyed by T&amp;R) of TownshipGrid objects, whose values
    are set according to the .
    &#34;&#34;&#34;
    tl = plssdesc.parsedTracts
    return tracts_into_twp_grids(
        tl, lddb=lddb, allow_ld_defaults=allow_ld_defaults)


def tracts_into_twp_grids(
        tract_list, grid_dict=None, lddb=None, allow_ld_defaults=False) -&gt; dict:
    &#34;&#34;&#34;
    Incorporate a list of parsed pyTRS.Tract objects into respective
    TownshipGrid objects, and return a dict of those TownshipGrid objs
    (keyed by T&amp;R). If an existing `grid_dict` is passed, it will be
    updated and returned. If not, a new one will be created and
    returned.
    Optionally specify `lddb=&lt;LotDefDB&gt;` to define lots and get better
    results.

    :param tract_list: A list of already-parsed pyTRS.Tract objects
    whose `.lotList` and `.QQList` attributes should incorporated into
    the TownshipGrid objects.
    :param grid_dict: An existing dict (keyed by T&amp;R) of TownshipGrid
    objects (one TownshipGrid per unique Twp/Rge), which will be updated
    and returned. (If no existing dict is passed here, a new one will be
    created and returned.)
    :param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
    to a .csv file** that can be loaded into a LotDefDB -- for how every
    lot should be interpreted in terms of its QQ counterpart(s).
    (**See LotDefDB documentation for how to properly format.)
    :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
    allowed as a fall-back option, when lots have not been explicitly
    defined for a given section. (Default lots are the &#39;usual&#39; lots in
    Sections 1 - 7, 18, 19, 30, and 31 of a &#39;standard&#39; township -- i.e.
    along the northern and western boundaries of a township. Potentially
    useful as a &#39;better-than-nothing&#39; option, but not as reliable as
    user-specified lot definitions.)
    &#34;&#34;&#34;
    if grid_dict is None:
        grid_dict = {}

    # If the user passed a filepath (as a str) to a .csv file that can
    # be loaded into a LDDB object, create that.
    if isinstance(lddb, str):
        lddb = LotDefDB(from_csv=lddb)
    # If we do not yet have a valid LotDefDB object, create a default.
    if not isinstance(lddb, LotDefDB):
        lddb = LotDefDB()

    # We&#39;ll incorporate each Tract object into a SectionGrid object. If
    # necessary, we&#39;ll first create TownshipGrid objects that do not yet
    # exist in the grid_dict.
    for tract in tract_list:

        # If there was a T&amp;R error in the parsing by pyTRS, twp and rge
        # will both be set as &#39;TRerr&#39; by `.break_TRS()`. If there was a
        # section error, `sec` will be set as `secError`. Otherwise,
        # these three variables are set usefully.
        twp, rge, sec = pyTRS.break_trs(tract.trs)

        # We don&#39;t want to duplicate &#39;TRerr&#39; when setting a key shortly,
        # so set twp and rge, such that only twp contains &#39;TRerr&#39;.
        if &#39;TRerr&#39; in twp+rge:
            twp = &#39;TRerr&#39;
            rge = &#39;&#39;

        # If `sec` == &#39;secError&#39;, that will be passed through to
        # `.incorporate_tract()`, which handles that error.

        # Handling a twp, rge, and/or sec that are undefined.
        if twp == &#39;&#39;:
            twp = &#39;undef&#39;
            rge = &#39;&#39;
        if sec in [&#39;&#39;, None]:
            sec = 0

        twprge = twp + rge

        # Get the TLD for this T&amp;R from the lddb, if one exists. If not,
        # create and use a default TLD object. (We `force_tld_return` to
        # ensure that a TwpLotDefinitions object gets returned, instead
        # of None)
        tld = lddb.get_tld(
            twprge, allow_ld_defaults=allow_ld_defaults, force_tld_return=True)

        # If a TownshipGrid object does not yet exist for this T&amp;R in
        # the dict, create one, and add it to the dict now.
        grid_dict.setdefault(twprge, TownshipGrid(twp=twp, rge=rge, tld=tld))

        # Now incorporate the Tract object into a SectionGrid object
        # within the dict. No /new/ SectionGrid objects are created at
        # this point (since a TownshipGrid object creates all 36 of them
        # at init), but SectionGrid objects are updated at this point to
        # incorporate our tracts.
        TwpGridObj = grid_dict[twprge]
        TwpGridObj.incorporate_tract(tract, sec)

    return grid_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyTRSplat.grid.Grid.plssdesc_to_twp_grids"><code class="name flex">
<span>def <span class="ident">plssdesc_to_twp_grids</span></span>(<span>plssdesc:Â pyTRS.parser.parser.PLSSDesc, lddb=None, allow_ld_defaults=False) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a dict of TownshipGrid objects (keyed by T&amp;R, i.e. up to
3 digits for township and range number, and a single lowercase
letter for N/S and E/W &ndash; i.e. '154n97w' for T154N-R97W or '1s7e'
for T1S-R7E) from a parsed pyTRS.PLSSDesc object.</p>
<p>:param plssdesc: An already-parsed pyTRS.PLSSDesc object whose
subordinate pyTRS.Tract objects (which have also been parsed into
lots and QQs) should be applied to the resulting TownshipGrid
objects (i.e. incorporating the Tract objects' <code>.lotList</code> and
<code>.QQList</code> attributes into the subordinate SectionGrid objects under
the TownshipGrids).
:param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
to a .csv file<strong> that can be loaded into a LotDefDB &ndash; for how every
lot should be interpreted in terms of its QQ counterpart(s).
(</strong>See LotDefDB documentation for how to properly format.)
:param allow_ld_defaults: Whether 'default' lot definitions are
allowed as a fall-back option, when lots have not been explicitly
defined for a given section. (Default lots are the 'usual' lots in
Sections 1 - 7, 18, 19, 30, and 31 of a 'standard' township &ndash; i.e.
along the northern and western boundaries of a township. Potentially
useful as a 'better-than-nothing' option, but not as reliable as
user-specified lot definitions.)
:return: A dict (keyed by T&amp;R) of TownshipGrid objects, whose values
are set according to the .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plssdesc_to_twp_grids(
        plssdesc: pyTRS.PLSSDesc, lddb=None,
        allow_ld_defaults=False) -&gt; dict:
    &#34;&#34;&#34;
    Generate a dict of TownshipGrid objects (keyed by T&amp;R, i.e. up to
    3 digits for township and range number, and a single lowercase
    letter for N/S and E/W -- i.e. &#39;154n97w&#39; for T154N-R97W or &#39;1s7e&#39;
    for T1S-R7E) from a parsed pyTRS.PLSSDesc object.

    :param plssdesc: An already-parsed pyTRS.PLSSDesc object whose
    subordinate pyTRS.Tract objects (which have also been parsed into
    lots and QQs) should be applied to the resulting TownshipGrid
    objects (i.e. incorporating the Tract objects&#39; `.lotList` and
    `.QQList` attributes into the subordinate SectionGrid objects under
    the TownshipGrids).
    :param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
    to a .csv file** that can be loaded into a LotDefDB -- for how every
    lot should be interpreted in terms of its QQ counterpart(s).
    (**See LotDefDB documentation for how to properly format.)
    :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
    allowed as a fall-back option, when lots have not been explicitly
    defined for a given section. (Default lots are the &#39;usual&#39; lots in
    Sections 1 - 7, 18, 19, 30, and 31 of a &#39;standard&#39; township -- i.e.
    along the northern and western boundaries of a township. Potentially
    useful as a &#39;better-than-nothing&#39; option, but not as reliable as
    user-specified lot definitions.)
    :return: A dict (keyed by T&amp;R) of TownshipGrid objects, whose values
    are set according to the .
    &#34;&#34;&#34;
    tl = plssdesc.parsedTracts
    return tracts_into_twp_grids(
        tl, lddb=lddb, allow_ld_defaults=allow_ld_defaults)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.tracts_into_twp_grids"><code class="name flex">
<span>def <span class="ident">tracts_into_twp_grids</span></span>(<span>tract_list, grid_dict=None, lddb=None, allow_ld_defaults=False) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Incorporate a list of parsed pyTRS.Tract objects into respective
TownshipGrid objects, and return a dict of those TownshipGrid objs
(keyed by T&amp;R). If an existing <code>grid_dict</code> is passed, it will be
updated and returned. If not, a new one will be created and
returned.
Optionally specify <code>lddb=&lt;LotDefDB&gt;</code> to define lots and get better
results.</p>
<p>:param tract_list: A list of already-parsed pyTRS.Tract objects
whose <code>.lotList</code> and <code>.QQList</code> attributes should incorporated into
the TownshipGrid objects.
:param grid_dict: An existing dict (keyed by T&amp;R) of TownshipGrid
objects (one TownshipGrid per unique Twp/Rge), which will be updated
and returned. (If no existing dict is passed here, a new one will be
created and returned.)
:param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
to a .csv file<strong> that can be loaded into a LotDefDB &ndash; for how every
lot should be interpreted in terms of its QQ counterpart(s).
(</strong>See LotDefDB documentation for how to properly format.)
:param allow_ld_defaults: Whether 'default' lot definitions are
allowed as a fall-back option, when lots have not been explicitly
defined for a given section. (Default lots are the 'usual' lots in
Sections 1 - 7, 18, 19, 30, and 31 of a 'standard' township &ndash; i.e.
along the northern and western boundaries of a township. Potentially
useful as a 'better-than-nothing' option, but not as reliable as
user-specified lot definitions.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracts_into_twp_grids(
        tract_list, grid_dict=None, lddb=None, allow_ld_defaults=False) -&gt; dict:
    &#34;&#34;&#34;
    Incorporate a list of parsed pyTRS.Tract objects into respective
    TownshipGrid objects, and return a dict of those TownshipGrid objs
    (keyed by T&amp;R). If an existing `grid_dict` is passed, it will be
    updated and returned. If not, a new one will be created and
    returned.
    Optionally specify `lddb=&lt;LotDefDB&gt;` to define lots and get better
    results.

    :param tract_list: A list of already-parsed pyTRS.Tract objects
    whose `.lotList` and `.QQList` attributes should incorporated into
    the TownshipGrid objects.
    :param grid_dict: An existing dict (keyed by T&amp;R) of TownshipGrid
    objects (one TownshipGrid per unique Twp/Rge), which will be updated
    and returned. (If no existing dict is passed here, a new one will be
    created and returned.)
    :param lddb: Either a pyTRSplat.LotDefDB object, or a filepath (str)
    to a .csv file** that can be loaded into a LotDefDB -- for how every
    lot should be interpreted in terms of its QQ counterpart(s).
    (**See LotDefDB documentation for how to properly format.)
    :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
    allowed as a fall-back option, when lots have not been explicitly
    defined for a given section. (Default lots are the &#39;usual&#39; lots in
    Sections 1 - 7, 18, 19, 30, and 31 of a &#39;standard&#39; township -- i.e.
    along the northern and western boundaries of a township. Potentially
    useful as a &#39;better-than-nothing&#39; option, but not as reliable as
    user-specified lot definitions.)
    &#34;&#34;&#34;
    if grid_dict is None:
        grid_dict = {}

    # If the user passed a filepath (as a str) to a .csv file that can
    # be loaded into a LDDB object, create that.
    if isinstance(lddb, str):
        lddb = LotDefDB(from_csv=lddb)
    # If we do not yet have a valid LotDefDB object, create a default.
    if not isinstance(lddb, LotDefDB):
        lddb = LotDefDB()

    # We&#39;ll incorporate each Tract object into a SectionGrid object. If
    # necessary, we&#39;ll first create TownshipGrid objects that do not yet
    # exist in the grid_dict.
    for tract in tract_list:

        # If there was a T&amp;R error in the parsing by pyTRS, twp and rge
        # will both be set as &#39;TRerr&#39; by `.break_TRS()`. If there was a
        # section error, `sec` will be set as `secError`. Otherwise,
        # these three variables are set usefully.
        twp, rge, sec = pyTRS.break_trs(tract.trs)

        # We don&#39;t want to duplicate &#39;TRerr&#39; when setting a key shortly,
        # so set twp and rge, such that only twp contains &#39;TRerr&#39;.
        if &#39;TRerr&#39; in twp+rge:
            twp = &#39;TRerr&#39;
            rge = &#39;&#39;

        # If `sec` == &#39;secError&#39;, that will be passed through to
        # `.incorporate_tract()`, which handles that error.

        # Handling a twp, rge, and/or sec that are undefined.
        if twp == &#39;&#39;:
            twp = &#39;undef&#39;
            rge = &#39;&#39;
        if sec in [&#39;&#39;, None]:
            sec = 0

        twprge = twp + rge

        # Get the TLD for this T&amp;R from the lddb, if one exists. If not,
        # create and use a default TLD object. (We `force_tld_return` to
        # ensure that a TwpLotDefinitions object gets returned, instead
        # of None)
        tld = lddb.get_tld(
            twprge, allow_ld_defaults=allow_ld_defaults, force_tld_return=True)

        # If a TownshipGrid object does not yet exist for this T&amp;R in
        # the dict, create one, and add it to the dict now.
        grid_dict.setdefault(twprge, TownshipGrid(twp=twp, rge=rge, tld=tld))

        # Now incorporate the Tract object into a SectionGrid object
        # within the dict. No /new/ SectionGrid objects are created at
        # this point (since a TownshipGrid object creates all 36 of them
        # at init), but SectionGrid objects are updated at this point to
        # incorporate our tracts.
        TwpGridObj = grid_dict[twprge]
        TwpGridObj.incorporate_tract(tract, sec)

    return grid_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyTRSplat.grid.Grid.LotDefDB"><code class="flex name class">
<span>class <span class="ident">LotDefDB</span></span>
<span>(</span><span>from_csv=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A dict object (which often get abbreviated 'lddb' or 'LDDB' in code
comments and documentation) for defining which lots correspond to
which QQs, for any number of sections in any number of Twp/Rge's.
Keyed by Twp/Rge (as a single string, i.e. '154n97w' for T154N-R97W
or '1s7e' for T1S-R7E), whose values are a TwpLotDefinition object
for that Twp/Rge.</p>
<p>A pyTRSplat.LotDefDB object is a nested dict with this structure:
- LotDefDB - dict, keyed by Twp/Rge (str), value-type:
&ndash; TwpLotDefinitions - dict, keyed by sec number (int), value-type:
&mdash; LotDefinitions - dict, keyed by lot name (ex: 'L2'), value-type:
---- a string, being QQ name(s), separated by comma if more than one
(i.e. how each lot should be interpreted in terms of QQ's
ex: 'L2' -&gt; 'NWNE')
Thus, rudimentary access might be:
lddb_obj['154n97w'][1]['L2'] -&gt; 'NWNE'
(i.e. Lot 2, of Sec 1, T154N-R97W corresponds with the
NW/4NE/4 of said section)
However, see custom getter methods <code><a title="pyTRSplat.grid.Grid.LotDefDB.get_tld" href="#pyTRSplat.grid.Grid.LotDefDB.get_tld">LotDefDB.get_tld()</a></code> and
<code><a title="pyTRSplat.grid.Grid.LotDefDB.trs" href="#pyTRSplat.grid.Grid.LotDefDB.trs">LotDefDB.trs()</a></code>, which have more robust handling of default /
unspecified values. (See also <code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld">TwpLotDefinitions.get_ld()</a></code> method
for similar reasons.)</p>
<p>The <code>.get_tld()</code> method (for getting TwpLotDefinitions by <code>twprge</code>
key) is recommended over Python's built-in dict getters (i.e.
<code>dct['key']</code> or <code>dct.get('key')</code>), because it adds more specific
functionality for handling defaults / key errors.
There also exists the <code>.trs()</code> method, which is a deeper-level
getter, i.e. it pulls out the (section-level) LotDefinitions object
from another level down in this dict structure; rather than the
(Twp/Rge-level) TwpLotDefinitions object, which is stored as a value
of this dict.</p>
<p>NOTE: If a string filepath to a properly formatted** .csv file is
passed as init parameter <code>from_csv=</code>, the object will load the data
represented in the .csv file. (See below for proper formatting.)</p>
<p>** For proper .csv formatting, follow these guidelines (and see the
example <code>SAMPLE_LDDB.csv</code> in the documentation):
1) These 5 headers MUST exist, all lowercase:
twp, rge, sec, lot, qq
2) twp must be specified in the format '000x'
ex: '154n' for Township 154 North; '1s' for Township 7 South
(without quotation marks)
3) rge must be specified in the format '000x'
ex: '97w' for Range 97 West; '6e' for Range 6 East
(without quotation marks)
4) sec and lot should integers (non-numeric lots cannot
currently be handled)
5) qq should be in the format as follows:
a) 'NENE' for 'Northeast Quarter of the Northeast Quarter';
'W2' for 'West Half'; 'ALL' for 'ALL' &hellip;
(These get passed through pyTRS parsing, so
reasonable abbreviations SHOULD be captured&hellip;)
b) If a lot comprises more than a single QQ, separate QQs by
comma (with no space), and/or use larger aliquot
divisions as appropriate.
ex: Lot 1 that comprises the N/2NE/4 could be
specified under the 'qq' columns as 'N2NE'
(without quotation marks)
ex: Lot 4 that sprawls across the E/2NW/4 and
SW/4NW/4 could be specified under the 'qq'
column as 'E2NW,SWNW' (without quotation
marks)
6) Any other columns (e.g., 'COMMENTS') should be acceptable but
will be ignored.
7) Duplicate lot entries will result in only the last-entered
row being effective. If a lot comprises multiple QQ's,
keep it on a single row, and refer to list item #5 above
on how to handle it.
8) Keep in mind that extra long .csv files might conceivably
take a while to process and/or result in a LotDefDB that
burdens the system's memory.</p>
<p>A nested dict of definitions of how specific lots should be
interpreted, in terms of their QQ counterparts.
:param from_csv: (Optional) The filepath to a .csv file that
contains properly formatted data, which can be loaded into this
LotDefDB object. (See LotDefDB documentation for guidelines on
how a .csv file must be formatted.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LotDefDB(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;lddb&#39; or &#39;LDDB&#39; in code
    comments and documentation) for defining which lots correspond to
    which QQs, for any number of sections in any number of Twp/Rge&#39;s.
    Keyed by Twp/Rge (as a single string, i.e. &#39;154n97w&#39; for T154N-R97W
    or &#39;1s7e&#39; for T1S-R7E), whose values are a TwpLotDefinition object
    for that Twp/Rge.

    A pyTRSplat.LotDefDB object is a nested dict with this structure:
    - LotDefDB - dict, keyed by Twp/Rge (str), value-type:
    -- TwpLotDefinitions - dict, keyed by sec number (int), value-type:
    --- LotDefinitions - dict, keyed by lot name (ex: &#39;L2&#39;), value-type:
    ---- a string, being QQ name(s), separated by comma if more than one
            (i.e. how each lot should be interpreted in terms of QQ&#39;s
                ex: &#39;L2&#39; -&gt; &#39;NWNE&#39;)
    Thus, rudimentary access might be:
        lddb_obj[&#39;154n97w&#39;][1][&#39;L2&#39;] -&gt; &#39;NWNE&#39;
            (i.e. Lot 2, of Sec 1, T154N-R97W corresponds with the
            NW/4NE/4 of said section)
    However, see custom getter methods `LotDefDB.get_tld()` and
    `LotDefDB.trs()`, which have more robust handling of default /
    unspecified values. (See also `TwpLotDefinitions.get_ld()` method
    for similar reasons.)

    The `.get_tld()` method (for getting TwpLotDefinitions by `twprge`
    key) is recommended over Python&#39;s built-in dict getters (i.e.
    `dct[&#39;key&#39;]` or `dct.get(&#39;key&#39;)`), because it adds more specific
    functionality for handling defaults / key errors.
    There also exists the `.trs()` method, which is a deeper-level
    getter, i.e. it pulls out the (section-level) LotDefinitions object
    from another level down in this dict structure; rather than the
    (Twp/Rge-level) TwpLotDefinitions object, which is stored as a value
    of this dict.

    NOTE: If a string filepath to a properly formatted** .csv file is
    passed as init parameter `from_csv=`, the object will load the data
    represented in the .csv file. (See below for proper formatting.)

    ** For proper .csv formatting, follow these guidelines (and see the
    example `SAMPLE_LDDB.csv` in the documentation):
        1) These 5 headers MUST exist, all lowercase:
                twp, rge, sec, lot, qq
        2) twp must be specified in the format &#39;000x&#39;
            ex: &#39;154n&#39; for Township 154 North; &#39;1s&#39; for Township 7 South
                (without quotation marks)
        3) rge must be specified in the format &#39;000x&#39;
            ex: &#39;97w&#39; for Range 97 West; &#39;6e&#39; for Range 6 East
                (without quotation marks)
        4) sec and lot should integers (non-numeric lots cannot
                currently be handled)
        5) qq should be in the format as follows:
            a) &#39;NENE&#39; for &#39;Northeast Quarter of the Northeast Quarter&#39;;
                    &#39;W2&#39; for &#39;West Half&#39;; &#39;ALL&#39; for &#39;ALL&#39; ...
                        (These get passed through pyTRS parsing, so
                        reasonable abbreviations SHOULD be captured...)
            b) If a lot comprises more than a single QQ, separate QQs by
                    comma (with no space), and/or use larger aliquot
                    divisions as appropriate.
                        ex: Lot 1 that comprises the N/2NE/4 could be
                            specified under the &#39;qq&#39; columns as &#39;N2NE&#39;
                            (without quotation marks)
                        ex: Lot 4 that sprawls across the E/2NW/4 and
                            SW/4NW/4 could be specified under the &#39;qq&#39;
                            column as &#39;E2NW,SWNW&#39; (without quotation
                            marks)
        6) Any other columns (e.g., &#39;COMMENTS&#39;) should be acceptable but
                will be ignored.
        7) Duplicate lot entries will result in only the last-entered
                row being effective. If a lot comprises multiple QQ&#39;s,
                keep it on a single row, and refer to list item #5 above
                on how to handle it.
        8) Keep in mind that extra long .csv files might conceivably
                take a while to process and/or result in a LotDefDB that
                burdens the system&#39;s memory.&#34;&#34;&#34;

    def __init__(self, from_csv=None):
        &#34;&#34;&#34;
        A nested dict of definitions of how specific lots should be
        interpreted, in terms of their QQ counterparts.
        :param from_csv: (Optional) The filepath to a .csv file that
        contains properly formatted data, which can be loaded into this
        LotDefDB object. (See LotDefDB documentation for guidelines on
        how a .csv file must be formatted.)
        &#34;&#34;&#34;
        super().__init__()
        if from_csv is not None:
            self._import_csv(from_csv)

    def _import_csv(self, fp):
        &#34;&#34;&#34;
        Read in a properly formatted** .csv file at filepath `fp`, and
        convert each unique T&amp;R represented in the .csv file into a
        separate TwpLotDefinitions object, keyed by T&amp;R (keys formatted
        &#39;000x000y&#39; or fewer digits -- ex: &#39;154n97w&#39; for T154N-R97W, or
        &#39;1s6e&#39; for T1S-R6E).

        **See the docstring for LotDefDB for proper .csv formatting.
        &#34;&#34;&#34;

        from pathlib import Path

        # Confirm that we&#39;re going to read &#39;.csv&#39; file.
        if Path(fp).suffix.lower() != &#39;.csv&#39;:
            raise ValueError(&#34;Filepath must end in &#39;.csv&#39;&#34;)

        import csv
        f = open(fp, &#39;r&#39;)
        reader = csv.DictReader(f)

        for row in reader:
            twp, rge = row[&#39;twp&#39;].lower(), row[&#39;rge&#39;].lower()
            sec = int(row[&#39;sec&#39;])
            lot, qq = row[&#39;lot&#39;], row[&#39;qq&#39;]
            # If no TLD has yet been created for this T&amp;R, do it now.
            self.setdefault(twp + rge, TwpLotDefinitions())

            # Add this lot/qq definition for the section/twp/rge on this row.
            self[twp + rge].setdefault(sec, LotDefinitions())
            self[twp + rge][sec].set_lot(lot, qq)

    def set_twp(self, twprge, tld_obj):
        &#34;&#34;&#34;
        Set the TwpLotDefinitions object for a specified `twprge`
        (formatted &#39;000x000z&#39; or fewer digits, if not needed).
        &#34;&#34;&#34;
        # This need not be a defined method, but it&#39;s more intuitively
        # named, so... why not.
        self[twprge] = tld_obj

    def get_tld(self, twprge, allow_ld_defaults=False,
                force_tld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling TwpLotDefinitions object for the
        requested `twprge`, out of this LotDefDB object. There are two
        parameters to dictate the behavior of this getter, in the event
        that the key (`twprge`) does not exist in this dict, and they
        apply in order:
        -- `allow_ld_defaults` (defaults to False): If an explicit
        LotDefinitions object does not already exist for the requested
        key (`sec_num`), then create and return a TwpLotDefinitions
        object with default definitions for every section (i.e. sections
        1 - 7, 18, 19, 30, and 31 will have LotDefinitions objects with
        some lots defined (per a &#39;standard&#39; township); but all other
        sections have empty LotDefinitions objects).
            NOTE: This getter does NOT add the returned default
                TwpLotDefinitions object to the LotDefDB object!
        -- `force_tld_return` (defaults to False): If an explicit
        TwpLotDefinitions object does not already exist, and the user
        did not want a default TwpLotDefinitions object as a backup,
        then this parameter dictates whether to return None (i.e.
        `=False`), or to return an empty TwpLotDefinitions object (i.e.
        `=True`).
            NOTE: This getter does NOT add the returned empty
                TwpLotDefinitions object to the LotDefDB object!

        :param twprge: The Twp/Rge combo (e.g. &#39;154n97w&#39;, &#39;1s8e&#39;, etc.),
        whose TwpLotDefinitions object is requested (i.e. the dict key).
        :param allow_ld_defaults: As discussed above.
        :param force_tld_return:  As discussed above.
        :return: If [a] a TwpLotDefinitions object exists for the
        requested twprge, [b] the user passed `allow_ld_defaults=True`,
        AND/OR [c] the user passed `force_tld_return=True` -- then will
        return a TwpLotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        tld = self.get(twprge, None)
        if tld is not None:
            return tld
        elif allow_ld_defaults:
            # If there was no TLD set for this twprge, but the user wants
            # to allow default TLD&#39;s, generate and return one now.
            return TwpLotDefinitions(
                default_sections=[i for i in range(0, 37)])
        elif force_tld_return:
            return TwpLotDefinitions()
        else:
            return None

    def trs(self, trs, allow_ld_defaults=None, force_ld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling the (section-level) LotDefinitions
        object for the specified `trs` (i.e. Twp/Rge/Sec), if one
        exists in this LotDefDB.

        Like the`TwpLotDefinitions.get_ld()`, this has two backup
        parameters that take over if no such LotDefinitions object
        exists, both with equivalent functionality as in that method:
        -- `allow_ld_defaults` (defaults to False)
        -- `force_ld_return` (defaults to False)
        NOTE: This getter will not set the returned default/empty
            LotDefinitions object (if any) to this LotDefDB object!

        :param trs: The Twp/Rge/Sec of the desired section, in the
        format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
        digits for section).
            ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
        :param allow_ld_defaults: As discussed above.
        :param force_ld_return:  As discussed above.
        :return: If [a] a LotDefinitions object exists for the requested
        section, [b] the user passed `allow_ld_defaults=True`, AND/OR
        [c] the user passed `force_ld_return=True` -- then will return a
        LotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        twp, rge, sec = pyTRS.break_trs(trs)
        twprge = twp + rge
        tld = self.get_tld(
            twprge, allow_ld_defaults=allow_ld_defaults,
            force_tld_return=force_ld_return)
        if tld is not None:
            return tld.get_ld(
                sec_num=int(sec), allow_ld_defaults=allow_ld_defaults,
                force_ld_return=force_ld_return)
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.LotDefDB.get_tld"><code class="name flex">
<span>def <span class="ident">get_tld</span></span>(<span>self, twprge, allow_ld_defaults=False, force_tld_return=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A custom getter for pulling TwpLotDefinitions object for the
requested <code>twprge</code>, out of this LotDefDB object. There are two
parameters to dictate the behavior of this getter, in the event
that the key (<code>twprge</code>) does not exist in this dict, and they
apply in order:
&ndash; <code>allow_ld_defaults</code> (defaults to False): If an explicit
LotDefinitions object does not already exist for the requested
key (<code>sec_num</code>), then create and return a TwpLotDefinitions
object with default definitions for every section (i.e. sections
1 - 7, 18, 19, 30, and 31 will have LotDefinitions objects with
some lots defined (per a 'standard' township); but all other
sections have empty LotDefinitions objects).
NOTE: This getter does NOT add the returned default
TwpLotDefinitions object to the LotDefDB object!
&ndash; <code>force_tld_return</code> (defaults to False): If an explicit
TwpLotDefinitions object does not already exist, and the user
did not want a default TwpLotDefinitions object as a backup,
then this parameter dictates whether to return None (i.e.
<code>=False</code>), or to return an empty TwpLotDefinitions object (i.e.
<code>=True</code>).
NOTE: This getter does NOT add the returned empty
TwpLotDefinitions object to the LotDefDB object!</p>
<p>:param twprge: The Twp/Rge combo (e.g. '154n97w', '1s8e', etc.),
whose TwpLotDefinitions object is requested (i.e. the dict key).
:param allow_ld_defaults: As discussed above.
:param force_tld_return:
As discussed above.
:return: If [a] a TwpLotDefinitions object exists for the
requested twprge, [b] the user passed <code>allow_ld_defaults=True</code>,
AND/OR [c] the user passed <code>force_tld_return=True</code> &ndash; then will
return a TwpLotDefinitions object. Otherwise, will return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tld(self, twprge, allow_ld_defaults=False,
            force_tld_return=False):
    &#34;&#34;&#34;
    A custom getter for pulling TwpLotDefinitions object for the
    requested `twprge`, out of this LotDefDB object. There are two
    parameters to dictate the behavior of this getter, in the event
    that the key (`twprge`) does not exist in this dict, and they
    apply in order:
    -- `allow_ld_defaults` (defaults to False): If an explicit
    LotDefinitions object does not already exist for the requested
    key (`sec_num`), then create and return a TwpLotDefinitions
    object with default definitions for every section (i.e. sections
    1 - 7, 18, 19, 30, and 31 will have LotDefinitions objects with
    some lots defined (per a &#39;standard&#39; township); but all other
    sections have empty LotDefinitions objects).
        NOTE: This getter does NOT add the returned default
            TwpLotDefinitions object to the LotDefDB object!
    -- `force_tld_return` (defaults to False): If an explicit
    TwpLotDefinitions object does not already exist, and the user
    did not want a default TwpLotDefinitions object as a backup,
    then this parameter dictates whether to return None (i.e.
    `=False`), or to return an empty TwpLotDefinitions object (i.e.
    `=True`).
        NOTE: This getter does NOT add the returned empty
            TwpLotDefinitions object to the LotDefDB object!

    :param twprge: The Twp/Rge combo (e.g. &#39;154n97w&#39;, &#39;1s8e&#39;, etc.),
    whose TwpLotDefinitions object is requested (i.e. the dict key).
    :param allow_ld_defaults: As discussed above.
    :param force_tld_return:  As discussed above.
    :return: If [a] a TwpLotDefinitions object exists for the
    requested twprge, [b] the user passed `allow_ld_defaults=True`,
    AND/OR [c] the user passed `force_tld_return=True` -- then will
    return a TwpLotDefinitions object. Otherwise, will return None.
    &#34;&#34;&#34;

    tld = self.get(twprge, None)
    if tld is not None:
        return tld
    elif allow_ld_defaults:
        # If there was no TLD set for this twprge, but the user wants
        # to allow default TLD&#39;s, generate and return one now.
        return TwpLotDefinitions(
            default_sections=[i for i in range(0, 37)])
    elif force_tld_return:
        return TwpLotDefinitions()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefDB.set_twp"><code class="name flex">
<span>def <span class="ident">set_twp</span></span>(<span>self, twprge, tld_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the TwpLotDefinitions object for a specified <code>twprge</code>
(formatted '000x000z' or fewer digits, if not needed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_twp(self, twprge, tld_obj):
    &#34;&#34;&#34;
    Set the TwpLotDefinitions object for a specified `twprge`
    (formatted &#39;000x000z&#39; or fewer digits, if not needed).
    &#34;&#34;&#34;
    # This need not be a defined method, but it&#39;s more intuitively
    # named, so... why not.
    self[twprge] = tld_obj</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefDB.trs"><code class="name flex">
<span>def <span class="ident">trs</span></span>(<span>self, trs, allow_ld_defaults=None, force_ld_return=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A custom getter for pulling the (section-level) LotDefinitions
object for the specified <code>trs</code> (i.e. Twp/Rge/Sec), if one
exists in this LotDefDB.</p>
<p>Like the<code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld">TwpLotDefinitions.get_ld()</a></code>, this has two backup
parameters that take over if no such LotDefinitions object
exists, both with equivalent functionality as in that method:
&ndash; <code>allow_ld_defaults</code> (defaults to False)
&ndash; <code>force_ld_return</code> (defaults to False)
NOTE: This getter will not set the returned default/empty
LotDefinitions object (if any) to this LotDefDB object!</p>
<p>:param trs: The Twp/Rge/Sec of the desired section, in the
format '000x000x00' (up to 3 digits for twp and rge, exactly 2
digits for section).
ex: '154n97w01', '1s7e36', etc.
:param allow_ld_defaults: As discussed above.
:param force_ld_return:
As discussed above.
:return: If [a] a LotDefinitions object exists for the requested
section, [b] the user passed <code>allow_ld_defaults=True</code>, AND/OR
[c] the user passed <code>force_ld_return=True</code> &ndash; then will return a
LotDefinitions object. Otherwise, will return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trs(self, trs, allow_ld_defaults=None, force_ld_return=False):
    &#34;&#34;&#34;
    A custom getter for pulling the (section-level) LotDefinitions
    object for the specified `trs` (i.e. Twp/Rge/Sec), if one
    exists in this LotDefDB.

    Like the`TwpLotDefinitions.get_ld()`, this has two backup
    parameters that take over if no such LotDefinitions object
    exists, both with equivalent functionality as in that method:
    -- `allow_ld_defaults` (defaults to False)
    -- `force_ld_return` (defaults to False)
    NOTE: This getter will not set the returned default/empty
        LotDefinitions object (if any) to this LotDefDB object!

    :param trs: The Twp/Rge/Sec of the desired section, in the
    format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
    digits for section).
        ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
    :param allow_ld_defaults: As discussed above.
    :param force_ld_return:  As discussed above.
    :return: If [a] a LotDefinitions object exists for the requested
    section, [b] the user passed `allow_ld_defaults=True`, AND/OR
    [c] the user passed `force_ld_return=True` -- then will return a
    LotDefinitions object. Otherwise, will return None.
    &#34;&#34;&#34;

    twp, rge, sec = pyTRS.break_trs(trs)
    twprge = twp + rge
    tld = self.get_tld(
        twprge, allow_ld_defaults=allow_ld_defaults,
        force_tld_return=force_ld_return)
    if tld is not None:
        return tld.get_ld(
            sec_num=int(sec), allow_ld_defaults=allow_ld_defaults,
            force_ld_return=force_ld_return)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions"><code class="flex name class">
<span>class <span class="ident">LotDefinitions</span></span>
<span>(</span><span>default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A dict object (which often get abbreviated 'ld' or 'LD' in code
comments and documentation) for defining which lots correspond to
which QQ in a given section. At init, pass in an int 1 - 36
(inclusive) to set to the /default/ for that section in a STANDARD
township (i.e. perhaps 'better-than-nothing').</p>
<p>These objects can also be contained within a TwpLotDefinitions
object for a 36-section collection of such lot-to-QQ definitions.
In turn, TwpLotDefinitions can be contained within a LotDefDB
object for definitions of lots in the sections of any number of
townships.</p>
<p>See <code>LotDefDB.from_csv()</code> or <code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv">TwpLotDefinitions.from_csv()</a></code> for
loading larger databases from .csv files, rather than creating
LotDefinitions objects individually.</p>
<p>Additional documentation on LotDefinitions is maintained under
pyTRSplat.LotDefDB objects, to avoid undue repetition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LotDefinitions(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;ld&#39; or &#39;LD&#39; in code
    comments and documentation) for defining which lots correspond to
    which QQ in a given section. At init, pass in an int 1 - 36
    (inclusive) to set to the /default/ for that section in a STANDARD
    township (i.e. perhaps &#39;better-than-nothing&#39;).

    These objects can also be contained within a TwpLotDefinitions
    object for a 36-section collection of such lot-to-QQ definitions.
    In turn, TwpLotDefinitions can be contained within a LotDefDB
    object for definitions of lots in the sections of any number of
    townships.

    See `LotDefDB.from_csv()` or `TwpLotDefinitions.from_csv()` for
    loading larger databases from .csv files, rather than creating
    LotDefinitions objects individually.

    Additional documentation on LotDefinitions is maintained under
    pyTRSplat.LotDefDB objects, to avoid undue repetition.
    &#34;&#34;&#34;

    # Below are defaults for sections in a &#39;standard&#39; 6x6 Township grid.
    # (Sections along the north and west boundaries of the township have
    # &#39;expected&#39; lot locations. In practice, these might only RARELY be
    # the only lots in a township, and they are not always consistent,
    # even within these sections. Even so, it is better than nothing.)

    DEF_01_to_05 = {
        &#39;L1&#39;: &#39;NENE&#39;,
        &#39;L2&#39;: &#39;NWNE&#39;,
        &#39;L3&#39;: &#39;NENW&#39;,
        &#39;L4&#39;: &#39;NWNW&#39;
    }

    DEF_06 = {
        &#39;L1&#39;: &#39;NENE&#39;,
        &#39;L2&#39;: &#39;NWNE&#39;,
        &#39;L3&#39;: &#39;NENW&#39;,
        &#39;L4&#39;: &#39;NWNW&#39;,
        &#39;L5&#39;: &#39;SWNW&#39;,
        &#39;L6&#39;: &#39;NWSW&#39;,
        &#39;L7&#39;: &#39;SWSW&#39;,
    }

    DEF_07_18_19_30_31 = {
        &#39;L1&#39;: &#39;NWNW&#39;,
        &#39;L2&#39;: &#39;SWNW&#39;,
        &#39;L3&#39;: &#39;NWSW&#39;,
        &#39;L4&#39;: &#39;SWSW&#39;
    }

    # All other sections in a /standard/ Twp have no lots.
    DEF_00 = {}

    def __init__(self, default=None):
        super().__init__()

        # If default is specified, we&#39;ll absorb that standard dict for
        # this LD object.
        if isinstance(default, dict):
            self.absorb_ld(default)
        elif default in [1, 2, 3, 4, 5]:
            self.absorb_ld(LotDefinitions.DEF_01_to_05)
        elif default == 6:
            self.absorb_ld(LotDefinitions.DEF_06)
        elif default in [7, 18, 19, 30, 31]:
            self.absorb_ld(LotDefinitions.DEF_07_18_19_30_31)
        else:
            self.absorb_ld(LotDefinitions.DEF_00)

    def set_lot(self, lot, definition):
        &#34;&#34;&#34;Set definition (value) to lot (key). Overwrite, if already
        exists. Using this method ensures that the resulting format will
        be as expected elsewhere in the program (assuming input format
        is acceptable), by passing definitions through pyTRS parsing.&#34;&#34;&#34;

        # If no leading &#39;L&#39; was fed in, add it now (e.g. 1 -&gt; &#39;L1&#39;)
        if str(lot).upper()[0] != &#39;L&#39;:
            lot = &#39;L&#39; + str(lot).upper()

        # Ensure the definitions are broken down into QQ&#39;s by passing them
        # through pyTRS.Tract parsing, and pulling the resulting QQList.
        qq_list = pyTRS.Tract(
            desc=definition, initParseQQ=True, config=&#39;cleanQQ&#39;).QQList
        self[lot] = &#39;,&#39;.join(qq_list)

    def absorb_ld(self, dct):
        &#34;&#34;&#34;Absorb another LotDefinitions object. Will overwrite existing
        keys, if any. Using this method ensures that the resulting
        format will be as expected elsewhere in the program (assuming
        input format is acceptable), by passing definitions through
        pyTRS parsing.&#34;&#34;&#34;
        for lot, definition in dct.items():
            self.set_lot(lot, definition)

    def lots_by_qq_name(self) -&gt; dict:
        &#34;&#34;&#34;Get a dict, with QQ&#39;s as keys (e.g., &#39;NENE&#39;), and whose
        values are each a list of the lot(s) that correspond with those
        QQ&#39;s (e.g., &#39;L1&#39;). Note that it is possible for more than 1 lot
        per QQ, so each value is a list.&#34;&#34;&#34;
        ret_dict = {}
        for k, v in self.items():
            list_of_qqs = _smooth_QQs(v)
            for qq in list_of_qqs:
                if qq in ret_dict.keys():
                    ret_dict[qq].append(k)
                else:
                    ret_dict[qq] = [k]
        return ret_dict</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.DEF_00"><code class="name">var <span class="ident">DEF_00</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.DEF_01_to_05"><code class="name">var <span class="ident">DEF_01_to_05</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.DEF_06"><code class="name">var <span class="ident">DEF_06</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.DEF_07_18_19_30_31"><code class="name">var <span class="ident">DEF_07_18_19_30_31</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.absorb_ld"><code class="name flex">
<span>def <span class="ident">absorb_ld</span></span>(<span>self, dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Absorb another LotDefinitions object. Will overwrite existing
keys, if any. Using this method ensures that the resulting
format will be as expected elsewhere in the program (assuming
input format is acceptable), by passing definitions through
pyTRS parsing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absorb_ld(self, dct):
    &#34;&#34;&#34;Absorb another LotDefinitions object. Will overwrite existing
    keys, if any. Using this method ensures that the resulting
    format will be as expected elsewhere in the program (assuming
    input format is acceptable), by passing definitions through
    pyTRS parsing.&#34;&#34;&#34;
    for lot, definition in dct.items():
        self.set_lot(lot, definition)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.lots_by_qq_name"><code class="name flex">
<span>def <span class="ident">lots_by_qq_name</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get a dict, with QQ's as keys (e.g., 'NENE'), and whose
values are each a list of the lot(s) that correspond with those
QQ's (e.g., 'L1'). Note that it is possible for more than 1 lot
per QQ, so each value is a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lots_by_qq_name(self) -&gt; dict:
    &#34;&#34;&#34;Get a dict, with QQ&#39;s as keys (e.g., &#39;NENE&#39;), and whose
    values are each a list of the lot(s) that correspond with those
    QQ&#39;s (e.g., &#39;L1&#39;). Note that it is possible for more than 1 lot
    per QQ, so each value is a list.&#34;&#34;&#34;
    ret_dict = {}
    for k, v in self.items():
        list_of_qqs = _smooth_QQs(v)
        for qq in list_of_qqs:
            if qq in ret_dict.keys():
                ret_dict[qq].append(k)
            else:
                ret_dict[qq] = [k]
    return ret_dict</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.LotDefinitions.set_lot"><code class="name flex">
<span>def <span class="ident">set_lot</span></span>(<span>self, lot, definition)</span>
</code></dt>
<dd>
<div class="desc"><p>Set definition (value) to lot (key). Overwrite, if already
exists. Using this method ensures that the resulting format will
be as expected elsewhere in the program (assuming input format
is acceptable), by passing definitions through pyTRS parsing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_lot(self, lot, definition):
    &#34;&#34;&#34;Set definition (value) to lot (key). Overwrite, if already
    exists. Using this method ensures that the resulting format will
    be as expected elsewhere in the program (assuming input format
    is acceptable), by passing definitions through pyTRS parsing.&#34;&#34;&#34;

    # If no leading &#39;L&#39; was fed in, add it now (e.g. 1 -&gt; &#39;L1&#39;)
    if str(lot).upper()[0] != &#39;L&#39;:
        lot = &#39;L&#39; + str(lot).upper()

    # Ensure the definitions are broken down into QQ&#39;s by passing them
    # through pyTRS.Tract parsing, and pulling the resulting QQList.
    qq_list = pyTRS.Tract(
        desc=definition, initParseQQ=True, config=&#39;cleanQQ&#39;).QQList
    self[lot] = &#39;,&#39;.join(qq_list)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid"><code class="flex name class">
<span>class <span class="ident">SectionGrid</span></span>
<span>(</span><span>sec='', twp='', rge='', ld=None, allow_ld_defaults=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A grid of a single Section, divided into standard PLSS aliquot
quarter-quarters (QQs) &ndash; i.e. 4x4 for a standard section.
Takes optional <code>ld=</code> argument for specifying a LotDefinitions object
(defaults to a 'standard' township layout if not specified &ndash; i.e.
Sections 1 - 7, 18, 19, 30, and 31 have lots, because they are along
the northern and/or western boundaries of the township). A
TwpLotDefinitions object may also be passed, so long as <code>sec</code>,
<code>twp</code>, and <code>rge</code> are also correctly specified.</p>
<p>If <code>sec=&lt;int or str&gt;</code>, <code>twp=&lt;str&gt;</code>, and <code>rge=&lt;str&gt;</code> are not
specified at init, the object may not have full functionality in
conjunction with other modules.
&ndash;example:
sg_obj = SectionGrid(<code>sec=14, twp='154n', rge='97w')
--equivalently:
sg_obj = SectionGrid.from_trs('154n97w14')
(Passing</code>ld=&hellip;` in either example is optional, but advisable.)</p>
<p>If a lot was not defined for this SectionGrid but the lot is
incorporated into the SectionGrid anyway, it will not set any hits,
but the lot will be added to the list in the <code>.unhandled_lots</code>
attribute.</p>
<p>QQ's have been assigned these coordinates, with (0,0) being the NWNW
and (3,3) being the SESE &ndash; i.e. moving from top-to-bottom and
left-to-right:</p>
<hr>
<p>| NWNW -&gt; (0,0) | NENW -&gt; (1,0) || NWNE -&gt; (2,0) | NENE -&gt; (3,0) |
|---------------+---------------++---------------+---------------|
| SWNW -&gt; (0,1) | SENW -&gt; (1,1) || SWNE -&gt; (2,1) | SENE -&gt; (3,1) |
|===============+===============++===============+===============|
| NWSW -&gt; (0,2) | SESW -&gt; (1,2) || NWSE -&gt; (2,2) | NESE -&gt; (3,2) |
|---------------+---------------++---------------+---------------|
| SWSW -&gt; (0,3) | SESW -&gt; (1,3) || SWSE -&gt; (2,3) | SESE -&gt; (3,3) |</p>
<hr>
<p>:param sec: Section number (passed as an int, or as a 2-digit
string).
:param twp: Township number (up to 3 digits) and N/S direction
(as a single lowercase character).
ex: '154n', '1s', etc.
:param rge: Range number (up to 3 digits) and E/W direction
(as a single lowercase character).
ex: '97w', '7e', etc.
:param ld: A pyTRSplat.LotDefinitions object, defining how lots
should be interpreted in this section, in terms of QQs.
:param allow_ld_defaults: Whether 'default' lot definitions are
allowed as a fall-back option, when lots have not been
explicitly defined for a given section. (Default lots are the
'usual' lots in Sections 1 - 7, 18, 19, 30, and 31 of a
'standard' township &ndash; i.e. along the northern and western
boundaries of a township. Potentially useful as a 'better-than-
nothing' option, but not as reliable as user-specified lot
definitions.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SectionGrid:
    &#34;&#34;&#34;
    A grid of a single Section, divided into standard PLSS aliquot
    quarter-quarters (QQs) -- i.e. 4x4 for a standard section.
    Takes optional `ld=` argument for specifying a LotDefinitions object
    (defaults to a &#39;standard&#39; township layout if not specified -- i.e.
    Sections 1 - 7, 18, 19, 30, and 31 have lots, because they are along
    the northern and/or western boundaries of the township). A
    TwpLotDefinitions object may also be passed, so long as `sec`,
    `twp`, and `rge` are also correctly specified.

    If `sec=&lt;int or str&gt;`, `twp=&lt;str&gt;`, and `rge=&lt;str&gt;` are not
    specified at init, the object may not have full functionality in
    conjunction with other modules.
        --example:
            sg_obj = SectionGrid(`sec=14, twp=&#39;154n&#39;, rge=&#39;97w&#39;)
        --equivalently:
            sg_obj = SectionGrid.from_trs(&#39;154n97w14&#39;)
    (Passing `ld=...` in either example is optional, but advisable.)

    If a lot was not defined for this SectionGrid but the lot is
    incorporated into the SectionGrid anyway, it will not set any hits,
    but the lot will be added to the list in the `.unhandled_lots`
    attribute.

    QQ&#39;s have been assigned these coordinates, with (0,0) being the NWNW
    and (3,3) being the SESE -- i.e. moving from top-to-bottom and
    left-to-right:
    ------------------------------------------------------------------
    | NWNW -&gt; (0,0) | NENW -&gt; (1,0) || NWNE -&gt; (2,0) | NENE -&gt; (3,0) |
    |---------------+---------------++---------------+---------------|
    | SWNW -&gt; (0,1) | SENW -&gt; (1,1) || SWNE -&gt; (2,1) | SENE -&gt; (3,1) |
    |===============+===============++===============+===============|
    | NWSW -&gt; (0,2) | SESW -&gt; (1,2) || NWSE -&gt; (2,2) | NESE -&gt; (3,2) |
    |---------------+---------------++---------------+---------------|
    | SWSW -&gt; (0,3) | SESW -&gt; (1,3) || SWSE -&gt; (2,3) | SESE -&gt; (3,3) |
    ------------------------------------------------------------------
    &#34;&#34;&#34;

    def __init__(
            self, sec=&#39;&#39;, twp=&#39;&#39;, rge=&#39;&#39;, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;

        :param sec: Section number (passed as an int, or as a 2-digit
        string).
        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :param ld: A pyTRSplat.LotDefinitions object, defining how lots
        should be interpreted in this section, in terms of QQs.
        :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
        allowed as a fall-back option, when lots have not been
        explicitly defined for a given section. (Default lots are the
        &#39;usual&#39; lots in Sections 1 - 7, 18, 19, 30, and 31 of a
        &#39;standard&#39; township -- i.e. along the northern and western
        boundaries of a township. Potentially useful as a &#39;better-than-
        nothing&#39; option, but not as reliable as user-specified lot
        definitions.)
        &#34;&#34;&#34;

        # Note: twp and rge should have their direction specified
        #   (&#39;n&#39; or &#39;s&#39; for twp; and &#39;e&#39; or &#39;w&#39; for rge). Without doing
        #   so, various functionality may break.

        twp = twp.lower()
        rge = rge.lower()
        self.twp = twp
        self.rge = rge

        # &#39;secError&#39; can be returned by pyTRS in the event of a flawed
        # parse, so we handle this by setting to 0 (a meaningless number
        # for a section that can&#39;t exist in reality) to avoid causing
        # ValueError when converting to int elsewhere.
        if sec == &#39;secError&#39;:
            sec = 0

        # Ensure sec is formatted as a two digit string -- ex: &#39;01&#39;
        sec = str(int(sec)).rjust(2, &#39;0&#39;)

        self.sec = sec
        self.twprge = twp + rge
        self.trs = f&#34;{twp}{rge}{sec}&#34;.lower()
        self.unhandled_lots = []

        try:
            sec_num = int(sec)
        except ValueError:
            sec_num = 0

        self.ld = {}
        if ld is None and allow_ld_defaults:
            # If ld was not specified, but the user wants to allow
            # defaults (i.e. for Sections 1 - 7, 18, 19, 30, and 31)
            self.ld = LotDefinitions(default=sec_num)
        elif isinstance(ld, LotDefinitions):
            self.ld = ld
        elif isinstance(ld, TwpLotDefinitions):
            # If the user passed a TLD object (which contains LotDefinitions
            # objects), then pull the appropriate LD object (based on the
            # section number); and if it doesn&#39;t exist, create a new (empty)
            # LD object
            self.ld = ld.get(int(sec), LotDefinitions())
        else:
            # Otherwise, an empty LD.
            self.ld = LotDefinitions()

        # A dict for the 16 aliquot divisions of a standard section,
        # with (0, 0) being NWNW and (3, 3) being SESE -- i.e. beginning
        # at the NWNW, and running east and south. The nested dict for
        # each QQ contains the x,y coordinates in the grid, and whether
        # that QQ has been switched `on` -- i.e. &#39;val&#39;, which is either
        # 0 (&#39;nothing&#39;) or 1 (&#39;something&#39;) to track whether the QQ
        # (or equivalent Lot) was identified in the tract description.
        self.QQgrid = {
            &#39;NWNW&#39;: {&#39;coord&#39;: (0, 0), &#39;val&#39;: 0},
            &#39;NENW&#39;: {&#39;coord&#39;: (1, 0), &#39;val&#39;: 0},
            &#39;NWNE&#39;: {&#39;coord&#39;: (2, 0), &#39;val&#39;: 0},
            &#39;NENE&#39;: {&#39;coord&#39;: (3, 0), &#39;val&#39;: 0},
            &#39;SWNW&#39;: {&#39;coord&#39;: (0, 1), &#39;val&#39;: 0},
            &#39;SENW&#39;: {&#39;coord&#39;: (1, 1), &#39;val&#39;: 0},
            &#39;SWNE&#39;: {&#39;coord&#39;: (2, 1), &#39;val&#39;: 0},
            &#39;SENE&#39;: {&#39;coord&#39;: (3, 1), &#39;val&#39;: 0},
            &#39;NWSW&#39;: {&#39;coord&#39;: (0, 2), &#39;val&#39;: 0},
            &#39;NESW&#39;: {&#39;coord&#39;: (1, 2), &#39;val&#39;: 0},
            &#39;NWSE&#39;: {&#39;coord&#39;: (2, 2), &#39;val&#39;: 0},
            &#39;NESE&#39;: {&#39;coord&#39;: (3, 2), &#39;val&#39;: 0},
            &#39;SWSW&#39;: {&#39;coord&#39;: (0, 3), &#39;val&#39;: 0},
            &#39;SESW&#39;: {&#39;coord&#39;: (1, 3), &#39;val&#39;: 0},
            &#39;SWSE&#39;: {&#39;coord&#39;: (2, 3), &#39;val&#39;: 0},
            &#39;SESE&#39;: {&#39;coord&#39;: (3, 3), &#39;val&#39;: 0}
        }

        # Whether this SectionGrid has been &#39;pinged&#39; by a setter (e.g.,
        # by `.incorporate_lot_list()` -- even if no values were
        # actually set, or if values were later reset to 0).
        self._was_pinged = False

    @staticmethod
    def from_trs(trs=&#39;&#39;, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        Create and return a SectionGrid object by passing in a TRS
        (e.g., &#39;154n97w14&#39;), rather than the separate Sec, Twp, Rge
        components. Also takes optional `ld` argument for specifying
        LotDefinitions object.

        All available parameters have the same effect as for vanilla
        __init__(), except:
        :param trs: The Twp/Rge/Sec specified as a single string, in the
        format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
        digits for section).
            ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
        :return: A SectionGrid object.
        &#34;&#34;&#34;
        twp, rge, sec = pyTRS.break_trs(trs)
        return SectionGrid(
            sec, twp, rge, ld=ld, allow_ld_defaults=allow_ld_defaults)

    @staticmethod
    def from_tract(tract : pyTRS.Tract, ld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        Return a new SectionGrid object created from a parsed
        pyTRS.Tract object and incorporate the lotList and QQList from
        that Tract.

        All available parameters have the same effect as for vanilla
        __init__(), except:
        :param tract: A pyTRS.Tract object (already parsed into lots and
        QQs).
        :return: A SectionGrid object.
        &#34;&#34;&#34;
        twp, rge, sec = tract.twp, tract.rge, tract.sec
        secObj = SectionGrid(
            sec=sec, twp=twp, rge=rge, ld=ld,
            allow_ld_defaults=allow_ld_defaults)
        secObj.incorporate_tract(tract)

        return secObj

    def apply_lddb(self, lddb):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions object from the
        pyTRSplat.LotDefDB object, if such a LD object exists in that
        LDDB. Will not write/overwrite anything if no LD object exists
        for this section in the LDDB.
        :param lddb: A pyTRSplat.LotDefDB object, ideally containing a
        TwpLotDefinitions object for this section&#39;s twprge, which in
        turn contains a LotDefinitions object for this section.
        &#34;&#34;&#34;
        ld = lddb.trs(self.trs)
        if ld is not None:
            self.ld = ld

    def apply_tld(self, tld):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions object from the
        pyTRSplat.TwpLotDefinitions object, if such a LD object exists
        in that TLD. Will not write/overwrite anything if no LD object
        exists for this section in the TLD.
        :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
        containing a LotDefinitions object for this section.
        &#34;&#34;&#34;
        ld = tld.get(int(self.sec), None)
        if ld is not None:
            self.ld = ld

    def lots_by_qq_name(self) -&gt; dict:
        &#34;&#34;&#34;
        Generate a dict, with QQs as keys, and whose values are each a
        list of the lot(s) that correspond with those QQs. Note that it
        is possible for more than 1 lot per QQ, so the values are all
        lists.
        &#34;&#34;&#34;

        # This functionality is handled by LotDefinitions object.
        return self.ld.lots_by_qq_name()

    def lots_by_grid(self) -&gt; list:
        &#34;&#34;&#34;
        Convert the `ld` into a grid (nested list), depicting which lots
        fall within which coordinate. For example, &#39;L1&#39; through &#39;L4&#39;
        in a standard Section 1 correspond to the N2N2 QQ&#39;s,
        respectively -- so this method would output a grid whose
        (0,0), (1,0), (2,0), and (3,0) are filled with [&#39;L4&#39;], [&#39;L3&#39;],
        [&#39;L2&#39;], and [&#39;L1&#39;], respectively.
        &#34;&#34;&#34;

        lots_by_QQname_dict = self.lots_by_qq_name()
        ar = self.output_array()

        for qq_name, dv in self.QQgrid.items():
            x = dv[&#39;coord&#39;][0]
            y = dv[&#39;coord&#39;][1]
            lots = lots_by_QQname_dict.get(qq_name)
            if lots is not None:
                ar[y][x] = lots
            else:
                ar[y][x] = []

        return ar

    def incorporate_tract(self, tract: pyTRS.Tract):
        &#34;&#34;&#34;
        Check the lotList and QQList of a parsed pyTRS.Tract object,
        and incorporate any hits into the grid.
        NOTE: Relies on the LotDefinitions object in `.ld` at the time
        this method is called. Later changes to `.ld` will not
        modify what has already been done here.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        self.incorporate_qq_list(tract.QQList)
        self.incorporate_lot_list(tract.lotList)

    def incorporate_lot_list(self, lotList: list):
        &#34;&#34;&#34;
        Incorporate all lots in the passed `lotList` into the grid.
            ex: Passing [&#39;L1&#39;, &#39;L3&#39;, &#39;L4&#39;, &#39;L5&#39;] might set &#39;NENE&#39;,
                &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; as hits for a hypothetical
                SectionGrid, depending on how lots 1, 3, 4, and 5 are
                defined in LotDefinitions object in the `.ld` attribute
                of the SectionGrid.
        NOTE: Relies on the LotDefinitions object in `.ld` at the time
        this method is called. Later changes to `.ld` will not
        modify what has already been done here.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # QQ equivalents to Lots
        equiv_qq = []

        # Convert each lot to its equivalent QQ, per the ld, and
        # add them to the equiv_qq list.
        for lot in lotList:
            # First remove any divisions in the lot (e.g., &#39;N2 of L1&#39; -&gt; &#39;L1&#39;)
            lot = _lot_without_div(lot)

            eq_qqs_from_lot = self._unpack_ld(lot)
            if eq_qqs_from_lot is None:
                self.unhandled_lots.append(lot)
                continue
            equiv_qq.extend(eq_qqs_from_lot)

        self.incorporate_qq_list(equiv_qq)

    def incorporate_qq_list(self, QQList : list):
        &#34;&#34;&#34;
        Incorporate all QQs in the passed QQList into the grid.
            ex: Passing &#39;NENE&#39;, &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; sets all of
                those QQ&#39;s as hits in a SectionGrid.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # `qq` can be fed in as &#39;NENE&#39; or &#39;NENE,NWNE&#39;. So we need to break it
        # into components before incorporating.
        for qq in QQList:
            for qq_ in qq.replace(&#39; &#39;, &#39;&#39;).split(&#39;,&#39;):
                # Also, ensure we&#39;re only getting 4-characters max -- i.e.
                # &#39;N2NENE&#39; -&gt; &#39;NENE&#39; by passing through `_smooth_QQs()`.
                # That returns a list (should be of 1 element), so get
                # the first (only) element in the returned list.
                qq_ = _smooth_QQs(qq_)[0]
                self.turn_on_qq(qq_)

    def _unpack_ld(self, lot):
        &#34;&#34;&#34;
        INTERNAL USE:
        Pass a lot number (string &#39;L1&#39; or int 1), and get a list of the
        corresponding / properly formatted QQ(s) from the `.ld` of this
        SectionGrid object. Returns None if the lot is undefined, or if
        it was defined with invalid QQ&#39;s.
        &#34;&#34;&#34;

        equiv_aliquots = []
        # Cull lot divisions (i.e. &#39;N2 of L1&#39; to just &#39;L1&#39;)
        lot = _lot_without_div(lot)

        # Get the raw definition from the LotDefinitions object.
        # If undefined in the LD obj, return None.
        raw_ldef = self.ld.get(lot, None)
        if raw_ldef is None:
            return None

        # Ensure the raw lot definition is in the expected format and is
        # broken out into QQ chunks (e.g., a &#39;L1&#39; that is defined as
        # &#39;N2NE4&#39; should be converted to &#39;NENE&#39; and &#39;NWNE&#39;).  And add
        # the resulting QQ(s) to the list of aliquots.
        equiv_aliquots.extend(_smooth_QQs(raw_ldef))

        if len(equiv_aliquots) == 0:
            return None

        return equiv_aliquots

    def output_text_plat(self, include_header=False) -&gt; str:
        &#34;&#34;&#34;
        Output a simple plat (as a string) of the Section grid values.
        &#34;&#34;&#34;

        ar = self.output_array()
        total_columns = len(ar[0])
        total_rows = len(ar)
        box_width = 4
        box_height = 1
        total_width = 1 + total_columns * (box_width + 1)

        header = &#39;=&#39; * total_width + &#39;\n&#39; + self.trs.center(total_width)

        plat_txt = &#39;=&#39; * total_width
        rows_written = 0
        for row in ar:
            drawn_row = &#39;|&#39;
            for col in row:
                draw = &#39; &#39; * box_width
                if col != 0:
                    draw = &#39;X&#39; * box_width

                drawn_row = drawn_row + draw + &#39;|&#39;
            plat_txt = plat_txt + ( &#39;\n&#39; + drawn_row ) * box_height
            rows_written += 1
            if rows_written != total_rows:
                plat_txt = plat_txt + &#39;\n&#39; + &#39;|&#39;
                plat_txt = (
                        plat_txt + (&#39;-&#39; * box_width + &#39;+&#39;) * (total_columns - 1)
                )
                plat_txt = plat_txt + &#39;-&#39; * box_width + &#39;|&#39;

        plat_txt = plat_txt + &#39;\n&#39; + &#39;=&#39; * total_width

        return (header + &#39;\n&#39;) * include_header + plat_txt

    def output_array(self) -&gt; list:
        &#34;&#34;&#34;
        Convert the grid to an array (oriented from NWNW to SESE),
        with resulting coords formatted (y, x).
        ex:
            ar = sg_obj.output_array()
            ar[y][x]  # Accesses the value at (x, y) in `sg_obj.QQgrid`
        &#34;&#34;&#34;

        max_x = 0
        max_y = 0
        for qq in self.QQgrid.values():
            if qq[&#39;coord&#39;][0] &gt; max_x:
                max_x = qq[&#39;coord&#39;][0]
            if qq[&#39;coord&#39;][1] &gt; max_y:
                max_y = qq[&#39;coord&#39;][1]

        # Create an array of all zero-values, with equal dimensions as
        # in the SectionGrid.QQgrid (which is 4x4 in a standard section).
        ar = [[0 for _a in range(max_x + 1)] for _b in range(max_y + 1)]

        for qq in self.QQgrid.values():
            x = qq[&#39;coord&#39;][0]
            y = qq[&#39;coord&#39;][1]
            if qq[&#39;val&#39;] != 0:
                ar[y][x] = qq[&#39;val&#39;]

        return ar

    def turn_off_qq(self, qq: str):
        &#34;&#34;&#34;
        Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 0.
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        &#34;&#34;&#34;
        qq = qq.upper()
        if qq in self.QQgrid.keys():
            self.QQgrid[qq][&#39;val&#39;] = 0

    def turn_on_qq(self, qq: str, custom_val=1):
        &#34;&#34;&#34;
        Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 1.

        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        :param custom_val: Instead of 1, use a different &#39;on&#39; value
        for this QQ.
        WARNING: Using a `custom_val` as anything other than 1 will
        break most functionality in this module, so it should only be
        used if you have a deep understanding of its implications.
        &#34;&#34;&#34;

        # Track that this SectionGrid was &#39;pinged&#39; by a setter,
        # regardless what the value of its QQ&#39;s may be (now or later on)
        self._was_pinged = True

        # Note: Passing anything other than `1` to `custom_val` will
        # probably cause other current functionality to break. But it
        # might be useful for some purposes (e.g., tracking which
        # PLSS descriptions include that QQ).
        qq = qq.upper()
        if qq in self.QQgrid.keys():
            self.QQgrid[qq][&#39;val&#39;] = custom_val

    def filled_coords(self) -&gt; list:
        &#34;&#34;&#34;
        Return a list of coordinates in the SectionGrid that contain a
        a hit (i.e. anything other than `0` val).
        &#34;&#34;&#34;
        ar = self.output_array()
        filled = []
        for y in range(len(ar)):
            for x in range(len(ar[y])):
                if ar[y][x] != 0:
                    filled.append((x,y))
        return filled

    def filled_qqs(self) -&gt; list:
        &#34;&#34;&#34;
        Return a list of QQs in the SectionGrid that contain a hit.
        &#34;&#34;&#34;
        hits = []
        for qq, v in self.QQgrid.items():
            if v[&#39;val&#39;] != 0:
                hits.append(qq)
        return hits

    def has_any(self):
        &#34;&#34;&#34;
        Return a bool, whether at least one QQ contains a hit anywhere
        in this SectionGrid.
        &#34;&#34;&#34;
        ar = self.output_array()
        for i in ar:
            for j in i:
                if j != 0:
                    return True
        return False</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.SectionGrid.from_tract"><code class="name flex">
<span>def <span class="ident">from_tract</span></span>(<span>tract:Â pyTRS.parser.parser.Tract, ld=None, allow_ld_defaults=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new SectionGrid object created from a parsed
pyTRS.Tract object and incorporate the lotList and QQList from
that Tract.</p>
<p>All available parameters have the same effect as for vanilla
<strong>init</strong>(), except:
:param tract: A pyTRS.Tract object (already parsed into lots and
QQs).
:return: A SectionGrid object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_tract(tract : pyTRS.Tract, ld=None, allow_ld_defaults=False):
    &#34;&#34;&#34;
    Return a new SectionGrid object created from a parsed
    pyTRS.Tract object and incorporate the lotList and QQList from
    that Tract.

    All available parameters have the same effect as for vanilla
    __init__(), except:
    :param tract: A pyTRS.Tract object (already parsed into lots and
    QQs).
    :return: A SectionGrid object.
    &#34;&#34;&#34;
    twp, rge, sec = tract.twp, tract.rge, tract.sec
    secObj = SectionGrid(
        sec=sec, twp=twp, rge=rge, ld=ld,
        allow_ld_defaults=allow_ld_defaults)
    secObj.incorporate_tract(tract)

    return secObj</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.from_trs"><code class="name flex">
<span>def <span class="ident">from_trs</span></span>(<span>trs='', ld=None, allow_ld_defaults=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a SectionGrid object by passing in a TRS
(e.g., '154n97w14'), rather than the separate Sec, Twp, Rge
components. Also takes optional <code>ld</code> argument for specifying
LotDefinitions object.</p>
<p>All available parameters have the same effect as for vanilla
<strong>init</strong>(), except:
:param trs: The Twp/Rge/Sec specified as a single string, in the
format '000x000x00' (up to 3 digits for twp and rge, exactly 2
digits for section).
ex: '154n97w01', '1s7e36', etc.
:return: A SectionGrid object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_trs(trs=&#39;&#39;, ld=None, allow_ld_defaults=False):
    &#34;&#34;&#34;
    Create and return a SectionGrid object by passing in a TRS
    (e.g., &#39;154n97w14&#39;), rather than the separate Sec, Twp, Rge
    components. Also takes optional `ld` argument for specifying
    LotDefinitions object.

    All available parameters have the same effect as for vanilla
    __init__(), except:
    :param trs: The Twp/Rge/Sec specified as a single string, in the
    format &#39;000x000x00&#39; (up to 3 digits for twp and rge, exactly 2
    digits for section).
        ex: &#39;154n97w01&#39;, &#39;1s7e36&#39;, etc.
    :return: A SectionGrid object.
    &#34;&#34;&#34;
    twp, rge, sec = pyTRS.break_trs(trs)
    return SectionGrid(
        sec, twp, rge, ld=ld, allow_ld_defaults=allow_ld_defaults)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.SectionGrid.apply_lddb"><code class="name flex">
<span>def <span class="ident">apply_lddb</span></span>(<span>self, lddb)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the appropriate pyTRSplat.LotDefinitions object from the
pyTRSplat.LotDefDB object, if such a LD object exists in that
LDDB. Will not write/overwrite anything if no LD object exists
for this section in the LDDB.
:param lddb: A pyTRSplat.LotDefDB object, ideally containing a
TwpLotDefinitions object for this section's twprge, which in
turn contains a LotDefinitions object for this section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_lddb(self, lddb):
    &#34;&#34;&#34;
    Apply the appropriate pyTRSplat.LotDefinitions object from the
    pyTRSplat.LotDefDB object, if such a LD object exists in that
    LDDB. Will not write/overwrite anything if no LD object exists
    for this section in the LDDB.
    :param lddb: A pyTRSplat.LotDefDB object, ideally containing a
    TwpLotDefinitions object for this section&#39;s twprge, which in
    turn contains a LotDefinitions object for this section.
    &#34;&#34;&#34;
    ld = lddb.trs(self.trs)
    if ld is not None:
        self.ld = ld</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.apply_tld"><code class="name flex">
<span>def <span class="ident">apply_tld</span></span>(<span>self, tld)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the appropriate pyTRSplat.LotDefinitions object from the
pyTRSplat.TwpLotDefinitions object, if such a LD object exists
in that TLD. Will not write/overwrite anything if no LD object
exists for this section in the TLD.
:param tld: A pyTRSplat.TwpLotDefinitions object, ideally
containing a LotDefinitions object for this section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_tld(self, tld):
    &#34;&#34;&#34;
    Apply the appropriate pyTRSplat.LotDefinitions object from the
    pyTRSplat.TwpLotDefinitions object, if such a LD object exists
    in that TLD. Will not write/overwrite anything if no LD object
    exists for this section in the TLD.
    :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
    containing a LotDefinitions object for this section.
    &#34;&#34;&#34;
    ld = tld.get(int(self.sec), None)
    if ld is not None:
        self.ld = ld</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.filled_coords"><code class="name flex">
<span>def <span class="ident">filled_coords</span></span>(<span>self) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of coordinates in the SectionGrid that contain a
a hit (i.e. anything other than <code>0</code> val).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filled_coords(self) -&gt; list:
    &#34;&#34;&#34;
    Return a list of coordinates in the SectionGrid that contain a
    a hit (i.e. anything other than `0` val).
    &#34;&#34;&#34;
    ar = self.output_array()
    filled = []
    for y in range(len(ar)):
        for x in range(len(ar[y])):
            if ar[y][x] != 0:
                filled.append((x,y))
    return filled</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.filled_qqs"><code class="name flex">
<span>def <span class="ident">filled_qqs</span></span>(<span>self) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of QQs in the SectionGrid that contain a hit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filled_qqs(self) -&gt; list:
    &#34;&#34;&#34;
    Return a list of QQs in the SectionGrid that contain a hit.
    &#34;&#34;&#34;
    hits = []
    for qq, v in self.QQgrid.items():
        if v[&#39;val&#39;] != 0:
            hits.append(qq)
    return hits</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.has_any"><code class="name flex">
<span>def <span class="ident">has_any</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a bool, whether at least one QQ contains a hit anywhere
in this SectionGrid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_any(self):
    &#34;&#34;&#34;
    Return a bool, whether at least one QQ contains a hit anywhere
    in this SectionGrid.
    &#34;&#34;&#34;
    ar = self.output_array()
    for i in ar:
        for j in i:
            if j != 0:
                return True
    return False</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.incorporate_lot_list"><code class="name flex">
<span>def <span class="ident">incorporate_lot_list</span></span>(<span>self, lotList:Â list)</span>
</code></dt>
<dd>
<div class="desc"><p>Incorporate all lots in the passed <code>lotList</code> into the grid.
ex: Passing ['L1', 'L3', 'L4', 'L5'] might set 'NENE',
'NENW', 'NWNW', and 'SWNW' as hits for a hypothetical
SectionGrid, depending on how lots 1, 3, 4, and 5 are
defined in LotDefinitions object in the <code>.ld</code> attribute
of the SectionGrid.
NOTE: Relies on the LotDefinitions object in <code>.ld</code> at the time
this method is called. Later changes to <code>.ld</code> will not
modify what has already been done here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incorporate_lot_list(self, lotList: list):
    &#34;&#34;&#34;
    Incorporate all lots in the passed `lotList` into the grid.
        ex: Passing [&#39;L1&#39;, &#39;L3&#39;, &#39;L4&#39;, &#39;L5&#39;] might set &#39;NENE&#39;,
            &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; as hits for a hypothetical
            SectionGrid, depending on how lots 1, 3, 4, and 5 are
            defined in LotDefinitions object in the `.ld` attribute
            of the SectionGrid.
    NOTE: Relies on the LotDefinitions object in `.ld` at the time
    this method is called. Later changes to `.ld` will not
    modify what has already been done here.
    &#34;&#34;&#34;

    # Track that this SectionGrid was &#39;pinged&#39; by a setter,
    # regardless what the value of its QQ&#39;s may be (now or later on)
    self._was_pinged = True

    # QQ equivalents to Lots
    equiv_qq = []

    # Convert each lot to its equivalent QQ, per the ld, and
    # add them to the equiv_qq list.
    for lot in lotList:
        # First remove any divisions in the lot (e.g., &#39;N2 of L1&#39; -&gt; &#39;L1&#39;)
        lot = _lot_without_div(lot)

        eq_qqs_from_lot = self._unpack_ld(lot)
        if eq_qqs_from_lot is None:
            self.unhandled_lots.append(lot)
            continue
        equiv_qq.extend(eq_qqs_from_lot)

    self.incorporate_qq_list(equiv_qq)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.incorporate_qq_list"><code class="name flex">
<span>def <span class="ident">incorporate_qq_list</span></span>(<span>self, QQList:Â list)</span>
</code></dt>
<dd>
<div class="desc"><p>Incorporate all QQs in the passed QQList into the grid.
ex: Passing 'NENE', 'NENW', 'NWNW', and 'SWNW' sets all of
those QQ's as hits in a SectionGrid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incorporate_qq_list(self, QQList : list):
    &#34;&#34;&#34;
    Incorporate all QQs in the passed QQList into the grid.
        ex: Passing &#39;NENE&#39;, &#39;NENW&#39;, &#39;NWNW&#39;, and &#39;SWNW&#39; sets all of
            those QQ&#39;s as hits in a SectionGrid.
    &#34;&#34;&#34;

    # Track that this SectionGrid was &#39;pinged&#39; by a setter,
    # regardless what the value of its QQ&#39;s may be (now or later on)
    self._was_pinged = True

    # `qq` can be fed in as &#39;NENE&#39; or &#39;NENE,NWNE&#39;. So we need to break it
    # into components before incorporating.
    for qq in QQList:
        for qq_ in qq.replace(&#39; &#39;, &#39;&#39;).split(&#39;,&#39;):
            # Also, ensure we&#39;re only getting 4-characters max -- i.e.
            # &#39;N2NENE&#39; -&gt; &#39;NENE&#39; by passing through `_smooth_QQs()`.
            # That returns a list (should be of 1 element), so get
            # the first (only) element in the returned list.
            qq_ = _smooth_QQs(qq_)[0]
            self.turn_on_qq(qq_)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.incorporate_tract"><code class="name flex">
<span>def <span class="ident">incorporate_tract</span></span>(<span>self, tract:Â pyTRS.parser.parser.Tract)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the lotList and QQList of a parsed pyTRS.Tract object,
and incorporate any hits into the grid.
NOTE: Relies on the LotDefinitions object in <code>.ld</code> at the time
this method is called. Later changes to <code>.ld</code> will not
modify what has already been done here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incorporate_tract(self, tract: pyTRS.Tract):
    &#34;&#34;&#34;
    Check the lotList and QQList of a parsed pyTRS.Tract object,
    and incorporate any hits into the grid.
    NOTE: Relies on the LotDefinitions object in `.ld` at the time
    this method is called. Later changes to `.ld` will not
    modify what has already been done here.
    &#34;&#34;&#34;

    # Track that this SectionGrid was &#39;pinged&#39; by a setter,
    # regardless what the value of its QQ&#39;s may be (now or later on)
    self._was_pinged = True

    self.incorporate_qq_list(tract.QQList)
    self.incorporate_lot_list(tract.lotList)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.lots_by_grid"><code class="name flex">
<span>def <span class="ident">lots_by_grid</span></span>(<span>self) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the <code>ld</code> into a grid (nested list), depicting which lots
fall within which coordinate. For example, 'L1' through 'L4'
in a standard Section 1 correspond to the N2N2 QQ's,
respectively &ndash; so this method would output a grid whose
(0,0), (1,0), (2,0), and (3,0) are filled with ['L4'], ['L3'],
['L2'], and ['L1'], respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lots_by_grid(self) -&gt; list:
    &#34;&#34;&#34;
    Convert the `ld` into a grid (nested list), depicting which lots
    fall within which coordinate. For example, &#39;L1&#39; through &#39;L4&#39;
    in a standard Section 1 correspond to the N2N2 QQ&#39;s,
    respectively -- so this method would output a grid whose
    (0,0), (1,0), (2,0), and (3,0) are filled with [&#39;L4&#39;], [&#39;L3&#39;],
    [&#39;L2&#39;], and [&#39;L1&#39;], respectively.
    &#34;&#34;&#34;

    lots_by_QQname_dict = self.lots_by_qq_name()
    ar = self.output_array()

    for qq_name, dv in self.QQgrid.items():
        x = dv[&#39;coord&#39;][0]
        y = dv[&#39;coord&#39;][1]
        lots = lots_by_QQname_dict.get(qq_name)
        if lots is not None:
            ar[y][x] = lots
        else:
            ar[y][x] = []

    return ar</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.lots_by_qq_name"><code class="name flex">
<span>def <span class="ident">lots_by_qq_name</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a dict, with QQs as keys, and whose values are each a
list of the lot(s) that correspond with those QQs. Note that it
is possible for more than 1 lot per QQ, so the values are all
lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lots_by_qq_name(self) -&gt; dict:
    &#34;&#34;&#34;
    Generate a dict, with QQs as keys, and whose values are each a
    list of the lot(s) that correspond with those QQs. Note that it
    is possible for more than 1 lot per QQ, so the values are all
    lists.
    &#34;&#34;&#34;

    # This functionality is handled by LotDefinitions object.
    return self.ld.lots_by_qq_name()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.output_array"><code class="name flex">
<span>def <span class="ident">output_array</span></span>(<span>self) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the grid to an array (oriented from NWNW to SESE),
with resulting coords formatted (y, x).
ex:
ar = sg_obj.output_array()
ar[y][x]
# Accesses the value at (x, y) in <code>sg_obj.QQgrid</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_array(self) -&gt; list:
    &#34;&#34;&#34;
    Convert the grid to an array (oriented from NWNW to SESE),
    with resulting coords formatted (y, x).
    ex:
        ar = sg_obj.output_array()
        ar[y][x]  # Accesses the value at (x, y) in `sg_obj.QQgrid`
    &#34;&#34;&#34;

    max_x = 0
    max_y = 0
    for qq in self.QQgrid.values():
        if qq[&#39;coord&#39;][0] &gt; max_x:
            max_x = qq[&#39;coord&#39;][0]
        if qq[&#39;coord&#39;][1] &gt; max_y:
            max_y = qq[&#39;coord&#39;][1]

    # Create an array of all zero-values, with equal dimensions as
    # in the SectionGrid.QQgrid (which is 4x4 in a standard section).
    ar = [[0 for _a in range(max_x + 1)] for _b in range(max_y + 1)]

    for qq in self.QQgrid.values():
        x = qq[&#39;coord&#39;][0]
        y = qq[&#39;coord&#39;][1]
        if qq[&#39;val&#39;] != 0:
            ar[y][x] = qq[&#39;val&#39;]

    return ar</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.output_text_plat"><code class="name flex">
<span>def <span class="ident">output_text_plat</span></span>(<span>self, include_header=False) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Output a simple plat (as a string) of the Section grid values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_text_plat(self, include_header=False) -&gt; str:
    &#34;&#34;&#34;
    Output a simple plat (as a string) of the Section grid values.
    &#34;&#34;&#34;

    ar = self.output_array()
    total_columns = len(ar[0])
    total_rows = len(ar)
    box_width = 4
    box_height = 1
    total_width = 1 + total_columns * (box_width + 1)

    header = &#39;=&#39; * total_width + &#39;\n&#39; + self.trs.center(total_width)

    plat_txt = &#39;=&#39; * total_width
    rows_written = 0
    for row in ar:
        drawn_row = &#39;|&#39;
        for col in row:
            draw = &#39; &#39; * box_width
            if col != 0:
                draw = &#39;X&#39; * box_width

            drawn_row = drawn_row + draw + &#39;|&#39;
        plat_txt = plat_txt + ( &#39;\n&#39; + drawn_row ) * box_height
        rows_written += 1
        if rows_written != total_rows:
            plat_txt = plat_txt + &#39;\n&#39; + &#39;|&#39;
            plat_txt = (
                    plat_txt + (&#39;-&#39; * box_width + &#39;+&#39;) * (total_columns - 1)
            )
            plat_txt = plat_txt + &#39;-&#39; * box_width + &#39;|&#39;

    plat_txt = plat_txt + &#39;\n&#39; + &#39;=&#39; * total_width

    return (header + &#39;\n&#39;) * include_header + plat_txt</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.turn_off_qq"><code class="name flex">
<span>def <span class="ident">turn_off_qq</span></span>(<span>self, qq:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the specified QQ (e.g. 'NENE') to 0.
:param qq: The name of a QQ (one of the 16 standard QQs only
&ndash; e.g. 'NENE', 'SWSE', etc.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off_qq(self, qq: str):
    &#34;&#34;&#34;
    Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 0.
    :param qq: The name of a QQ (one of the 16 standard QQs only
    -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
    &#34;&#34;&#34;
    qq = qq.upper()
    if qq in self.QQgrid.keys():
        self.QQgrid[qq][&#39;val&#39;] = 0</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.SectionGrid.turn_on_qq"><code class="name flex">
<span>def <span class="ident">turn_on_qq</span></span>(<span>self, qq:Â str, custom_val=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the specified QQ (e.g. 'NENE') to 1.</p>
<p>:param qq: The name of a QQ (one of the 16 standard QQs only
&ndash; e.g. 'NENE', 'SWSE', etc.)
:param custom_val: Instead of 1, use a different 'on' value
for this QQ.
WARNING: Using a <code>custom_val</code> as anything other than 1 will
break most functionality in this module, so it should only be
used if you have a deep understanding of its implications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_on_qq(self, qq: str, custom_val=1):
    &#34;&#34;&#34;
    Set the value of the specified QQ (e.g. &#39;NENE&#39;) to 1.

    :param qq: The name of a QQ (one of the 16 standard QQs only
    -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
    :param custom_val: Instead of 1, use a different &#39;on&#39; value
    for this QQ.
    WARNING: Using a `custom_val` as anything other than 1 will
    break most functionality in this module, so it should only be
    used if you have a deep understanding of its implications.
    &#34;&#34;&#34;

    # Track that this SectionGrid was &#39;pinged&#39; by a setter,
    # regardless what the value of its QQ&#39;s may be (now or later on)
    self._was_pinged = True

    # Note: Passing anything other than `1` to `custom_val` will
    # probably cause other current functionality to break. But it
    # might be useful for some purposes (e.g., tracking which
    # PLSS descriptions include that QQ).
    qq = qq.upper()
    if qq in self.QQgrid.keys():
        self.QQgrid[qq][&#39;val&#39;] = custom_val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid"><code class="flex name class">
<span>class <span class="ident">TownshipGrid</span></span>
<span>(</span><span>twp='', rge='', tld=None, allow_ld_defaults=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A grid of a single Township/Range, containing in its <code>.sections</code>
attribute a dict (keyed by integers 1 - 36, inclusive) of a separate
SectionGrid object for each of its 36 sections. Also contains a dict
key <code>0</code> (i.e. a nonsense 'Section 0'), as a 'junk drawer' for error-
ridden sections.</p>
<p>A grid of a single Township/Range, containing in its <code>.sections</code>
attribute a dict (keyed by integers 1 - 36, inclusive) of a
separate SectionGrid object for each of its 36 sections. Also
contains a dict key <code>0</code> (i.e. a nonsense 'Section 0'), as a
'junk drawer' for error- ridden sections.</p>
<p>:param twp: Township number (up to 3 digits) and N/S direction
(as a single lowercase character).
ex: '154n', '1s', etc.
:param rge: Range number (up to 3 digits) and E/W direction
(as a single lowercase character).
ex: '97w', '7e', etc.
:param tld: A pyTRSplat.TwpLotDefinitions object, defining how
lots should be interpreted in each respective section, in terms
of QQs.
:param allow_ld_defaults: Whether 'default' lot definitions are
allowed as a fall-back option, when lots have not been
explicitly defined for a given section. (Default lots are the
'usual' lots in Sections 1 - 7, 18, 19, 30, and 31 of a
'standard' township &ndash; i.e. along the northern and western
boundaries of a township. Potentially useful as a 'better-than-
nothing' option, but not as reliable as user-specified lot
definitions.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TownshipGrid:
    &#34;&#34;&#34;
    A grid of a single Township/Range, containing in its `.sections`
    attribute a dict (keyed by integers 1 - 36, inclusive) of a separate
    SectionGrid object for each of its 36 sections. Also contains a dict
    key `0` (i.e. a nonsense &#39;Section 0&#39;), as a &#39;junk drawer&#39; for error-
    ridden sections.
    &#34;&#34;&#34;

    # Sections 1-6, 13-18, and 25-30 (inclusive) are east-to-west (i.e.
    # right-to-left) -- all other sections are left-to-right.
    RIGHT_TO_LEFT_SECTIONS = list(
        range(1, 7)) + list(range(13, 19)) + list(range(25, 31))

    def __init__(self, twp=&#39;&#39;, rge=&#39;&#39;, tld=None, allow_ld_defaults=False):
        &#34;&#34;&#34;
        A grid of a single Township/Range, containing in its `.sections`
        attribute a dict (keyed by integers 1 - 36, inclusive) of a
        separate SectionGrid object for each of its 36 sections. Also
        contains a dict key `0` (i.e. a nonsense &#39;Section 0&#39;), as a
        &#39;junk drawer&#39; for error- ridden sections.

        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :param tld: A pyTRSplat.TwpLotDefinitions object, defining how
        lots should be interpreted in each respective section, in terms
        of QQs.
        :param allow_ld_defaults: Whether &#39;default&#39; lot definitions are
        allowed as a fall-back option, when lots have not been
        explicitly defined for a given section. (Default lots are the
        &#39;usual&#39; lots in Sections 1 - 7, 18, 19, 30, and 31 of a
        &#39;standard&#39; township -- i.e. along the northern and western
        boundaries of a township. Potentially useful as a &#39;better-than-
        nothing&#39; option, but not as reliable as user-specified lot
        definitions.)
        &#34;&#34;&#34;
        # NOTE: `tld` stands for `TwpLotDefinitions`

        total_sections = 36

        self.twp = twp
        self.rge = rge
        self.twprge = twp + rge

        # dict of SectionGrid objects for each section, keyed by ints 1 - 36
        self.sections = {}

        # dict of (x,y) coords for each section in the Twp, keyed by ints 1 - 36
        self.section_coords = {}

        if isinstance(tld, TwpLotDefinitions):
            self.tld = tld
        elif tld is None and allow_ld_defaults:
            self.tld = TwpLotDefinitions(list(range(0, 37)))
        else:
            self.tld = TwpLotDefinitions()

        # Sections &#34;snake&#34; from the NE corner of the township west then
        # down, then they cut back east, then down and west again, etc.,
        # thus:
        #           6   5   4   3   2   1
        #           7   8   9   10  11  12
        #           18  17  16  15  14  13
        #           19  20  21  22  23  24
        #           30  29  28  27  26  25
        #           31  32  33  34  35  36
        #
        # ...so accounting for this is a little trickier:
        for sec_num in range(1, total_sections + 1):
            x = (sec_num - 1) // 6
            if sec_num in TownshipGrid.RIGHT_TO_LEFT_SECTIONS:
                y = -sec_num % 6
            else:
                y = sec_num % 6
            # Pull the LotDefinitions from our TLD, if it&#39;s been set for
            # this section. If not set, check with `allow_ld_defaults`
            # whether to pull a default LD, or to pull an empty LD.
            ld = self.tld.get_ld(
                sec_num, allow_ld_defaults=allow_ld_defaults,
                force_ld_return=True)
            self.sections[sec_num] = SectionGrid(
                sec=sec_num, twp=twp, rge=rge, ld=ld)
            self.section_coords[sec_num] = (x, y)

        # Also add a nonsense &#39;Section 0&#39; (which never actually exists
        # for any real-life township). This way, we can handle section
        # errors (e.g., from a flawed parse by pyTRS, which can generate
        # a section number of &#39;secError&#39;) by changing them to Section 0,
        # without crashing the program, but while also being able to
        # check if there were flaws (e.g., if there are any changes made
        # to this SectionGrid object).
        self.sections[0] = SectionGrid(sec=0, twp=twp, rge=rge)
        self.section_coords[0] = (-1, -1)

    def apply_tld(self, tld):
        &#34;&#34;&#34;
        Apply the appropriate pyTRSplat.LotDefinitions objects from the
        pyTRSplat.TwpLotDefinitions object to the respective SectionGrid
        objects in this TownshipGrid (if such LD objects exists in that
        TLD for such sections). Will not write/overwrite anything if no
        LD object exists for a given section in the TLD.

        :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
        containing a LotDefinitions object for each section.
        &#34;&#34;&#34;
        if not isinstance(tld, TwpLotDefinitions):
            raise TypeError(&#39;`tld` must be `TwpLotDefinitions` object.&#39;)
        for key, val in tld.items():
            self.apply_ld(key, val)

    def apply_ld(self, sec_num: int, ld):
        &#34;&#34;&#34;
        Apply a LotDefinitions object (`ld`) to the SectionGrid object
        that is designated by the section number (`sec_num`).
        &#34;&#34;&#34;
        if not isinstance(ld, LotDefinitions):
            raise TypeError(&#39;`ld` must be type `LotDefinitions`&#39;)
        self.sections[int(sec_num)].ld = ld

    def filled_section_grids(self, include_pinged=False) -&gt; list:
        &#34;&#34;&#34;
        Return a list of pyTRSplat.SectionGrid objects that have at
        least one QQ filled.

        :param include_pinged: Optionally, also include all SectionGrid
        objects that were &#39;pinged&#39; by any setter method, even if no
        values were set (e.g., an empty list was passed to the
        `.incorporate_lotlist()` method, resulting in no actually-set
        values. This is potentially useful if a pyTRS.Tract object was
        parsed but did not have any identifiable lots or QQ&#39;s and we
        still want to include the corresponding SectionGrid object here.
        Defaults to False.
        :return: A list of SectionGrid objects.
        &#34;&#34;&#34;
        x_sec = []
        for sec_num, val in self.sections.items():
            if val.has_any() or (val._was_pinged and include_pinged):
                x_sec.append(val)
        return x_sec

    def incorporate_tract(self, tract, sec_num=None):
        &#34;&#34;&#34;
        Check the `.lotList` and `.QQList` attributes of a parsed
        pyTRS.Tract object, and incorporate any hits into the
        appropriate SectionGrid.
        NOTE: Relies on the TwpLotDefinitions object in `.tld` at the
        time this method is called. Later changes to `.tld` will not
        modify what has already been done here.
        :param tract: The pyTRS.Tract object whose lotList and QQList
        should be incorporated into the TownshipGrid.
        :param sec_num: The section number for the Tract being
        incorporated. If not specified, it will pull the `.sec`
        attribute from the Tract object.
        &#34;&#34;&#34;
        if sec_num is None:
            sec_num = tract.sec
        # &#39;secError&#39; can be returned by pyTRS in the event of a flawed
        # parse, so we handle this by setting sec_num to 0 (a section number
        # that can&#39;t exist in reality), before trying to
        # convert `sec` to an int causes a ValueError.
        if sec_num == &#39;secError&#39;:
            sec_num = 0
        sec_num = int(sec_num)
        secGridObj = self.sections[sec_num]
        secGridObj.incorporate_tract(tract)

    def turn_off_qq(self, sec_num: int, qq: str):
        &#34;&#34;&#34;
        For the specified section, set the value of the specified QQ
        (e.g. &#39;NENE&#39;) to 0, in the appropriate SectionGrid in the
        `.sections` attribute of this TownshipGrid object.

        :param sec_num: An integer (1 - 36) for section number. (Use 0
        to throw away into the junk drawer without raising an error.)
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        &#34;&#34;&#34;
        if sec_num in self.sections.keys():
            self.sections[int(sec_num)].turn_on_qq(qq=qq)

    def turn_on_qq(self, sec_num: int, qq: str, custom_val=1):
        &#34;&#34;&#34;
        For the specified section, set the value of the specified QQ
        (e.g. &#39;NENE&#39;) to `1`, in the appropriate SectionGrid in the
        `.sections` attribute of this TownshipGrid object.
        :param sec_num: An integer (1 - 36) for section number. (Use 0
        to throw away into the junk drawer without raising an error.)
        :param qq: The name of a QQ (one of the 16 standard QQs only
        -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
        :param custom_val: Instead of 1, use a different &#39;on&#39; value
        for this QQ.
        WARNING: Using a `custom_val` as anything other than 1 will
        break most functionality in this module, so it should only be
        used if you have a deep understanding of its implications.
        &#34;&#34;&#34;

        # Note: Passing anything other than `1` to `custom_val` will
        # probably cause other current functionality to break. But it
        # might be useful for some purposes (e.g., tracking which
        # PLSS descriptions include that QQ).

        if sec_num in self.sections.keys():
            self.sections[int(sec_num)].turn_on_qq(qq=qq, custom_val=custom_val)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.RIGHT_TO_LEFT_SECTIONS"><code class="name">var <span class="ident">RIGHT_TO_LEFT_SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.apply_ld"><code class="name flex">
<span>def <span class="ident">apply_ld</span></span>(<span>self, sec_num:Â int, ld)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a LotDefinitions object (<code>ld</code>) to the SectionGrid object
that is designated by the section number (<code>sec_num</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_ld(self, sec_num: int, ld):
    &#34;&#34;&#34;
    Apply a LotDefinitions object (`ld`) to the SectionGrid object
    that is designated by the section number (`sec_num`).
    &#34;&#34;&#34;
    if not isinstance(ld, LotDefinitions):
        raise TypeError(&#39;`ld` must be type `LotDefinitions`&#39;)
    self.sections[int(sec_num)].ld = ld</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.apply_tld"><code class="name flex">
<span>def <span class="ident">apply_tld</span></span>(<span>self, tld)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the appropriate pyTRSplat.LotDefinitions objects from the
pyTRSplat.TwpLotDefinitions object to the respective SectionGrid
objects in this TownshipGrid (if such LD objects exists in that
TLD for such sections). Will not write/overwrite anything if no
LD object exists for a given section in the TLD.</p>
<p>:param tld: A pyTRSplat.TwpLotDefinitions object, ideally
containing a LotDefinitions object for each section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_tld(self, tld):
    &#34;&#34;&#34;
    Apply the appropriate pyTRSplat.LotDefinitions objects from the
    pyTRSplat.TwpLotDefinitions object to the respective SectionGrid
    objects in this TownshipGrid (if such LD objects exists in that
    TLD for such sections). Will not write/overwrite anything if no
    LD object exists for a given section in the TLD.

    :param tld: A pyTRSplat.TwpLotDefinitions object, ideally
    containing a LotDefinitions object for each section.
    &#34;&#34;&#34;
    if not isinstance(tld, TwpLotDefinitions):
        raise TypeError(&#39;`tld` must be `TwpLotDefinitions` object.&#39;)
    for key, val in tld.items():
        self.apply_ld(key, val)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.filled_section_grids"><code class="name flex">
<span>def <span class="ident">filled_section_grids</span></span>(<span>self, include_pinged=False) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of pyTRSplat.SectionGrid objects that have at
least one QQ filled.</p>
<p>:param include_pinged: Optionally, also include all SectionGrid
objects that were 'pinged' by any setter method, even if no
values were set (e.g., an empty list was passed to the
<code>.incorporate_lotlist()</code> method, resulting in no actually-set
values. This is potentially useful if a pyTRS.Tract object was
parsed but did not have any identifiable lots or QQ's and we
still want to include the corresponding SectionGrid object here.
Defaults to False.
:return: A list of SectionGrid objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filled_section_grids(self, include_pinged=False) -&gt; list:
    &#34;&#34;&#34;
    Return a list of pyTRSplat.SectionGrid objects that have at
    least one QQ filled.

    :param include_pinged: Optionally, also include all SectionGrid
    objects that were &#39;pinged&#39; by any setter method, even if no
    values were set (e.g., an empty list was passed to the
    `.incorporate_lotlist()` method, resulting in no actually-set
    values. This is potentially useful if a pyTRS.Tract object was
    parsed but did not have any identifiable lots or QQ&#39;s and we
    still want to include the corresponding SectionGrid object here.
    Defaults to False.
    :return: A list of SectionGrid objects.
    &#34;&#34;&#34;
    x_sec = []
    for sec_num, val in self.sections.items():
        if val.has_any() or (val._was_pinged and include_pinged):
            x_sec.append(val)
    return x_sec</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.incorporate_tract"><code class="name flex">
<span>def <span class="ident">incorporate_tract</span></span>(<span>self, tract, sec_num=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the <code>.lotList</code> and <code>.QQList</code> attributes of a parsed
pyTRS.Tract object, and incorporate any hits into the
appropriate SectionGrid.
NOTE: Relies on the TwpLotDefinitions object in <code>.tld</code> at the
time this method is called. Later changes to <code>.tld</code> will not
modify what has already been done here.
:param tract: The pyTRS.Tract object whose lotList and QQList
should be incorporated into the TownshipGrid.
:param sec_num: The section number for the Tract being
incorporated. If not specified, it will pull the <code>.sec</code>
attribute from the Tract object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incorporate_tract(self, tract, sec_num=None):
    &#34;&#34;&#34;
    Check the `.lotList` and `.QQList` attributes of a parsed
    pyTRS.Tract object, and incorporate any hits into the
    appropriate SectionGrid.
    NOTE: Relies on the TwpLotDefinitions object in `.tld` at the
    time this method is called. Later changes to `.tld` will not
    modify what has already been done here.
    :param tract: The pyTRS.Tract object whose lotList and QQList
    should be incorporated into the TownshipGrid.
    :param sec_num: The section number for the Tract being
    incorporated. If not specified, it will pull the `.sec`
    attribute from the Tract object.
    &#34;&#34;&#34;
    if sec_num is None:
        sec_num = tract.sec
    # &#39;secError&#39; can be returned by pyTRS in the event of a flawed
    # parse, so we handle this by setting sec_num to 0 (a section number
    # that can&#39;t exist in reality), before trying to
    # convert `sec` to an int causes a ValueError.
    if sec_num == &#39;secError&#39;:
        sec_num = 0
    sec_num = int(sec_num)
    secGridObj = self.sections[sec_num]
    secGridObj.incorporate_tract(tract)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.turn_off_qq"><code class="name flex">
<span>def <span class="ident">turn_off_qq</span></span>(<span>self, sec_num:Â int, qq:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>For the specified section, set the value of the specified QQ
(e.g. 'NENE') to 0, in the appropriate SectionGrid in the
<code>.sections</code> attribute of this TownshipGrid object.</p>
<p>:param sec_num: An integer (1 - 36) for section number. (Use 0
to throw away into the junk drawer without raising an error.)
:param qq: The name of a QQ (one of the 16 standard QQs only
&ndash; e.g. 'NENE', 'SWSE', etc.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off_qq(self, sec_num: int, qq: str):
    &#34;&#34;&#34;
    For the specified section, set the value of the specified QQ
    (e.g. &#39;NENE&#39;) to 0, in the appropriate SectionGrid in the
    `.sections` attribute of this TownshipGrid object.

    :param sec_num: An integer (1 - 36) for section number. (Use 0
    to throw away into the junk drawer without raising an error.)
    :param qq: The name of a QQ (one of the 16 standard QQs only
    -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
    &#34;&#34;&#34;
    if sec_num in self.sections.keys():
        self.sections[int(sec_num)].turn_on_qq(qq=qq)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TownshipGrid.turn_on_qq"><code class="name flex">
<span>def <span class="ident">turn_on_qq</span></span>(<span>self, sec_num:Â int, qq:Â str, custom_val=1)</span>
</code></dt>
<dd>
<div class="desc"><p>For the specified section, set the value of the specified QQ
(e.g. 'NENE') to <code>1</code>, in the appropriate SectionGrid in the
<code>.sections</code> attribute of this TownshipGrid object.
:param sec_num: An integer (1 - 36) for section number. (Use 0
to throw away into the junk drawer without raising an error.)
:param qq: The name of a QQ (one of the 16 standard QQs only
&ndash; e.g. 'NENE', 'SWSE', etc.)
:param custom_val: Instead of 1, use a different 'on' value
for this QQ.
WARNING: Using a <code>custom_val</code> as anything other than 1 will
break most functionality in this module, so it should only be
used if you have a deep understanding of its implications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_on_qq(self, sec_num: int, qq: str, custom_val=1):
    &#34;&#34;&#34;
    For the specified section, set the value of the specified QQ
    (e.g. &#39;NENE&#39;) to `1`, in the appropriate SectionGrid in the
    `.sections` attribute of this TownshipGrid object.
    :param sec_num: An integer (1 - 36) for section number. (Use 0
    to throw away into the junk drawer without raising an error.)
    :param qq: The name of a QQ (one of the 16 standard QQs only
    -- e.g. &#39;NENE&#39;, &#39;SWSE&#39;, etc.)
    :param custom_val: Instead of 1, use a different &#39;on&#39; value
    for this QQ.
    WARNING: Using a `custom_val` as anything other than 1 will
    break most functionality in this module, so it should only be
    used if you have a deep understanding of its implications.
    &#34;&#34;&#34;

    # Note: Passing anything other than `1` to `custom_val` will
    # probably cause other current functionality to break. But it
    # might be useful for some purposes (e.g., tracking which
    # PLSS descriptions include that QQ).

    if sec_num in self.sections.keys():
        self.sections[int(sec_num)].turn_on_qq(qq=qq, custom_val=custom_val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.grid.Grid.TwpLotDefinitions"><code class="flex name class">
<span>class <span class="ident">TwpLotDefinitions</span></span>
<span>(</span><span>default_sections=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A dict object (which often get abbreviated 'tld' or 'TLD' in code
comments and documentation) of LotDefinition objects (i.e.
essentially a nested dict) for an entire township. Each key is a
section number (an int), whose value is a LotDefinition object for
that section. If a section number (int) or list of section numbers
(all ints) is passed at init, will create default LotDefinitions
objects for those sections.</p>
<p>A pyTRSplat.TwpLotDefinitions object is a nested dict with this
structure:
- TwpLotDefinitions - dict, keyed by sec number (int), value-type:
&ndash; LotDefinitions - dict, keyed by lot name (ex: 'L2'), value-type:
&mdash; a string, being QQ name(s), separated by comma if more than one
(i.e. how each lot should be interpreted in terms of QQ's
ex: 'L2' -&gt; 'NWNE')
Thus, rudimentary access might be:
tld_obj[1]['L2'] -&gt; 'NWNE'
(i.e. Lot 2, of Sec 1 of this township corresponds with the
NW/4NE/4 of said section)
However, see custom getter method <code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld">TwpLotDefinitions.get_ld()</a></code>,
which has more robust handling of default / unspecified values.</p>
<p>IMPORTANT: TwpLotDefinitions objects contain ONLY one element by
default: Key <code>0</code>, whose value is a meaningless LotDefinitions obj,
used as a 'junk drawer' for error-ridden sections. Additional
LotDefinitions objects can be added with the <code>.set_section()</code> method
or by loading appropriately formatted data from a .csv file with
<code>.load_csv()</code>.</p>
<p>NOTE: The <code>.get_ld()</code> method is recommended over Python's built-in
dict getters (i.e. <code>dct['key']</code> or <code>dct.get('key')</code>), because it
adds more specific functionality for handling defaults.</p>
<p>These objects can be contained within a pyTRSplat.LotDefDB object
(keyed by T&amp;R, formatted '000x000x' or fewer digits &ndash; e.g.,
'154n97w' for T154N-R97W) for definitions of lots in the sections of
any number of townships.</p>
<p>See <code>LotDefDB.from_csv()</code> or <code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv">TwpLotDefinitions.from_csv()</a></code> for
loading larger databases from .csv files, rather than creating
TwpLotDefinitions objects individually.</p>
<p>Additional documentation on TwpLotDefinitions is maintained under
pyTRSplat.LotDefDB objects, to avoid undue repetition.</p>
<p>A dict object (which often get abbreviated 'tld' or 'TLD' in
code comments and documentation) of LotDefinition objects (i.e.
essentially a nested dict) for an entire township. Each key is a
section number (an int), whose value is a LotDefinition object
for that section. If a section number (int) or list of section
numbers (all ints) is passed at init, will create default
LotDefinitions objects for those sections.</p>
<p>:param default_sections: A single integer, or list of integers,
for the section(s) for which default LotDefinitions should be
created at init. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TwpLotDefinitions(dict):
    &#34;&#34;&#34;
    A dict object (which often get abbreviated &#39;tld&#39; or &#39;TLD&#39; in code
    comments and documentation) of LotDefinition objects (i.e.
    essentially a nested dict) for an entire township. Each key is a
    section number (an int), whose value is a LotDefinition object for
    that section. If a section number (int) or list of section numbers
    (all ints) is passed at init, will create default LotDefinitions
    objects for those sections.

    A pyTRSplat.TwpLotDefinitions object is a nested dict with this
    structure:
    - TwpLotDefinitions - dict, keyed by sec number (int), value-type:
    -- LotDefinitions - dict, keyed by lot name (ex: &#39;L2&#39;), value-type:
    --- a string, being QQ name(s), separated by comma if more than one
            (i.e. how each lot should be interpreted in terms of QQ&#39;s
                ex: &#39;L2&#39; -&gt; &#39;NWNE&#39;)
    Thus, rudimentary access might be:
        tld_obj[1][&#39;L2&#39;] -&gt; &#39;NWNE&#39;
            (i.e. Lot 2, of Sec 1 of this township corresponds with the
            NW/4NE/4 of said section)
    However, see custom getter method `TwpLotDefinitions.get_ld()`,
    which has more robust handling of default / unspecified values.

    IMPORTANT: TwpLotDefinitions objects contain ONLY one element by
    default: Key `0`, whose value is a meaningless LotDefinitions obj,
    used as a &#39;junk drawer&#39; for error-ridden sections. Additional
    LotDefinitions objects can be added with the `.set_section()` method
    or by loading appropriately formatted data from a .csv file with
    `.load_csv()`.

    NOTE: The `.get_ld()` method is recommended over Python&#39;s built-in
    dict getters (i.e. `dct[&#39;key&#39;]` or `dct.get(&#39;key&#39;)`), because it
    adds more specific functionality for handling defaults.

    These objects can be contained within a pyTRSplat.LotDefDB object
    (keyed by T&amp;R, formatted &#39;000x000x&#39; or fewer digits -- e.g.,
    &#39;154n97w&#39; for T154N-R97W) for definitions of lots in the sections of
    any number of townships.

    See `LotDefDB.from_csv()` or `TwpLotDefinitions.from_csv()` for
    loading larger databases from .csv files, rather than creating
    TwpLotDefinitions objects individually.

    Additional documentation on TwpLotDefinitions is maintained under
    pyTRSplat.LotDefDB objects, to avoid undue repetition.
    &#34;&#34;&#34;

    def __init__(self, default_sections=None):
        &#34;&#34;&#34;
        A dict object (which often get abbreviated &#39;tld&#39; or &#39;TLD&#39; in
        code comments and documentation) of LotDefinition objects (i.e.
        essentially a nested dict) for an entire township. Each key is a
        section number (an int), whose value is a LotDefinition object
        for that section. If a section number (int) or list of section
        numbers (all ints) is passed at init, will create default
        LotDefinitions objects for those sections.

        :param default_sections: A single integer, or list of integers,
        for the section(s) for which default LotDefinitions should be
        created at init. Defaults to None.
        &#34;&#34;&#34;
        super().__init__()

        # Initialize an empty LotDef obj for an non-existing &#39;section 0&#39;
        # (for error-handling purposes only -- will not contain
        # meaningful data)
        self[0] = LotDefinitions(None)

        # If we want to use default dicts for any sections, do so now.
        if isinstance(default_sections, int):
            self[default_sections] = LotDefinitions(default_sections)
        elif isinstance(default_sections, list):
            for sec in default_sections:
                self[sec] = LotDefinitions(sec)

    def set_section(self, sec_num: int, lot_defs: LotDefinitions):
        &#34;&#34;&#34;
        Set the LotDefinitions object for a specified section.
        &#34;&#34;&#34;
        # This need not be a defined method, but it&#39;s more intuitively
        # named, so... why not.
        self[sec_num] = lot_defs

    def get_ld(self, sec_num: int, allow_ld_defaults=False,
               force_ld_return=False):
        &#34;&#34;&#34;
        A custom getter for pulling LotDefinitions object for the
        requested section, out of this TwpLotDefinitions object. There
        are two parameters to dictate the behavior of this getter, in
        the event that the key (`sec_num`) does not exist in this dict,
        and they apply in order:
        -- `allow_ld_defaults` (defaults to False): If an explicit
        LotDefinitions object does not already exist for the requested
        key (`sec_num`), then create and return a default LotDefinitions
        object, whose lots are defined as defaults according to the
        `sec_num`. In other words, if `sec_num` is an integer of 1 - 7,
        18, 19, 30, or 31, the returned LotDefinitions object will have
        some lots defined (per a &#39;standard&#39; township); but any other
        section number would be an empty LotDefinitions object.
            NOTE: This getter does NOT add the returned default
                LotDefinitions object to the TwpLotDefinitions object!
        -- `force_ld_return` (defaults to False): If an explicit
        LotDefinitions object does not already exist, and the user did
        not want a default LotDefinitions object as a backup, then this
        parameter dictates whether to return None (i.e. `=False`), or to
        return an empty LotDefinitions object (i.e. `=True`).
            NOTE: This getter does NOT add the returned empty
                LotDefinitions object to the TwpLotDefinitions object!

        :param sec_num: The section number, whose LotDefinitions object
        is requested (i.e. the dict key).
        :param allow_ld_defaults: As discussed above.
        :param force_ld_return:  As discussed above.
        :return: If [a] a LotDefinitions object exists for the requested
        section, [b] the user passed `allow_ld_defaults=True`, AND/OR
        [c] the user passed `force_ld_return=True` -- then will return a
        LotDefinitions object. Otherwise, will return None.
        &#34;&#34;&#34;

        sec_num = int(sec_num)
        ld = self.get(sec_num, None)
        if ld is not None:
            return ld
        elif allow_ld_defaults:
            # If there was no LD set for this section, but the user wants
            # to allow default LD&#39;s, generate and return a section-default
            # LD now.
            return LotDefinitions(default=sec_num)
        elif force_ld_return:
            # If the LD was not set for this section, and the user
            # prohibited defaults, but the user still wants to receive a
            # LotDefinitions object... we return an empty LD obj.
            return LotDefinitions()
        else:
            return None

    @staticmethod
    def from_csv(fp, twp: str, rge: str):
        &#34;&#34;&#34;
        Generate a TwpLotDefinitions object from a properly formatted**
        .csv file at filepath `fp`. Specify `twp=&lt;str&gt;` and `rge=&lt;str&gt;`
        for which rows should match.
            ex: tld_obj = TwpLotDefinitions.from_csv(
                    r&#39;assets\examples\SAMPLE_LDDB.csv&#39;,
                    twp=&#39;154n&#39;, rge=&#39;97w&#39;)

        **See the docstring for LotDefDB for proper .csv formatting.

        :param fp: Filepath to the .csv file to load.
        :param twp: Township number (up to 3 digits) and N/S direction
        (as a single lowercase character).
            ex: &#39;154n&#39;, &#39;1s&#39;, etc.
        :param rge: Range number (up to 3 digits) and E/W direction
        (as a single lowercase character).
            ex: &#39;97w&#39;, &#39;7e&#39;, etc.
        :return: A new TwpLotDefinitions object that has loaded all
        relevant data from the .csv file.
        &#34;&#34;&#34;

        if None in [twp, rge]:
            raise ValueError(&#39;`twp` and `rge` must be specified.&#39;)

        twp = twp.lower()
        rge = rge.lower()

        # Load a full LotDefDB object from .csv file, and then pull our
        # twp+rge from it. If our twp+rge does not exist as a key,
        # return an empty TLD object.
        temp_lddb = LotDefDB(from_csv=fp)
        return temp_lddb.get_tld(
            twp+rge, allow_ld_defaults=False, force_tld_return=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv"><code class="name flex">
<span>def <span class="ident">from_csv</span></span>(<span>fp, twp:Â str, rge:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a TwpLotDefinitions object from a properly formatted**
.csv file at filepath <code>fp</code>. Specify <code>twp=&lt;str&gt;</code> and <code>rge=&lt;str&gt;</code>
for which rows should match.
ex: tld_obj = TwpLotDefinitions.from_csv(
r'assets\examples\SAMPLE_LDDB.csv',
twp='154n', rge='97w')</p>
<p>**See the docstring for LotDefDB for proper .csv formatting.</p>
<p>:param fp: Filepath to the .csv file to load.
:param twp: Township number (up to 3 digits) and N/S direction
(as a single lowercase character).
ex: '154n', '1s', etc.
:param rge: Range number (up to 3 digits) and E/W direction
(as a single lowercase character).
ex: '97w', '7e', etc.
:return: A new TwpLotDefinitions object that has loaded all
relevant data from the .csv file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_csv(fp, twp: str, rge: str):
    &#34;&#34;&#34;
    Generate a TwpLotDefinitions object from a properly formatted**
    .csv file at filepath `fp`. Specify `twp=&lt;str&gt;` and `rge=&lt;str&gt;`
    for which rows should match.
        ex: tld_obj = TwpLotDefinitions.from_csv(
                r&#39;assets\examples\SAMPLE_LDDB.csv&#39;,
                twp=&#39;154n&#39;, rge=&#39;97w&#39;)

    **See the docstring for LotDefDB for proper .csv formatting.

    :param fp: Filepath to the .csv file to load.
    :param twp: Township number (up to 3 digits) and N/S direction
    (as a single lowercase character).
        ex: &#39;154n&#39;, &#39;1s&#39;, etc.
    :param rge: Range number (up to 3 digits) and E/W direction
    (as a single lowercase character).
        ex: &#39;97w&#39;, &#39;7e&#39;, etc.
    :return: A new TwpLotDefinitions object that has loaded all
    relevant data from the .csv file.
    &#34;&#34;&#34;

    if None in [twp, rge]:
        raise ValueError(&#39;`twp` and `rge` must be specified.&#39;)

    twp = twp.lower()
    rge = rge.lower()

    # Load a full LotDefDB object from .csv file, and then pull our
    # twp+rge from it. If our twp+rge does not exist as a key,
    # return an empty TLD object.
    temp_lddb = LotDefDB(from_csv=fp)
    return temp_lddb.get_tld(
        twp+rge, allow_ld_defaults=False, force_tld_return=True)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld"><code class="name flex">
<span>def <span class="ident">get_ld</span></span>(<span>self, sec_num:Â int, allow_ld_defaults=False, force_ld_return=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A custom getter for pulling LotDefinitions object for the
requested section, out of this TwpLotDefinitions object. There
are two parameters to dictate the behavior of this getter, in
the event that the key (<code>sec_num</code>) does not exist in this dict,
and they apply in order:
&ndash; <code>allow_ld_defaults</code> (defaults to False): If an explicit
LotDefinitions object does not already exist for the requested
key (<code>sec_num</code>), then create and return a default LotDefinitions
object, whose lots are defined as defaults according to the
<code>sec_num</code>. In other words, if <code>sec_num</code> is an integer of 1 - 7,
18, 19, 30, or 31, the returned LotDefinitions object will have
some lots defined (per a 'standard' township); but any other
section number would be an empty LotDefinitions object.
NOTE: This getter does NOT add the returned default
LotDefinitions object to the TwpLotDefinitions object!
&ndash; <code>force_ld_return</code> (defaults to False): If an explicit
LotDefinitions object does not already exist, and the user did
not want a default LotDefinitions object as a backup, then this
parameter dictates whether to return None (i.e. <code>=False</code>), or to
return an empty LotDefinitions object (i.e. <code>=True</code>).
NOTE: This getter does NOT add the returned empty
LotDefinitions object to the TwpLotDefinitions object!</p>
<p>:param sec_num: The section number, whose LotDefinitions object
is requested (i.e. the dict key).
:param allow_ld_defaults: As discussed above.
:param force_ld_return:
As discussed above.
:return: If [a] a LotDefinitions object exists for the requested
section, [b] the user passed <code>allow_ld_defaults=True</code>, AND/OR
[c] the user passed <code>force_ld_return=True</code> &ndash; then will return a
LotDefinitions object. Otherwise, will return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ld(self, sec_num: int, allow_ld_defaults=False,
           force_ld_return=False):
    &#34;&#34;&#34;
    A custom getter for pulling LotDefinitions object for the
    requested section, out of this TwpLotDefinitions object. There
    are two parameters to dictate the behavior of this getter, in
    the event that the key (`sec_num`) does not exist in this dict,
    and they apply in order:
    -- `allow_ld_defaults` (defaults to False): If an explicit
    LotDefinitions object does not already exist for the requested
    key (`sec_num`), then create and return a default LotDefinitions
    object, whose lots are defined as defaults according to the
    `sec_num`. In other words, if `sec_num` is an integer of 1 - 7,
    18, 19, 30, or 31, the returned LotDefinitions object will have
    some lots defined (per a &#39;standard&#39; township); but any other
    section number would be an empty LotDefinitions object.
        NOTE: This getter does NOT add the returned default
            LotDefinitions object to the TwpLotDefinitions object!
    -- `force_ld_return` (defaults to False): If an explicit
    LotDefinitions object does not already exist, and the user did
    not want a default LotDefinitions object as a backup, then this
    parameter dictates whether to return None (i.e. `=False`), or to
    return an empty LotDefinitions object (i.e. `=True`).
        NOTE: This getter does NOT add the returned empty
            LotDefinitions object to the TwpLotDefinitions object!

    :param sec_num: The section number, whose LotDefinitions object
    is requested (i.e. the dict key).
    :param allow_ld_defaults: As discussed above.
    :param force_ld_return:  As discussed above.
    :return: If [a] a LotDefinitions object exists for the requested
    section, [b] the user passed `allow_ld_defaults=True`, AND/OR
    [c] the user passed `force_ld_return=True` -- then will return a
    LotDefinitions object. Otherwise, will return None.
    &#34;&#34;&#34;

    sec_num = int(sec_num)
    ld = self.get(sec_num, None)
    if ld is not None:
        return ld
    elif allow_ld_defaults:
        # If there was no LD set for this section, but the user wants
        # to allow default LD&#39;s, generate and return a section-default
        # LD now.
        return LotDefinitions(default=sec_num)
    elif force_ld_return:
        # If the LD was not set for this section, and the user
        # prohibited defaults, but the user still wants to receive a
        # LotDefinitions object... we return an empty LD obj.
        return LotDefinitions()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pyTRSplat.grid.Grid.TwpLotDefinitions.set_section"><code class="name flex">
<span>def <span class="ident">set_section</span></span>(<span>self, sec_num:Â int, lot_defs:Â <a title="pyTRSplat.grid.Grid.LotDefinitions" href="#pyTRSplat.grid.Grid.LotDefinitions">LotDefinitions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the LotDefinitions object for a specified section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_section(self, sec_num: int, lot_defs: LotDefinitions):
    &#34;&#34;&#34;
    Set the LotDefinitions object for a specified section.
    &#34;&#34;&#34;
    # This need not be a defined method, but it&#39;s more intuitively
    # named, so... why not.
    self[sec_num] = lot_defs</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyTRSplat.grid" href="index.html">pyTRSplat.grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyTRSplat.grid.Grid.plssdesc_to_twp_grids" href="#pyTRSplat.grid.Grid.plssdesc_to_twp_grids">plssdesc_to_twp_grids</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.tracts_into_twp_grids" href="#pyTRSplat.grid.Grid.tracts_into_twp_grids">tracts_into_twp_grids</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyTRSplat.grid.Grid.LotDefDB" href="#pyTRSplat.grid.Grid.LotDefDB">LotDefDB</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.grid.Grid.LotDefDB.get_tld" href="#pyTRSplat.grid.Grid.LotDefDB.get_tld">get_tld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefDB.set_twp" href="#pyTRSplat.grid.Grid.LotDefDB.set_twp">set_twp</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefDB.trs" href="#pyTRSplat.grid.Grid.LotDefDB.trs">trs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.grid.Grid.LotDefinitions" href="#pyTRSplat.grid.Grid.LotDefinitions">LotDefinitions</a></code></h4>
<ul class="two-column">
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.DEF_00" href="#pyTRSplat.grid.Grid.LotDefinitions.DEF_00">DEF_00</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.DEF_01_to_05" href="#pyTRSplat.grid.Grid.LotDefinitions.DEF_01_to_05">DEF_01_to_05</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.DEF_06" href="#pyTRSplat.grid.Grid.LotDefinitions.DEF_06">DEF_06</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.DEF_07_18_19_30_31" href="#pyTRSplat.grid.Grid.LotDefinitions.DEF_07_18_19_30_31">DEF_07_18_19_30_31</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.absorb_ld" href="#pyTRSplat.grid.Grid.LotDefinitions.absorb_ld">absorb_ld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.lots_by_qq_name" href="#pyTRSplat.grid.Grid.LotDefinitions.lots_by_qq_name">lots_by_qq_name</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.LotDefinitions.set_lot" href="#pyTRSplat.grid.Grid.LotDefinitions.set_lot">set_lot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.grid.Grid.SectionGrid" href="#pyTRSplat.grid.Grid.SectionGrid">SectionGrid</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.apply_lddb" href="#pyTRSplat.grid.Grid.SectionGrid.apply_lddb">apply_lddb</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.apply_tld" href="#pyTRSplat.grid.Grid.SectionGrid.apply_tld">apply_tld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.filled_coords" href="#pyTRSplat.grid.Grid.SectionGrid.filled_coords">filled_coords</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.filled_qqs" href="#pyTRSplat.grid.Grid.SectionGrid.filled_qqs">filled_qqs</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.from_tract" href="#pyTRSplat.grid.Grid.SectionGrid.from_tract">from_tract</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.from_trs" href="#pyTRSplat.grid.Grid.SectionGrid.from_trs">from_trs</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.has_any" href="#pyTRSplat.grid.Grid.SectionGrid.has_any">has_any</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.incorporate_lot_list" href="#pyTRSplat.grid.Grid.SectionGrid.incorporate_lot_list">incorporate_lot_list</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.incorporate_qq_list" href="#pyTRSplat.grid.Grid.SectionGrid.incorporate_qq_list">incorporate_qq_list</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.incorporate_tract" href="#pyTRSplat.grid.Grid.SectionGrid.incorporate_tract">incorporate_tract</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.lots_by_grid" href="#pyTRSplat.grid.Grid.SectionGrid.lots_by_grid">lots_by_grid</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.lots_by_qq_name" href="#pyTRSplat.grid.Grid.SectionGrid.lots_by_qq_name">lots_by_qq_name</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.output_array" href="#pyTRSplat.grid.Grid.SectionGrid.output_array">output_array</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.output_text_plat" href="#pyTRSplat.grid.Grid.SectionGrid.output_text_plat">output_text_plat</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.turn_off_qq" href="#pyTRSplat.grid.Grid.SectionGrid.turn_off_qq">turn_off_qq</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.SectionGrid.turn_on_qq" href="#pyTRSplat.grid.Grid.SectionGrid.turn_on_qq">turn_on_qq</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.grid.Grid.TownshipGrid" href="#pyTRSplat.grid.Grid.TownshipGrid">TownshipGrid</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.RIGHT_TO_LEFT_SECTIONS" href="#pyTRSplat.grid.Grid.TownshipGrid.RIGHT_TO_LEFT_SECTIONS">RIGHT_TO_LEFT_SECTIONS</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.apply_ld" href="#pyTRSplat.grid.Grid.TownshipGrid.apply_ld">apply_ld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.apply_tld" href="#pyTRSplat.grid.Grid.TownshipGrid.apply_tld">apply_tld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.filled_section_grids" href="#pyTRSplat.grid.Grid.TownshipGrid.filled_section_grids">filled_section_grids</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.incorporate_tract" href="#pyTRSplat.grid.Grid.TownshipGrid.incorporate_tract">incorporate_tract</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.turn_off_qq" href="#pyTRSplat.grid.Grid.TownshipGrid.turn_off_qq">turn_off_qq</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TownshipGrid.turn_on_qq" href="#pyTRSplat.grid.Grid.TownshipGrid.turn_on_qq">turn_on_qq</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions" href="#pyTRSplat.grid.Grid.TwpLotDefinitions">TwpLotDefinitions</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.from_csv">from_csv</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.get_ld">get_ld</a></code></li>
<li><code><a title="pyTRSplat.grid.Grid.TwpLotDefinitions.set_section" href="#pyTRSplat.grid.Grid.TwpLotDefinitions.set_section">set_section</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>