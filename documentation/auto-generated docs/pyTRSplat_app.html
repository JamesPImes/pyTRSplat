<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyTRSplat.pyTRSplat_app API documentation</title>
<meta name="description" content="A GUI application for converting text of PLSS land descriptions (&#39;legal
descriptions&#39;) to plats using the pyTRSplat module." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyTRSplat.pyTRSplat_app</code></h1>
</header>
<section id="section-intro">
<p>A GUI application for converting text of PLSS land descriptions ('legal
descriptions') to plats using the pyTRSplat module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2020, James P. Imes. All rights reserved.

&#34;&#34;&#34;
A GUI application for converting text of PLSS land descriptions (&#39;legal
descriptions&#39;) to plats using the pyTRSplat module.
&#34;&#34;&#34;

# TODO: Allow user to save selected page(s), rather than all.

import pyTRSplat._constants as _constants
from pyTRSplat import version
from pyTRSplat.plat import Plat, MultiPlat
from pyTRSplat.grid import SectionGrid, LotDefDB
from pyTRSplat.platsettings import Settings
from pyTRSplat.platqueue import MultiPlatQueue
from pyTRSplat.utils import _simplify_lot_number

from pyTRSplat.settingseditor import SettingsEditor
from pyTRSplat.imgdisplay import ScrollResizeDisplay

import pyTRS
import pyTRS._constants as pyTRS_constants
from pyTRS import version as pyTRS_version

import tkinter as tk
from tkinter.ttk import Combobox, Checkbutton
from tkinter import messagebox, filedialog
from tkinter import Label

from pathlib import Path

from PIL import ImageTk


########################################################################
# Main Application Window
########################################################################

class MainWindow(tk.Tk):

    def __init__(self):
        tk.Tk.__init__(self)
        self.title(&#39;pyTRSplat - Text-to-Plat Generator&#39;)

        # Store an empty LotDefDB object as `.lddb`
        self.lddb = LotDefDB()

        # Store (initially empty) queue of ad-hoc objects to be added to
        # the plat(s) -- e.g. SectionGrid, TownshipGrid, etc.
        self.ad_hoc_mpq = MultiPlatQueue()

        # Store a plain list (currently empty) of PLSSDesc objects that
        # will be platted
        self.plssdesc_list = []

        # A tab-notebook for switching between adding descriptions and
        # manually adding QQ&#39;s
        self.adder_tabs = tk.ttk.Notebook(self)
        self.adder_tabs.grid(row=1, column=1)

        # A widget for entering land descriptions, configuring parse,
        # loading LotDefDB, etc.
        self.desc_frame = DescFrame(master=self)
        self.adder_tabs.add(
            self.desc_frame, text=&#39;Add lands by description text&#39;)

        # A widget for adding QQ&#39;s manually (into `.ad_hoc_mpq`)
        self.manual_platter = ManualPlatter(
            master=self, mpq_owner=self)
        self.adder_tabs.add(self.manual_platter, text=&#34;Add QQ&#39;s manually&#34;)

        right_side_frame = tk.Frame(self)
        right_side_frame.grid(row=1, column=2, sticky=&#39;ns&#39;)

        # A widget for displaying a mini preview of the plat so far
        self.preview_frame = PlatPreview(right_side_frame, preview_owner=self)
        self.preview_frame.grid(row=1, column=2, sticky=&#39;n&#39;)

        # A widget for output settings / buttons. (Contains the plat
        # generator at `.output_frame.gen_plat()`
        self.output_frame = OutputFrame(right_side_frame, output_owner=self)
        self.output_frame.grid(row=2, column=2, pady=24, sticky=&#39;s&#39;)

        # Widget containing &#39;About&#39; and &#39;disclaimer&#39; buttons.
        self.about = About(master=self)
        self.about.grid(row=2, column=1, padx=4, pady=4, sticky=&#39;sw&#39;)

        #################################
        # Configurables:
        #################################

        # Whether to display a pop-up message every time a flawed parse
        # is noticed in the `.desc_frame`
        self.warn_flawed_parse = True

        # When clicking preview/save buttons, warn about any lots that
        # were not defined. If True and any are found, will prompt user
        # to define them now.
        self.warn_unhandled_lots = True

    @property
    def mpq(self):
        &#34;&#34;&#34;Return a MultiPlatQueue object from the `self.plssdesc_list`
        and `self.ad_hoc_mpq`.&#34;&#34;&#34;
        mpq = MultiPlatQueue()
        for obj in self.plssdesc_list:
            mpq.queue_add(obj)
        mpq.absorb(self.ad_hoc_mpq)
        return mpq

    def trigger_update_preview(self):
        &#34;&#34;&#34;Update the preview in `.preview_frame`.&#34;&#34;&#34;
        self.preview_frame.gen_preview()


########################################################################
# Getting / Parsing / Managing Land Descriptions and loading LotDefDB
########################################################################

class DescFrame(tk.Frame):
    &#34;&#34;&#34;A frame for getting / clearing text of description to parse and
    add to the plat, getting LotDefDB from .csv.&#34;&#34;&#34;
    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.master = master
        if not hasattr(master, &#39;warn_flawed_parse&#39;):
            master.warn_flawed_parse = True
        # a tk var containing Default config parameters for pyTRS parsing.
        self.config_text = tk.StringVar()
        self.config_text.set(&#39;&#39;)
        self.config_popup_tk = None

        # For getting the PLSS descriptions from user.
        desc_frame = tk.Frame(self)
        desc_frame.grid(row=0, column=1, sticky=&#39;n&#39;, padx=5, pady=5)

        # For getting .csv file for LotDefDB from user
        lddb_save_frame = tk.Frame(self)
        lddb_save_frame.grid(row=5, column=1, sticky=&#39;sw&#39;)

        # Button to configure pyTRS parameters
        cf_button = tk.Button(
            desc_frame, text=&#39;Configure Parse&#39;, height=2,
            command=self.cf_btn_clicked)
        cf_button.grid(row=3, column=1, pady=8, sticky=&#39;w&#39;)

        # Button to commence pyTRS parsing (and add resulting PLSSDesc to MPQ)
        parse_button = tk.Button(
            desc_frame, text=&#39;Parse Description / Add to Plat&#39;, height=2,
            command=self.parse_btn_clicked)
        parse_button.grid(row=3, column=1, pady=8, sticky=&#39;e&#39;)

        desc_box_header = tk.Label(
            desc_frame, text=&#39;Enter one or more land descriptions:&#39;)
        desc_box_header.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.desc_box_entry = tk.Text(desc_frame, width=36, height=9)
        self.desc_box_entry.grid(row=2, column=1)

        # Button to launch description editor
        editor_button = tk.Button(
            desc_frame, text=&#39;Description Editor&#39;, height=2,
            command=self.editor_btn_clicked)
        editor_button.grid(row=4, column=1, pady=5, sticky=&#39;w&#39;)

        # Button to clear all PLSSDesc&#39;s from the MPQ
        clear_button = tk.Button(
            desc_frame, text=&#39;Clear All Descriptions&#39;, height=2,
            command=self.clear_btn_clicked)
        clear_button.grid(row=4, column=1, pady=5, sticky=&#39;e&#39;)

        # Button to load LotDefDB from .csv file
        lddb_button = tk.Button(
            desc_frame, text=&#39;Get lot definitions from .csv&#39;, height=2,
            command=self.lddb_btn_clicked)
        lddb_button.grid(row=5, column=1, pady=5, sticky=&#39;w&#39;)

        # Button to view / manually define lots
        ld_editor_btn = tk.Button(
            desc_frame, text=&#39;View / define Lots&#39;, height=2,
            command=self.manual_lddb_clicked)
        ld_editor_btn.grid(row=5, column=1, pady=5, sticky=&#39;e&#39;)

        # Our current LotDefEditor toplevel (if any)
        self.lde = None

        self.lddp_fp_text = tk.StringVar(&#39;&#39;)
        self.lddp_fp_text.set(f&#34;Current lot definitions: [None loaded]&#34;)
        lddb_label = tk.Label(desc_frame, textvariable=self.lddp_fp_text)
        # lddb_label.grid(row=7, column=1, sticky=&#39;w&#39;)

        default_lots_frame = tk.Frame(desc_frame)
        default_lots_frame.grid(row=8, column=1, sticky=&#39;w&#39;)

        self.trust_default_lots = tk.BooleanVar(
            desc_frame, value=True, name=&#39;trust_default_lots&#39;)
        lots_chkbtn = Checkbutton(
            default_lots_frame, text=&#39;Trust Default Lots&#39;, onvalue=True,
            offvalue=False, variable=self.trust_default_lots,
            command=self.trigger_update_preview)
        lots_chkbtn.grid(row=1, column=2, sticky=&#39;w&#39;)

        lots_help_btn = tk.Button(
            default_lots_frame, text=&#39;?&#39;, padx=4,
            command=self.lots_help_btn_clicked)
        lots_help_btn.grid(
            row=1, column=1, sticky=&#39;w&#39;)

    def manual_lddb_clicked(self):
        &#34;&#34;&#34;
        Check if any lots currently exist in the parsed descriptions.
        If so, launch the lot viewer / editor window.
        &#34;&#34;&#34;
        try:
            self.lde.destroy()
        except:
            pass

        def unpack_tract(tract, lots):
            for lot in tract.lotList:
                lots.setdefault(tract.trs, [])
                if lot not in lots[tract.trs]:
                    lots[tract.trs].append(lot)

        # Use tiny settings for speed. Only want the unhandled lots.
        mp = self.master.output_frame.gen_plat(use_tiny=True)

        # Get a unhandled_lots dict, and set it to `lots` variable.
        # (Here we don&#39;t care about the first-returned value, a bool.)
        _, lots = self.master.output_frame._check_for_unhandled_lots(
            mp, warn=False, do_not_launch=True)

        for desc_obj in self.master.plssdesc_list:
            for tract in desc_obj.parsedTracts:
                unpack_tract(tract, lots)

        if len(lots) == 0:
            messagebox.showinfo(
                &#39;No Lots&#39;,
                &#39;There are currently no lots in parsed descriptions. Try &#39;
                &#39;adding one or more land descriptions above.&#39;
            )
            return

        self.lde = LotDefEditor(
            self, top_owner=self.master, target_lddb=self.master.lddb,
            lots=lots)
        self.lde.focus()

    def editor_btn_clicked(self):
        &#34;&#34;&#34;Launch (or refocus-on) a DescriptionEditor popup window, for
        editing already-added descriptions.&#34;&#34;&#34;
        if len(self.master.plssdesc_list) == 0:
            messagebox.showinfo(
                &#39;No descriptions&#39;,
                &#39;No descriptions to view / edit. Add land descriptions above.&#39;)
            return

        # Try grabbing the existing editor window, if it exists. If not,
        # launch a new editor window.
        try:
            self.editor_window.focus()
            self.editor_window.grab_set()
            return
        except:
            pass

        self.editor_window = DescriptionEditor(
            self, plssdesc_list=self.master.plssdesc_list,
            plssdesc_list_owner=self.master)
        self.editor_window.title(&#39;pyTRSplat - View / Edit Descriptions&#39;)
        self.editor_window.focus()
        self.editor_window.grab_set()

    def cf_btn_clicked(self):
        &#34;&#34;&#34;
        Config button was clicked; launch popup window to get Config
        parameters from user (results are stored in StringVar
        `self.config_text`).
        &#34;&#34;&#34;
        try:
            # Kill the previously opened config popup, if any.
            self.config_popup_tk.destroy()
        except:
            pass

        # Open a config popup, and store it to attrib.
        self.config_popup_tk = tk.Toplevel()
        self.config_popup_tk.focus()
        self.config_popup_tk.grab_set()
        self.config_popup_tk.title(&#39;Set pyTRS Config Parameters&#39;)
        after_prompt = None
        if len(self.master.plssdesc_list) &gt; 0:
            # If the user has already parsed one or more descriptions,
            # we&#39;ll give this notice after config parameters are set.
            after_prompt = (
                &#39;NOTE: &#39;
                &#39;The config parameters that have just been set will ONLY &#39;
                &#39;affect descriptions that are parsed AFTER this point. Any &#39;
                &#39;descriptions that have already been parsed and added to &#39;
                &#39;the plat will NOT be affected by changes to these config &#39;
                &#39;parameters. (To reconfigure already-parsed descriptions, &#39;
                &#39;use the Description Editor.)&#39;)
        pc = pyTRS.interface_tools.PromptConfig(
            master=self.config_popup_tk, target_config_var=self.config_text,
            parameters=[
                &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
            ],
            show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
            exit_after_ok=True)
        pc.pack(padx=20, pady=10)

    def parse_btn_clicked(self):
        &#34;&#34;&#34;
        Pull the entered text, and use the chosen config parameters (if
        any) to generate a PLSSDesc object, and add it to the queue to
        plat.
        &#34;&#34;&#34;
        config_text = self.config_text.get()
        descrip_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)

        if len(descrip_text) &lt; 2:
            return

        # Create a PLSSDesc object from the supplied text and parse it using the
        # specified config parameters (if any).
        desc = pyTRS.PLSSDesc(descrip_text, config=config_text, initParseQQ=True)

        if len(desc.eFlagList) &gt; 0 and self.master.warn_flawed_parse:
            eFlags = &#39;, &#39;.join(desc.eFlagList)
            confirm = tk.messagebox.askokcancel(
                &#39;Flawed Description Identified&#39;,
                &#39;One or more apparent flaws was identified when parsing this &#39;
                &#39;description, potentially due to non-standard abbreviations, &#39;
                &#39;typos, etc., or due to limitations in the parsing library:\n\n&#39;
                f&#34;&lt;flag codes:  {eFlags}&gt;&#34;
                &#39;\n\n&#39;
                &#39;The description can still be platted, although results may &#39;
                &#39;not be as intended.\n\n&#39;
                &#39;(The Description Editor can also be used at any time to view &#39;
                &#39;/ edit descriptions, and see additional parsing information.)&#39;
            )

            if not confirm:
                return

        # Add desc to the plssdesc_list
        self.master.plssdesc_list.append(desc)

        # Clear the text from the desc_box_entry
        self.desc_box_entry.delete(&#34;1.0&#34;, &#39;end-1c&#39;)

        # And update the preview plat.
        self.trigger_update_preview()

    def trigger_update_preview(self):
        self.master.preview_frame.gen_preview()

    def clear_btn_clicked(self):
        &#34;&#34;&#34;
        Clear all plats and descriptions (reset to start).
        NOTE: Does NOT clear manually added QQ&#39;s.
        &#34;&#34;&#34;
        prompt = messagebox.askyesno(
            &#39;Confirm?&#39;,
            &#39;Delete all added descriptions? (Does not delete manually added &#39;
            &#34;QQ&#39;s.)&#34;,
            icon=&#39;warning&#39;)

        if prompt is True:
            # Set the `.plssdesc_list` to an empty list
            self.master.plssdesc_list = []

            # Generate a new preview (which will be an empty plat)
            self.master.preview_frame.gen_preview()

    def lddb_btn_clicked(self):
        &#34;&#34;&#34;Prompt user for .csv file containing LotDefDB data. If
        selected, loads from that file into `master.lddb` attribute, and
        replaces the existing LotDefDB in that attribute.&#34;&#34;&#34;
        lddb_fp = filedialog.askopenfilename(
            initialdir=&#39;/&#39;,
            filetypes=[(&#34;CSV Files&#34;, &#34;*.csv&#34;)],
            title=&#39;CSV containing Lot Definition data...&#39;
        )
        if lddb_fp:
            if lddb_fp.lower().endswith(&#39;.csv&#39;):
                try:
                    # Load the LDDB
                    self.master.lddb._import_csv(lddb_fp)

                    # Update the preview window
                    self.master.preview_frame.gen_preview()

                    # Set the label
                    max_chars = 20
                    name = Path(lddb_fp).name
                    if len(name) &gt; max_chars:
                        name = name[:max_chars - 3] + &#39;...&#39;
                    self.lddp_fp_text.set(
                        f&#34;Current lot definitions: {name}&#34;)

                except:
                    messagebox.showerror(
                        &#39;Could Not Load File&#39;,
                        f&#34;Chosen file &#39;{lddb_fp}&#39; could not be loaded.&#34;)
            else:
                messagebox.showerror(
                    &#39;.csv Files Only&#39;, &#39;May only load \&#39;.csv\&#39; files containing &#39;
                                       &#39;lot definitions.&#39;)

    def lots_help_btn_clicked(self):
        &#34;&#34;&#34;Display info about LotDefDB and default lots.&#34;&#34;&#34;

        msg = (
            &#34;By checking &#39;Trust Default Lots&#39;, this program will interpret &#34;
            &#34;lots in Sections 1 - 7, 18, 19, 30, and 31 as though they are &#34;
            &#34;lots in a &#39;standard&#39; township, unless the user has otherwise &#34;
            &#34;defined lots for a given section manually (with the &#39;Define &#34;
            &#34;Lots&#39; function) and/or by loading a .csv file containing lot &#34;
            &#34;definitions (to see how to format such a .csv file, see the &#34;
            &#34;included `SAMPLE_LDDB.csv` and/or the documentation).&#34;
            &#34;\n\n&#34;
            &#34;NOTE: Default lots will ONLY be used where no lots have been &#34;
            &#34;defined for a given section individually or in a loaded .csv &#34;
            &#34;file. (If a .csv file has been loaded, and/or if some lots have &#34;
            &#34;been defined individually, but not any lots for Section 4, &#34;
            &#34;T154N-R97W, then default lots would be used for that Section 4 &#34;
            &#34;-- as long as this box is checked.)&#34;
            &#34;\n\n\n&#34;
            &#34;MORE INFO:\n&#34;
            &#34;A so-called &#39;standard&#39; township would have been surveyed in such &#34;
            &#34;a way that there are lots along the northern and western &#34;
            &#34;boundaries -- i.e. along the boundaries of Sections 1 - 7, 18, &#34;
            &#34;19, 30, and 31. These lot numbers are predictable (e.g. Lots 1, &#34;
            &#34;2, 3, and 4 in a &#39;standard&#39; Section 1 correspond with the NE¼NE¼, &#34;
            &#34;NW¼NE¼, NE¼NW¼, and NW¼NW¼, respectively). Every other square in &#34;
            &#34;a &#39;standard&#39; township is an essentially perfect 40-acre square &#34;
            &#34;called a &#39;quarter-quarter&#39; (or &#39;QQ&#39;).&#34;
            &#34;\n\n&#34;
            &#34;However, in practice, townships are rarely &#39;standard&#39;. Natural &#34;
            &#34;features like rivers, lakes, mountains, the curvature of the &#34;
            &#34;earth, etc. -- or faulty surveys -- may result in differently &#34;
            &#34;numbered lots in Sections 1 - 7, 18, 19, 30, and 31; as well as &#34;
            &#34;lots in any other sections.&#34;
            &#34;\n\n&#34;
            &#34;&#39;Trust Default Lots&#39; may be useful as a backup option, but &#34;
            &#34;a more accurate plat can be achieved by defining specific lots &#34;
            &#34;individually with the &#39;Define Lots&#39; feature, and/or by defining &#34;
            &#34;them in a .csv spreadsheet and loading from that.&#34;
        )
        messagebox.showinfo(&#39;Default Lots&#39;, msg)


########################################################################
# Generating, Displaying, and Controlling Plat Mini-Preview
########################################################################

class PlatPreview(tk.Frame):
    &#34;&#34;&#34;A frame displaying a preview of the plat, plus its controls.&#34;&#34;&#34;

    ###################
    # pyTRSplat.settings.Settings object
    ###################
    # Generate a Settings object for the mini-preview, with no
    # margins. (Hard-coded here, rather than creating it as a preset,
    # so that it will never be changed to unexpected settings.)
    PREVIEW_SETTINGS = Settings(preset=None)
    PREVIEW_SETTINGS_NONE = Settings(preset=None)
    for set_obj in [PREVIEW_SETTINGS, PREVIEW_SETTINGS_NONE]:
        set_obj.qq_side = 8
        set_obj.centerbox_wh = 12
        set_obj.sec_line_stroke = 1
        set_obj.qql_stroke = 1
        set_obj.ql_stroke = 1
        set_obj.sec_line_RGBA = (0, 0, 0, 255)
        set_obj.ql_RGBA = (128, 128, 128, 255)
        set_obj.qql_RGBA = (230, 230, 230, 255)
        set_obj.dim = (
            set_obj.qq_side * 4 * 6 + set_obj.sec_line_stroke,
            set_obj.qq_side * 4 * 6 + set_obj.sec_line_stroke)
        set_obj.y_top_marg = 0
        set_obj.set_font(&#39;sec&#39;, size=11)
        set_obj.write_header = False
        set_obj.write_tracts = False
        set_obj.write_lot_numbers = False

    # When there is nothing to preview, will show a grayed-out dummy plat.
    PREVIEW_SETTINGS_NONE.sec_line_RGBA = (148, 148, 148, 255)
    PREVIEW_SETTINGS_NONE.secfont_RGBA = (168, 168, 168, 255)
    PREVIEW_SETTINGS_NONE.ql_RGBA = (196, 196, 196, 255)
    PREVIEW_SETTINGS_NONE.centerbox_wh = 14

    def __init__(self, master=None, preview_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master

        if preview_owner is None:
            preview_owner = master
        self.preview_owner = preview_owner

        # A list of Image objects of previews of the plats
        self.previews = []
        # A list of twp/rge (strings) to use as headers for previews of the plats
        self.previews_twprge = []
        # Current index of the preview
        self.preview_index = 0
        # Tracking if we&#39;re displaying a dummy (empty plat) in the preview
        self.dummy_set = False

        # Subframe for handling everything with the plat, other than getting
        # the PLSS descrips.
        plat_frame = tk.Frame(self)
        plat_frame.grid(row=0, column=2, sticky=&#39;n&#39;)

        # # Subframe for showing a preview of the plat, and controls for
        # # left/right
        # plat_preview_frame = tk.Frame(plat_frame)
        # plat_preview_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        # Subframe for showing the preview (this one does get stored to
        # self, because it gets updated with a new image periodically.
        self.plat_preview_display_frame = tk.Frame(master=self)
        self.plat_preview_display_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        # Subframe for controlling the preview (scroll left/right)
        plat_preview_control_frame = tk.Frame(master=self)
        plat_preview_control_frame.grid(row=2, column=1, sticky=&#39;n&#39;)

        preview_disp_header = Label(
            self.plat_preview_display_frame, text=&#39;Quick Preview&#39;)
        preview_disp_header.grid(row=1, column=1, pady=2, sticky=&#39;n&#39;)

        # A label below the preview image to display T&amp;R
        self.preview_footer_text = tk.StringVar()
        preview_disp_footer = Label(
            self.plat_preview_display_frame,
            textvariable=self.preview_footer_text)
        preview_disp_footer.grid(row=3, column=1, sticky=&#39;n&#39;)

        self.preview_disp_label = None

        # Update the `self.previews` list (starts as an empty list).
        self.gen_preview()

        # Button to scroll preview right
        preview_right_button = tk.Button(
            plat_preview_control_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_preview)
        preview_right_button.grid(
            row=1, column=2, padx=8, pady=5, sticky=&#39;n&#39;)

        # Button to scroll preview left
        preview_left_button = tk.Button(
            plat_preview_control_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_preview(-1))
        preview_left_button.grid(
            row=1, column=1, padx=8, pady=5, sticky=&#39;n&#39;)

    def gen_preview(self):
        &#34;&#34;&#34;Generate a new list of preview plats (Image objects) and set
        it to `self.previews`. (Discards the old previews.) Updates
        `self.dummy_set` as appropriate.&#34;&#34;&#34;
        mpq = self.preview_owner.mpq
        lddb = self.preview_owner.lddb

        # Get the bool var that decides whether we&#39;re supposed to trust
        # default lots (i.e. pass through to `allow_ld_defaults=`)
        trust_default_lots = self.preview_owner.desc_frame.getvar(
            name=&#39;trust_default_lots&#39;)
        trust_default_lots = bool(trust_default_lots)

        # Create a new MP
        new_preview_mp = MultiPlat.from_queue(
            mpq, settings=self.PREVIEW_SETTINGS, lddb=lddb,
            allow_ld_defaults=trust_default_lots)

        self.dummy_set = False

        # If there&#39;s nothing yet in the MPQ, manually create a &#39;dummy&#39; plat
        # and append it, so that there&#39;s something to show (an empty plat)
        if len(mpq.keys()) == 0:
            dummy = Plat(settings=self.PREVIEW_SETTINGS_NONE)
            new_preview_mp.plats.append(dummy)
            self.dummy_set = True

        # Output the plat images to a list, and set to `.previews`
        self.previews = new_preview_mp.output()

        # And create a list of &#39;twprge&#39; values for each of the images, and
        # set to `.previews_twprge`.
        self.previews_twprge = []
        for plObj in new_preview_mp.plats:
            self.previews_twprge.append(plObj.twprge)

        # Update the preview display
        self.update_preview_display()

    def update_preview_display(self, index=None):
        &#34;&#34;&#34;Update the preview image and header in this widget.&#34;&#34;&#34;

        if index is None:
            index = self.preview_index

        # Pull the image from the `.previews` list, and convert it to
        # `ImageTk.PhotoImage` obj
        if index &gt; len(self.previews) - 1:
            index = 0
            self.preview_index = 0
        img = self.previews[index]
        preview = ImageTk.PhotoImage(img, master=self)

        # Display the preview in this label.
        self.preview_disp_label = Label(
            self.plat_preview_display_frame, image=preview)
        self.preview_disp_label.image = preview
        self.preview_disp_label.grid(row=2, column=1, sticky=&#39;n&#39;)

        # Also update the footer.
        foot_txt = self.previews_twprge[index]
        foot_txt = f&#34;{foot_txt}  [{index + 1} / {len(self.previews)}]&#34;
        self.preview_footer_text.set(foot_txt)

        # But if we&#39;ve most recently set a dummy, clear the footer.
        if self.dummy_set:
            self.preview_footer_text.set(&#39;[No plats to display.]&#39;)

    def scroll_preview(self, direction=1):
        &#34;&#34;&#34;Scroll the preview left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        self.preview_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        self.preview_index %= len(self.previews)
        self.update_preview_display()


########################################################################
# Generating the Plats, Previewing a Final Page, Saving to File
########################################################################

class OutputFrame(tk.Frame):
    &#34;&#34;&#34;A frame containing output settings, preview button, and save
    button, and corresponding functionality. Also contains the plat
    generator. (Interacts with the `preview_frame` and `.mpq` of
    `master`.&#34;&#34;&#34;
    def __init__(self, master=None, output_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master

        if output_owner is None:
            output_owner = master
        self.output_owner = output_owner

        # Most recent custom Settings object, as configured in SettingsEditor
        self.current_custom_settings = None

        ####################################
        # Choosing Plat Settings
        ####################################

        # Subframe for getting the plat settings from user.
        self.settings_frame = tk.Frame(self)
        self.settings_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        self.settings_label = Label(
            self.settings_frame, text=&#39;Output settings:&#39;)
        self.settings_label.grid(row=2, column=1, pady=3, sticky=&#39;e&#39;)

        self.avail_settings = Settings.list_presets()
        self.settings_combo = Combobox(self.settings_frame, width=9)
        self.settings_combo[&#39;values&#39;] = self.avail_settings
        self.settings_combo.grid(row=2, column=2, sticky=&#39;w&#39;)
        # Set the combo to &#39;default&#39; preset. (If that doesn&#39;t exist, set to
        # whatever&#39;s first in the list.)
        try:
            settings_index = self.avail_settings.index(&#39;default&#39;)
        except ValueError:
            settings_index = 0
        self.settings_combo.current(settings_index)

        self.current_editor = None
        launch_editor_btn = tk.Button(
            self.settings_frame, text=&#39;Customize Settings&#39;, padx=3,
            command=self.editor_btn_clicked)
        launch_editor_btn.grid(row=3, column=1, sticky=&#39;w&#39;)

        ####################################
        # Full Page Preview / Save buttons
        ####################################

        # Subframe for &#39;save&#39; button and &#39;show full preview&#39; button
        self.save_full_preview_frame = tk.Frame(self)
        self.save_full_preview_frame.grid(row=2, column=1, sticky=&#39;n&#39;)

        # Button to show a full-sized version of the preview, using
        # current settings of the master window
        self.preview_full_button = tk.Button(
            self.save_full_preview_frame, text=&#39;Page Preview&#39;, height=2,
            width=12, command=self.preview_btn_clicked)
        self.preview_full_button.grid(
            row=2, column=1, padx=4, pady=5, sticky=&#39;w&#39;)

        # Button to save plats
        self.save_button = tk.Button(
            self.save_full_preview_frame, text=&#39;Save Plats&#39;, height=2,
            width=12, command=self.save_btn_clicked)
        self.save_button.grid(row=2, column=2, padx=4, pady=5, sticky=&#39;e&#39;)

    def editor_btn_clicked(self):
        &#34;&#34;&#34;
        Launch a CustomSettingsEditor window.
        :return:
        &#34;&#34;&#34;
        try:
            self.current_editor.destroy()
        except:
            pass
        self.current_editor = tk.Toplevel(self)
        self.current_editor.title(&#39;pyTRSplat - Customize Plat Settings&#39;)

        set_obj = self._get_settings(force_settings_return=True)

        editor = CustomSettingsEditor(
            master=self.current_editor, output_frame=self,
            first_settings_obj=set_obj)
        # Pre-fill the &#39;Load Preset&#39; combo with what was set in the OutputFrame
        editor.load_preset_name.delete(0, tk.END)
        editor.load_preset_name.insert(tk.END, self.settings_combo.get())

        editor.pack()
        self.current_editor.focus()
        self.current_editor.grab_set()

    ####################################
    # Generating the Plat(s)
    ####################################

    def _get_settings(self, force_settings_return=False):
        &#34;&#34;&#34;
        Get the appropriate Settings object, according to prior user
        input.
        &#34;&#34;&#34;
        cur_set_name = self.settings_combo.get()
        if cur_set_name == &#39;&lt;customized&gt;&#39;:
            set_obj = self.current_custom_settings
        elif cur_set_name in self.avail_settings:
            set_obj = Settings(preset=cur_set_name)
        elif force_settings_return:
            set_obj = Settings(preset=None)
        else:
            tk.messagebox.showerror(
                &#39;Unrecognized Settings Name&#39;,
                &#34;Choose one of the available settings. Or use &#39;Customize &#34;
                &#34;Settings&#39; to configure the plats.&#34;)
            self.focus()
            self.grab_set()
            return False

        return set_obj

    def gen_plat(self, use_tiny=False):
        &#34;&#34;&#34;
        Generate and return the Plat(s).
        :param use_tiny: Whether to use &#39;tiny&#39; settings, when we don&#39;t
        actually care about the output, and just want to process as
        quickly as possible to see what issues would pop up for when we
        eventually create the plat for real (e.g., unhandled lots).
        &#34;&#34;&#34;

        if use_tiny:
            set_obj = PlatPreview.PREVIEW_SETTINGS
        else:
            # Get the name of the preset `Settings` object we&#39;ll use.
            set_obj = self._get_settings()
        if set_obj is False:
            return

        # Get the bool var that decides whether we&#39;re supposed to trust
        # default lots (i.e. pass through to `allow_ld_defaults=`)
        trust_default_lots = self.output_owner.desc_frame.getvar(
            name=&#39;trust_default_lots&#39;)
        trust_default_lots = bool(trust_default_lots)

        return MultiPlat.from_queue(
            mpq=self.output_owner.mpq, settings=set_obj,
            lddb=self.output_owner.lddb, allow_ld_defaults=trust_default_lots)

    def _check_for_unhandled_lots(self, mp, warn=None, do_not_launch=False):
        &#34;&#34;&#34;
        Check for any unhandled lots in any of the plats. Raise a
        warning if any are found. (Warning may be disabled in main
        window settings.)
        :param mp: A MultiPlat object.
        :param warn: Whether to warn of discovered unhandled lots and
        ask the user whether to define them now. (If not specified,
        defaults to what is configured in `.warn_unhandled_lots` in main
        app Tk window.) If set to `False`, will automatically launch the
        definer if any undefined lots were identified.
        :param do_not_launch: A bool, whether to simply return what is
        found, without prompting the user to launch the editor or
        warning the user first. (Defaults to False.)
        :return: If user declines to define lots now (or if
        `do_not_launch` is passed as True), returns a 2-tuple:
            First element: bool (whether or not unhandled lots are found
                -- i.e. `True` means there is at least 1 unhandled lot;
            Second element: A dict containing all the unhandled lots,
                keyed by TRS (a string -- i.e. `154n97w01` for Sec 1,
                T154N-R97W), whose values are a list of lots that had
                no definition.
        If the user DOES decide to define lots now, this returns None
        and starts up a series of lot definers.
        &#34;&#34;&#34;
        confirm = True
        if warn is None:
            warn = self.output_owner.warn_unhandled_lots
            confirm = False

        if do_not_launch:
            warn = False
            confirm = False

        uhl = mp.all_unhandled_lots
        ret_uhl = {}  # the unhandled lots that will be returned (keyed by TRS)
        for twprge, plat_level_uhl in uhl.items():
            for sec_num, sec_uhl in plat_level_uhl.items():
                if len(sec_uhl) &gt; 0:
                    trs = twprge + str(sec_num).rjust(2, &#39;0&#39;)
                    ret_uhl[trs] = sec_uhl
                    # TODO: check if it&#39;s a &#39;default&#39; lot
                    #   (i.e. Sections 1-7 etc.)

        uhl_found = len(ret_uhl) &gt; 0
        if uhl_found and warn:
            txt = &#39;&#39;
            for trs, lots in ret_uhl.items():
                txt = f&#34;{txt}\n{trs}: {&#39;, &#39;.join(lots)}&#34;
            txt.strip()
            confirm = tk.messagebox.askyesno(
                &#39;Undefined Lots&#39;,
                &#39;One or more lots were identified in the parsed &#39;
                &#39;description(s) for which no definitions have been given:\n&#39;
                f&#34;{txt}\n\n&#34;
                &#39;These cannot be depicted on the plat until defined. &#39;
                &#39;Do so now?&#39;
            )

        if confirm and uhl_found:
            self.lot_definers = SeriesLotDefiner(
                self, top_owner=self.output_owner,
                target_lddb=self.output_owner.lddb, lots_to_define=ret_uhl)
            return None

        return (uhl_found, ret_uhl)

    def preview_btn_clicked(self):
        &#34;&#34;&#34;Generate the MultiPlat and display one of the plats from it. If
        the desired `index` is greater than the number of plats generated,
        will show the final one.&#34;&#34;&#34;
        mp = self.gen_plat()
        if mp is None:
            return

        if self.output_owner.warn_unhandled_lots:
            confirm = self._check_for_unhandled_lots(mp)
            if confirm is None:
                return

        if len(mp.plats) == 0:
            messagebox.showinfo(
                &#39;No plats&#39;,
                &#34;No plats to preview. Add land descriptions or manually add &#34;
                &#34;QQ&#39;s and try again.&#34;)
            return

        index = self.output_owner.preview_frame.preview_index
        if index &gt;= len(mp.plats):
            index = len(mp.plats) - 1

        # output() returns a list (in this case, only one page), so grab
        # the first (only) element from it.
        preview_img = mp.output(pages=index)[0]
        preview_window = FullPreviewWindow(
            self, img=preview_img, settings_name=self.settings_combo.get())

    def save_btn_clicked(self):
        &#34;&#34;&#34;Generate plats and save them to .png or .pdf at user-selected
        filepath.&#34;&#34;&#34;

        mp = self.gen_plat()
        if mp is None:
            return

        if self.output_owner.warn_unhandled_lots:
            confirm = self._check_for_unhandled_lots(mp)
            if confirm is None:
                return

        if len(mp.plats) == 0:
            messagebox.showinfo(
                &#39;No plats&#39;,
                &#34;No plats to save. Add land descriptions or manually add &#34;
                &#34;QQ&#39;s and try again.&#34;)
            return

        write_it = False
        multi_png = False
        start_dir = &#39;/&#39;
        ext = &#39;&#39;

        # Look at how many images are in the `previews` list to see how
        # many plats there will be.
        num_plats = len(self.output_owner.preview_frame.previews)

        while True:
            save_fp = filedialog.asksaveasfilename(
                initialdir=start_dir,
                filetypes=[(&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;PDF Files&#34;, &#34;*.pdf&#34;)],
                title=&#39;Save to PDF or PNG...&#39;
            )

            if save_fp == &#39;&#39;:
                break
            else:
                # If we need to re-prompt for filepath, we&#39;ll go back to the
                # same directory at least.
                start_dir = str(Path(save_fp).parent)
                stem = str(Path(save_fp).stem)

            if save_fp.lower().endswith(&#39;.pdf&#39;):
                write_it = True
                ext = &#39;.pdf&#39;
                break

            elif save_fp.lower().endswith(&#39;.png&#39;) and num_plats &gt; 1:

                # Generate the warning message, that `.png` will save multiple.
                msg_txt = (
                    &#39;Multiple plats have been generated. When saving to &#39;
                    &#39;.png specifically, each file will be saved separately, &#39;
                    &#39;as follows:\n&#39;
                )
                for i in range(num_plats):
                    msg_txt = f&#34;{msg_txt}\n{stem}_{str(i).rjust(3, &#39;0&#39;)}.png&#34;
                    if i == 3 and num_plats &gt; i:
                        msg_txt = msg_txt + &#39;\netc.&#39;
                        break
                msg_txt = msg_txt + &#39;\n\nIt will NOT prompt before overwriting files.&#39;
                msg_txt = msg_txt + &#39;\n\nContinue with saving?&#39;

                confirm = messagebox.askyesno(
                    &#39;Confirm saving to multiple files?&#39;, msg_txt)
                if confirm:
                    write_it = True
                    multi_png = True
                    ext = &#39;.png&#39;
                    break
                else:
                    continue

            elif save_fp.lower().endswith(&#39;.png&#39;):
                write_it = True
                ext = &#39;.png&#39;
                break

            else:
                messagebox.showerror(
                    &#39;.png and .pdf Files Only&#39;,
                    &#39;May only save to \&#39;.pdf\&#39; or \&#39;.png\&#39; files.&#39;)

        if not write_it:
            # If the user hasn&#39;t confirmed a good filepath,
            return

        if ext == &#39;.png&#39;:
            mp.output_to_png(save_fp)
        else:
            mp.output_to_pdf(save_fp)

        open_confirm = tk.messagebox.askyesno(
            &#39;Success!&#39;, &#39;Plat saved. Open file now?&#39;)

        if not open_confirm:
            return

        import os
        if not multi_png:
            os.startfile(save_fp)
            return

        # If we saved more than one .png, cut the ext off the fp, add the
        # numeral for the first file, and re-add the ext
        first_png = save_fp[:-4] + &#39;_000.png&#39;
        os.startfile(first_png)


########################################################################
# About and Disclaimer Buttons
########################################################################

class About(tk.Frame):
    &#34;&#34;&#34;A frame containing the &#39;About&#39; button, and corresponding
    functionality.&#34;&#34;&#34;

    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.master = master

        # Button to display &#39;about&#39; info
        about_button = tk.Button(
            self, text=&#39;About&#39;, height=1, width=6,
            command=self.about_btn_clicked)
        about_button.grid(row=1, column=1, padx=4, sticky=&#39;w&#39;)

        # Button to display pyTRS disclaimer
        disclaimer_button = tk.Button(
            self, text=&#39;pyTRS disclaimer&#39;, height=1,
            command=self.disclaimer_btn_clicked)
        disclaimer_button.grid(row=1, column=2, ipadx=2, padx=4, sticky=&#39;e&#39;)

    def about_btn_clicked(self):
        splash_info = (
            f&#34;pyTRSplat {version()}\n&#34;
            &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
            &#34;A program for generating plats from PLSS land descriptions (often &#34;
            &#34;called &#39;legal descriptions&#39;).\n\n&#34;

            f&#34;Built on pyTRS {pyTRS_version()}.\n&#34;
            &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
            &#34;A program for parsing PLSS land descriptions into their component &#34;
            &#34;parts.\n\n&#34;

            f&#34;Contact: &lt;{_constants.__email__}&gt;&#34;

        )
        messagebox.showinfo(&#39;pyTRSplat - About&#39;, splash_info)

    def disclaimer_btn_clicked(self):
        &#34;&#34;&#34;Display the disclaimer text from the pyTRS module.&#34;&#34;&#34;
        messagebox.showinfo(&#39;pyTRS disclaimer&#39;, pyTRS_constants.__disclaimer__)


########################################################################
# Preview Full Image Display Window
########################################################################

class FullPreviewWindow(tk.Toplevel):
    &#34;&#34;&#34;A popup window containing a full-size preview of the requested
    plat page.&#34;&#34;&#34;

    def __init__(self, master=None, img=None, settings_name=None):
        tk.Toplevel.__init__(self, master=master)
        self.master = master
        if settings_name is None:
            settings_name = &#39;&#39;
        else:
            settings_name = f&#39;   [settings: {settings_name}]&#39;
        self.title(f&#34;pyTRSplat - Page Preview{settings_name}&#34;)

        if img is None:
            self.destroy()
        else:
            display_window = ScrollResizeDisplay(self, img=img)
            display_window.grid(row=1, column=1, sticky=&#39;n&#39;)


########################################################################
# Generic table rows (used for a couple different subclasses)
########################################################################

class TableRow(tk.Frame):
    &#34;&#34;&#34;
    A generic row in a table.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, column_data=None, col_widths=None,
            col_wraps=None, is_header=False, first_tk_col=0):
        &#34;&#34;&#34;
        :param column_data: A list of strings to write in the columns.
        The number of elements in the list will dictate how many
        columns are created.
        :param col_widths: A list of integers, each representing the
        width for that column. (List must have the same number of
        elements as `column_data`.)
        :param col_wraps: A list of integers, each representing the
        textwrap for that column, in Tkinter &#39;text units&#39;.
        (List must have the same number of elements as `column_data`.)
        :param is_header: Whether this row contains headers. (Defaults
        to False.)
        :param first_tk_col: The first tkinter grid column in which to
        place the table (probably only used for TableRow subclasses).
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        self.master = master
        if column_data is None:
            column_data = []
        if col_widths is None:
            col_widths = [None for _ in column_data]
        if col_wraps is None:
            col_wraps = [None for _ in column_data]

        anchor = &#39;nw&#39;
        if is_header:
            anchor = &#39;n&#39;

        for i in range(len(column_data)):
            txt = column_data[i]
            width = col_widths[i]
            wrap = col_wraps[i]
            frm = tk.Frame(
                master=self, highlightbackground=&#39;black&#39;, highlightthickness=1)
            frm.grid(row=0, column=first_tk_col + i, sticky=&#39;ns&#39;)
            lbl = tk.Label(
                master=frm, text=txt, anchor=anchor, width=width,
                wraplength=wrap, justify=&#39;left&#39;)
            lbl.grid(sticky=&#39;nw&#39;)


########################################################################
# Description Editor Window / Subframes
########################################################################

class DescriptionEditor(tk.Toplevel):
    &#34;&#34;&#34;
    A widget for viewing, editing, reconfiguring, and reparsing PLSSDesc
    objects that are currently in the MultiPlatQueue.

    NOTE: At init, specify `plssdesc_list_owner=&lt;object&gt;` (e.g., a root
    Tk() object), if that&#39;s where the list of updated/saved PLSSDesc
    objects should be stored to (defaults to same as `master`, but may
    need to be a higher-level master).
    &#34;&#34;&#34;

    SDE_ROW = 1
    SDE_COL = 1

    def __init__(self, master=None, plssdesc_list=None,
                 plssdesc_list_owner=None, **kw):
        tk.Toplevel.__init__(self, master, **kw)
        self.master = master
        if plssdesc_list_owner is None:
            plssdesc_list_owner = master
        self.plssdesc_list_owner = plssdesc_list_owner
        if not hasattr(self.plssdesc_list_owner, &#39;plssdesc_list&#39;):
            self.plssdesc_list_owner.plssdesc_list = []
        if plssdesc_list is None:
            plssdesc_list = []

        self.plssdesc_list = plssdesc_list

        self.more_info = False

        # The index of the currently displayed SDE
        self.displayed_sde_index = None

        # A list of SingleDescriptionEditor objects (a tk.Frame subclass),
        # one for each PLSSDesc object in `self.plssdesc_list`
        self.editors = self.populate_editors()

        ##############################
        # Control Frame / Buttons
        ##############################
        control_frame = tk.Frame(self)
        control_frame.grid(row=0, column=1, sticky=&#39;nesw&#39;)

        self.header_lbl = tk.Label(control_frame, text=&#39;&#39;)
        self.header_lbl.grid(row=0, column=1)

        # Subframe for left/right scrol
        scroll_frame = tk.Frame(control_frame)
        scroll_frame.grid(row=1, column=1)

        # Button to scroll preview right
        scroll_right_button = tk.Button(
            scroll_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_sde)
        scroll_right_button.grid(
            row=1, column=2, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button to scroll preview left
        scroll_left_button = tk.Button(
            scroll_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_sde(-1))
        scroll_left_button.grid(
            row=1, column=1, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button for toggling more/less info to be displayed
        if self.more_info:
            more_info_btn_txt = &#39;Show less info&#39;
        else:
            more_info_btn_txt = &#39;Show more info&#39;
        self.more_info_btn = tk.Button(
            control_frame, text=more_info_btn_txt, width=14,
            command=self.toggle_more_info)
        self.more_info_btn.grid(row=2, column=1, padx=8, pady=5, sticky=&#39;n&#39;)

        ##############
        # Subframe for the &#39;big&#39; choices -- Restore / Apply / Delete
        ##############
        bc_padx = 16
        bc_ipadx = 4

        big_choices_frame = tk.Frame(control_frame)
        big_choices_frame.grid(row=1, column=2, padx=15, sticky=&#39;n&#39;)

        # Button to restore all descriptions (and SDE&#39;s) to their original
        # state, as of when this window was opened.
        restore_button = tk.Button(
            big_choices_frame, text=&#39;Restore All&#39;, height=2, padx=bc_ipadx,
            command=self.restore_clicked)
        restore_button.grid(row=1, column=3, padx=bc_padx, sticky=&#39;n&#39;)

        # Button to export saved results back to `master.plssdesc_list`
        # and optionally close this popup window
        export_button = tk.Button(
            big_choices_frame, text=&#39;Apply Changes to Plat&#39;,
            height=2, padx=bc_ipadx, command=self.export_to_master)
        export_button.grid(row=1, column=4, padx=bc_padx, sticky=&#39;n&#39;)

        # Button to delete current description
        delete_button = tk.Button(
            big_choices_frame, text=&#39;Delete This Description&#39;, height=2,
            padx=bc_ipadx, command=self.delete_desc_clicked)
        delete_button.grid(row=1, column=5, padx=bc_padx, sticky=&#39;n&#39;)

        ##############################
        # Currently Displayed SingleDescriptionEditor frame
        ##############################

        self.displayed_sde = None
        if len(self.editors) &gt; 0:
            self.displayed_sde_index = 0
            self.update_displayed_editor(0)
        self.update_header()

    def populate_editors(self):
        &#34;&#34;&#34;Populate a separate SingleDescriptionEditor object for each
        PLSSDesc object in `self.plssdesc_list`. Return the resulting
        list of SDE objects.&#34;&#34;&#34;
        editors = []
        for obj in self.plssdesc_list:
            sde = SingleDescriptionEditor(
                self, plssdesc_obj=obj, more_info=self.more_info)
            editors.append(sde)
        return editors

    def update_displayed_editor(self, index=None):
        &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
        `index`.&#34;&#34;&#34;
        if index is None:
            index = self.displayed_sde_index

        if index is None:
            # If still None, don&#39;t do anything else.
            return

        if self.displayed_sde is not None:
            # If we&#39;ve already displayed an sde, remove it from the grid now
            self.displayed_sde.grid_remove()

        # Set the new displayed_sde, and place it on the grid.
        self.displayed_sde = self.editors[index]
        self.displayed_sde.grid(
            row=DescriptionEditor.SDE_ROW,
            column=DescriptionEditor.SDE_COL,
            sticky=&#39;nwse&#39;)

    def scroll_sde(self, direction=1):
        &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        if self.displayed_sde_index is not None:
            self.displayed_sde_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        if len(self.editors) not in [None, 0]:
            self.displayed_sde_index %= len(self.editors)
        self.update_displayed_editor()
        self.update_header()

    def update_header(self):
        &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
        if self.displayed_sde_index is not None:
            header_txt = f&#34;{self.displayed_sde_index + 1} / {len(self.editors)}&#34;
        else:
            header_txt = &#34;[No descriptions to display.]&#34;
        self.header_lbl.config(text=header_txt)

    def toggle_more_info(self):
        &#34;&#34;&#34;Toggle whether `more_info` should be displayed, and enact the
        change for each SDE.&#34;&#34;&#34;
        self.more_info = not self.more_info

        for sde in self.editors:
            sde.set_more_info(self.more_info)
            sde.display_new_flags()
            sde.display_new_tracts()

        if self.more_info:
            text = &#39;Show less info&#39;
        else:
            text = &#39;Show more info&#39;
        self.more_info_btn.config(text=text)

    def collect_plssdesc_objects(self):
        &#34;&#34;&#34;Return a new list of the re-saved PLSSDesc objects.&#34;&#34;&#34;
        new_plssdesc_list = []
        for sde in self.editors:
            new_plssdesc_list.append(sde.cur_plssdesc_obj)
        return new_plssdesc_list

    def export_to_master(self):
        &#34;&#34;&#34;Collect the updated PLSSDesc objects in a new list, and set it
        to the plssdesc_list_owner&#39;s `.plssdesc_list`. Update the plat
        previews. And close this window.&#34;&#34;&#34;
        self.plssdesc_list_owner.plssdesc_list = self.collect_plssdesc_objects()
        try:
            self.plssdesc_list_owner.trigger_update_preview()
        except:
            pass

        self.destroy()

    def delete_desc_clicked(self):
        &#34;&#34;&#34;&#39;Delete&#39; the currently displayed SDE object. (In actuality,
        the SDE object will simply be removed from the `self.editors`
        list. As a result, the PLSSDesc object contained in said SDE
        will not be included when exporting back to owner -- but if this
        window is closed without exporting, this deletion will not have
        had any effect.)&#34;&#34;&#34;
        # Current index
        ind = self.displayed_sde_index

        if ind is None:
            return

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Delete&#39;, &#39;Delete this description?&#39;)
        self.focus()
        self.grab_set()

        if not confirm:
            return

        # Remove this SDE from the grid
        self.editors[ind].grid_remove()

        # Remove the SDE from the list of `editors`
        self.editors.pop(ind)

        # Set the index appropriately; and update the display, if there
        # are any left.
        if len(self.editors) == 0:
            self.displayed_sde_index = None
        else:
            self.displayed_sde_index %= len(self.editors)
            self.update_displayed_editor()

        # And update the header.
        self.update_header()

    def restore_clicked(self):
        &#34;&#34;&#34;Restore all PLSSDesc objects to how they were when this
        window was initialized (including un-deleting any).&#34;&#34;&#34;

        if len(self.plssdesc_list) == 0:
            return

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Restore&#39;,
            &#39;Discard all changes (including deletions) that have not &#39;
            &#39;yet been applied to the plat?&#39;)
        self.focus()
        self.grab_set()

        if not confirm:
            return

        for sde in self.editors:
            sde.destroy()

        self.editors = self.populate_editors()
        self.displayed_sde = None
        self.displayed_sde_index = None
        if len(self.editors) &gt; 0:
            self.displayed_sde_index = 0
        self.update_displayed_editor()

        self.update_header()


class SingleDescriptionEditor(tk.Frame):
    &#34;&#34;&#34;A subframe for viewing, editing, reconfiguring, and reparsing a
    single pyTRS.PLSSDesc object.&#34;&#34;&#34;

    # Display colors of text, depending on whether it&#39;s original data,
    # edited data that has not yet been activated, or edited data that
    # has been activated but not yet saved
    SAVED_COLOR = &#39;black&#39;
    EDIT_UNACTIVATED_COLOR = &#39;red&#39;
    EDIT_UNSAVED_COLOR = &#39;blue&#39;

    def __init__(
            self, master=None, plssdesc_obj=None, more_info=False,
            display_more_info_btn=False, **kw):
        tk.Frame.__init__(self, master, **kw)
        if plssdesc_obj is None:
            plssdesc_obj = pyTRS.PLSSDesc(&#39;&#39;)
        self.cur_plssdesc_obj = plssdesc_obj
        self._orig_plssdesc_obj = plssdesc_obj

        # Tracking the PLSSDesc object from which we&#39;re currently viewing
        # tracts and flags, and whether the displayed data has been &#39;saved&#39;
        self.current_display_tract_source = plssdesc_obj
        self.current_display_flag_source = plssdesc_obj
        self.current_display_tract_status = &#39;parsed&#39;
        self.current_display_flag_status = &#39;parsed&#39;

        # Tracking whether this Editor object has created a new PLSSDesc
        # object (may also be reset to False by the &#39;Restore&#39; button)
        self.created_new_plssdesc = False

        # The first &#39;original description&#39; (`.origDesc`) that had been
        # stored in the PLSSDesc object as of init. (`.origDesc` may
        # change after this point, but this will not.)
        self._first_orig_desc = plssdesc_obj.origDesc
        # The new description that we&#39;ll use, if we end up replacing
        # our original PLSSDesc object.
        self.new_desc_text = self._first_orig_desc
        self.current_display_desc_status = &#39;parsed&#39;

        # The pyTRS Config text (decompiled from our PLSSDesc obj&#39;s
        # `.config` attrib) that was last used to parse the text. Hold
        # onto it to use in case the user hits the &#39;CANCEL&#39; button in
        # the config_popup.
        cf = plssdesc_obj.config  # currently a pyTRS.Config obj
        if not plssdesc_obj.layout_specified:
            # If the layout was NOT specified in `config` param when the
            # PLSSDesc obj was parsed (i.e. layout was deduced), we want
            # to deduce the layout for our replacement PLSSDesc object
            # too, rather than use the layout that this PLSSDesc ended
            # up with
            cf.layout = None
        first_config = cf.decompile_to_text()
        self._last_used_config = first_config

        # The new config parameters that we&#39;ll use, if we end up
        # replacing our original PLSSDesc object. (Can be changed by
        # clicking &#39;Reconfigure&#39; button.)
        self.config_text = tk.StringVar()
        self.config_text.set(self._last_used_config)

        # Frame holding controls and orig description
        control_orig_desc_frame = tk.Frame(self)
        control_orig_desc_frame.grid(row=0, column=0, pady=5, sticky=&#39;nws&#39;)

        #####################################
        # Edit / Reconfig / Reparse Controls
        #####################################

        # Whether the user wants to see more info on parsed data
        # (e.g., lots/QQ&#39;s, warning/error flags)
        self.more_info = more_info

        control_frame = tk.Frame(control_orig_desc_frame)
        control_frame.grid(row=0, column=0, sticky=&#39;nw&#39;)

        # Keeping track of the config_popup and/or new_desc_pop_up we&#39;ve
        # lauched from this editor, if any
        self.config_popup_tk = None
        self.new_desc_pop_up_tk = None

        btn_padx = 4

        reconfig_btn = tk.Button(
            control_frame, text=&#39;Reconfigure&#39;, height=2, padx=2,
            command=self.reconfig_btn_clicked)
        reconfig_btn.grid(row=0, column=0, padx=btn_padx, sticky=&#39;n&#39;)

        edit_desc_btn = tk.Button(
            control_frame, text=&#39;Edit Text&#39;, height=2, padx=2,
            command=self.edit_desc_btn_clicked)
        edit_desc_btn.grid(row=0, column=1, padx=btn_padx, sticky=&#39;n&#39;)

        reparse_btn = tk.Button(
            control_frame, text=&#39;Reparse&#39;, height=2, padx=2,
            command=self.reparse)
        reparse_btn.grid(row=0, column=2, padx=btn_padx, sticky=&#39;n&#39;)

        restore_btn = tk.Button(
            control_frame, text=&#39;Restore&#39;, height=2, padx=2,
            command=self.restore)
        restore_btn.grid(row=0, column=3, padx=btn_padx, sticky=&#39;n&#39;)

        # We display more info (i.e. lots/QQs, warning/error flags) in
        # the tables, depending on `.more_info`. However, we only show
        # a `Show More/Less Info` button if `display_more_info_btn=True`
        # was specified at init. (Allows control from higher-level
        # widget, but also the option to create a SDE with this
        # functionality.)
        if self.more_info:
            more_info_btn_txt = &#39;Show less info&#39;
        else:
            more_info_btn_txt = &#39;Show more info&#39;
        self.more_info_btn = tk.Button(
            control_frame, text=more_info_btn_txt, height=2, width=14,
            command=self.toggle_more_info)
        self.display_more_info_btn = display_more_info_btn
        if display_more_info_btn:
            self.more_info_btn.grid(row=0, column=4, padx=btn_padx, sticky=&#39;n&#39;)

        #####################################
        # Display
        #####################################

        # Displaying the original description.
        self.orig_desc_frame = tk.Frame(control_orig_desc_frame)
        self.orig_desc_frame.grid(row=2, column=0, padx=btn_padx, sticky=&#39;nswe&#39;)

        self.orig_desc_lbl_width = 40
        self.orig_desc_lbl_wraplength = 240

        # Orig Descrip
        self.orig_desc_lbl = tk.Label(self.orig_desc_frame, anchor=&#39;nw&#39;)
        self.orig_desc_lbl.config(
            fg=SingleDescriptionEditor.SAVED_COLOR,
            text=self._first_orig_desc,
            width=self.orig_desc_lbl_width,
            wraplength=self.orig_desc_lbl_wraplength,
            justify=&#39;left&#39;)
        self.orig_desc_lbl.grid(row=0, column=0, sticky=&#39;nw&#39;)

        self.pytrs_display_frame = tk.Frame(self)
        self.pytrs_display_frame.grid(row=0, column=3, sticky=&#39;n&#39;)

        # Variables to configure how/where the TractTable and FlagTable
        # should be placed in the grid.
        self.tract_table_row_col = (1, 1)
        self.tract_table_padx_pady = (5, 5)
        self.flag_table_row_col = (3, 1)
        self.flag_table_padx_pady = (5, 10)

        # The parsed tracts are displayed in `.tract_table` (set to None
        # here, but initialized as a TractTable obj in `.display_new_tracts`)
        self.tract_table = None
        self.display_new_tracts(
            source_plssdesc=self.cur_plssdesc_obj, status=&#39;saved&#39;)

        # Warning and Error Flags are displayed in `.flag_table` (set to
        # None here, but initialized as a FlagTable obj in `.display_new_flags`)
        self.flag_table = None
        self.display_new_flags(
            source_plssdesc=self.cur_plssdesc_obj, status=&#39;saved&#39;)

    def toggle_more_info(self):
        &#34;&#34;&#34;Toggle whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
        self.more_info = not self.more_info
        self.set_more_info()

    def set_more_info(self, set_to=None):
        &#34;&#34;&#34;Set whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
        if set_to is None:
            set_to = self.more_info
        self.more_info = set_to
        self.display_new_flags()
        self.display_new_tracts()
        if self.more_info:
            text=&#39;Show less info&#39;
        else:
            text=&#39;Show more info&#39;
        self.more_info_btn.config(text=text)

    def edit_desc_btn_clicked(self):
        &#34;&#34;&#34;Prompt the user to make edits to the original description.&#34;&#34;&#34;
        if self.new_desc_pop_up_tk is not None:
            self.new_desc_pop_up_tk.destroy()
        self.new_desc_pop_up_tk = DescTextEditWindow(
            master=self, orig_text=self.new_desc_text)
        self.new_desc_pop_up_tk.focus()
        self.new_desc_pop_up_tk.grab_set()

    def display_new_descrip(self, status=&#39;not_activated&#39;):
        &#34;&#34;&#34;Update the displayed description for the PLSSDesc object
        (pulled from `self.new_desc_text`). If the text has been edited
        but not enacted, set the color to red. If it has been enacted,
        but not yet saved, set to blue. If saved, set to black.&#34;&#34;&#34;
        if status == &#39;not_activated&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR
        elif status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        self.orig_desc_lbl.config(fg=text_color, text=self.new_desc_text)
        self.current_display_desc_status = status

    def display_new_flags(self, source_plssdesc=None, status=None):

        # If status not specified, get it from `self`. Also update `self`
        # on the status.
        if status is None:
            status = self.current_display_flag_status
        self.current_display_flag_status = status

        if status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        if source_plssdesc is None:
            source_plssdesc = self.current_display_flag_source

        # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
        # tracts from
        self.current_display_flag_source = source_plssdesc

        # Destroy the old flag_table, and replace it with a new one
        if self.flag_table is not None:
            self.flag_table.destroy()
        self.flag_table = FlagTable(
            self.pytrs_display_frame, wflag_list=source_plssdesc.wFlagList,
            eflag_list=source_plssdesc.eFlagList, more_info=self.more_info)
        if self.more_info:
            # Only if `.more_info==True` do we place this on the grid.
            self.flag_table.grid(
                row=self.flag_table_row_col[0],
                column=self.flag_table_row_col[1],
                padx=self.flag_table_padx_pady[0],
                pady=self.flag_table_padx_pady[1], sticky=&#39;nws&#39;)

    def display_new_tracts(self, source_plssdesc=None, status=None):
        &#34;&#34;&#34;Display the data for the parsed pyTRS.Tract in the specified
        `source_plssdesc`.&#34;&#34;&#34;
        # If status not specified, get it from `self`. Also update `self`
        # on the status.
        if status is None:
            status = self.current_display_tract_status
        self.current_display_tract_status = status

        if status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        if source_plssdesc is None:
            # Default to pulling the replacement.
            source_plssdesc = self.current_display_tract_source

        # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
        # tracts from
        self.current_display_tract_source = source_plssdesc

        # Destroy the old tract_table, and replace it with a new one,
        # using as the tract_list the `.parsedTracts` from the chosen
        # source PLSSDesc object.
        if self.tract_table is not None:
            self.tract_table.destroy()
        self.tract_table = TractTable(
            self.pytrs_display_frame,
            tract_list=source_plssdesc.parsedTracts, more_info=self.more_info)
        self.tract_table.grid(
            row=self.tract_table_row_col[0],
            column=self.tract_table_row_col[1],
            padx=self.tract_table_padx_pady[0],
            pady=self.tract_table_padx_pady[1], sticky=&#39;nw&#39;)

    def reparse(self):
        &#34;&#34;&#34;
        Reparse the pyTRS.PLSSDesc object at the specified index in
        `self.plssdesc_list`, using the optionally re-specified `config`
        parameters. (If `config` has not been specified, will use
        whatever was already in the PLSSDesc object.)

        Note: This will create a new PLSSDesc object and set it to
        `self.cur_plssdesc_obj`. Beware lists that contain the original
        PLSSDesc object, as those will NOT be automatically updated with
        this new object.
        &#34;&#34;&#34;

        # Close any subordinate popups.
        try:
            self.config_popup_tk.destroy()
        except:
            pass
        try:
            self.new_desc_pop_up_tk.destroy()
        except:
            pass

        config = self.config_text.get()
        if config == &#39;CANCEL&#39;:
            # If the user hit the cancel button in the config popup, use
            # the original config
            config = self._last_used_config
        desc = self.new_desc_text
        d_obj = pyTRS.PLSSDesc(desc, config=config, initParseQQ=True)
        # Set the main PLSSDesc obj to the new replacement.
        self.cur_plssdesc_obj = d_obj
        # Update our last-used config text (again stripping out layout,
        # if it was deduced, rather than dictated by user)
        cf = d_obj.config  # currently a pyTRS.Config obj
        if not d_obj.layout_specified:
            cf.layout = None
        self._last_used_config = cf.decompile_to_text()

        # Update our displays.
        self.display_new_descrip(status=&#39;parsed&#39;)
        self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        # And keep track of the fact that we&#39;ve created a new PLSSDesc obj.
        self.created_new_plssdesc = True

    def restore(self):
        &#34;&#34;&#34;
        Restore the original pyTRS.PLSSDesc object, as it existed at the
        creation of this editor instance.
        &#34;&#34;&#34;

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Restore&#39;,
            &#39;Discard all changes made to this description since opening &#39;
            &#39;this editor window?&#39;)
        if not confirm:
            return

        # TODO: Prompt &#34;Are You Sure&#34;

        # Close any subordinate popups.
        try:
            self.config_popup_tk.destroy()
            self.config_popup_tk = None
        except:
            pass
        try:
            self.new_desc_pop_up_tk.destroy()
            self.new_desc_pop_up_tk = None
        except:
            pass

        d_obj = self._orig_plssdesc_obj
        self.cur_plssdesc_obj = d_obj
        self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.created_new_plssdesc = False
        self.new_desc_text = self.cur_plssdesc_obj.origDesc
        self.display_new_descrip(status=&#39;parsed&#39;)

    def reconfig_btn_clicked(self):
        &#34;&#34;&#34;
        Re-Config button was clicked; launch popup window to get Config
        parameters from user (results are stored in StringVar
        `self.config_text`).
        &#34;&#34;&#34;
        try:
            # Kill the previously opened config popup, if any.
            self.config_popup_tk.destroy()
        except:
            pass

        # Open a config popup, and store it to attrib.
        self.config_popup_tk = tk.Toplevel()
        self.config_popup_tk.focus()
        self.config_popup_tk.grab_set()
        self.config_popup_tk.title(&#39;Change pyTRS Config Parameters&#39;)
        after_prompt = (
            &#39;NOTE: &#39;
            &#39;The config parameters that have just been set will ONLY &#39;
            &#39;affect THIS description. You MUST hit \&#39;Reparse\&#39; &#39;
            &#39;for these config parameters to have any effect.&#39;)
        pc = pyTRS.interface_tools.PromptConfig(
            master=self.config_popup_tk, target_config_var=self.config_text,
            parameters=[
                &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
            ],
            show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
            exit_after_ok=True)
        pc.pack(padx=20, pady=10)


class DescTextEditWindow(tk.Toplevel):
    &#34;&#34;&#34;A pop-up window in which the user may make edits to the text of a
    pyTRS.PLSSDesc object.&#34;&#34;&#34;

    def __init__(self, master=None, orig_text=None, **kw):
        tk.Toplevel.__init__(self, master, **kw)
        self.master = master

        self.orig_text = orig_text

        desc_box_header = tk.Label(
            self, text=&#39;Replace existing land description with:&#39;)
        desc_box_header.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.desc_box_entry = tk.Text(self, width=64, height=16)
        self.desc_box_entry.grid(row=2, column=1, padx=4, pady=4)

        # Fill with the text box with the existing text.
        if orig_text is not None:
            self.desc_box_entry.insert(tk.END, orig_text)

        control_frame = tk.Frame(self)
        control_frame.grid(row=3, column=1)
        ok_button = tk.Button(
            control_frame, text=&#39;Confirm&#39;, width=12,
            command=self.ok_btn_clicked)
        ok_button.grid(row=1, column=2, padx=16, pady=10, sticky=&#39;n&#39;)

        cancel_button = tk.Button(
            control_frame, text=&#39;Cancel&#39;, width=12,
            command=self.cancel_btn_clicked)
        cancel_button.grid(row=1, column=1, padx=16, pady=10, sticky=&#39;n&#39;)

    def ok_btn_clicked(self):
        # Set the new description.
        self.master.new_desc_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)
        # Display it.
        self.master.display_new_descrip(status=&#39;not_activated&#39;)
        # Destroy this text pop_up.
        self.master.new_desc_pop_up_tk = None
        self.destroy()

    def cancel_btn_clicked(self):
        if self.orig_text != self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;):
            # If there were changes made to the text, confirm with user
            # that they should be discarded before destroying the window
            confirm = messagebox.askyesno(
                &#39;Discard changes?&#39;,
                &#34;Discard any changes you&#39;ve made to this text?&#34;)
            self.focus()
            self.grab_set()

            if confirm:
                self.destroy()
        else:
            self.destroy()


class TractTable(tk.Frame):
    &#34;&#34;&#34;
    A frame containing a table of parsed data from a list of
    pyTRS.Tract objects.
    &#34;&#34;&#34;

    trs_col_width = 10
    trs_wraplength = 240

    desc_col_width = 30
    desc_wraplength = 200

    lotqq_col_width = 30
    lotqq_wraplength = 200

    def __init__(
            self, master=None, tract_list=None, more_info=False, **kw):
        &#34;&#34;&#34;
        :param tract_list: A list of pyTRS.Tract objects to display.
        :param more_info: Whether the user wants to display &#39;more info&#39;.
        In this case, the `.lotQQList` attribute of each pyTRS.Tract
        object is considered &#39;more info&#39;.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master
        if tract_list is None:
            tract_list = []
        self.tract_list = tract_list

        self.col_widths = [self.trs_col_width, self.desc_col_width]
        self.col_wraps = [self.trs_wraplength, self.desc_wraplength]

        if more_info:
            self.col_widths.append(self.lotqq_col_width)
            self.col_wraps.append(self.lotqq_wraplength)

        i = 0

        headers = [&#39;TRS&#39;, &#39;Description&#39;]
        if more_info:
            headers = [&#39;TRS&#39;, &#39;Description&#39;, &#39;Identified Lots / QQs&#39;]
        tr = TableRow(
            self, column_data=headers, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
        i += 1

        rows = []

        for tract_obj in tract_list:
            new_row = [tract_obj.trs, tract_obj.desc]
            if more_info:
                new_row.append(&#39;, &#39;.join(tract_obj.lotQQList))
            rows.append(new_row)

        for row in rows:
            tr = TableRow(
                self, column_data=row, col_widths=self.col_widths,
                col_wraps=self.col_wraps)
            tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
            i += 1


class FlagTable(tk.Frame):
    &#34;&#34;&#34;A frame containing a table of warning/error flags from a parsed
    pyTRS.PLSSDesc object.&#34;&#34;&#34;

    flag_col_width = 35
    flag_wraplength = 240

    col_widths = [flag_col_width, flag_col_width]
    col_wraps = [flag_wraplength, flag_wraplength]

    def __init__(
            self, master=None, wflag_list=None, eflag_list=None,
            more_info=False, **kw):
        &#34;&#34;&#34;
        :param more_info: Whether the user wants to display &#39;more info&#39;.
        In this case, all flag data is considered &#39;more info&#39;.
        :param wflag_list: The `.wFlagList` attribute from a
        pyTRS.PLSSDesc object to display.
        :param eflag_list: The `.eFlagList` attribute from a
        pyTRS.PLSSDesc object to display.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master

        if not more_info:
            return

        if wflag_list is None:
            wflag_list = [&#39;None&#39;]
        elif len(wflag_list) == 0:
            wflag_list = [&#39;None&#39;]

        if eflag_list is None:
            eflag_list = [&#39;None&#39;]
        elif len(eflag_list) == 0:
            eflag_list = [&#39;None&#39;]

        headers = [&#39;Warning Flags&#39;, &#39;Error Flags&#39;]
        row_data = [&#39;, &#39;.join(wflag_list), &#39;, &#39;.join(eflag_list)]

        i = 0
        tr = TableRow(
            self, column_data=headers, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
        i += 1
        tr = TableRow(
            self, column_data=row_data, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)


########################################################################
# Plat Settings Editor
########################################################################

class CustomSettingsEditor(SettingsEditor):
    &#34;&#34;&#34;
    An editor for configuring plat settings, somewhat customized for
    this application.
    &#34;&#34;&#34;
    def __init__(self, master=None, output_frame=None, first_settings_obj=None,
            show_save_preset=True, show_load_preset=True,
            show_save_custom=False, show_load_custom=False):
        SettingsEditor.__init__(
            self, master, first_settings_obj=first_settings_obj, show_ok=True,
            show_save_preset=show_save_preset, show_load_preset=show_load_preset,
            show_save_custom=show_save_custom, show_load_custom=show_load_custom)
        self.master = master

        # Output frame is where the resulting data should be stored.
        self.output_frame = output_frame
        self.ok_button.config(text=&#39;Update Plat With These Settings&#39;)

    def ok_btn_clicked(self):
        &#34;&#34;&#34;
        Compile the Settings object and pass it to the main window.
        &#34;&#34;&#34;
        set_obj = self.editor.compile_settings()
        if set_obj is False:
            return
        output_frame = self.output_frame
        output_frame.current_custom_settings = set_obj

        # Update the displayed presets in the output frame
        output_frame.avail_settings = Settings.list_presets()
        output_frame.avail_settings.append(&#39;&lt;customized&gt;&#39;)
        output_frame.settings_combo[&#39;values&#39;] = output_frame.avail_settings
        output_frame.settings_combo.current(len(output_frame.avail_settings) - 1)

        # Destroy the toplevel containing this frame.
        self.master.destroy()


########################################################################
# On-The-Fly Lot Definitions
########################################################################

class SectionFiller(tk.Frame):
    &#34;&#34;&#34;
    A frame with 4x4 button grid for manually turning on/off QQ&#39;s.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, sec=0, twp=&#39;&#39;, rge=&#39;&#39;, trs=&#39;&#39;, ld=None,
            allow_ld_defaults=False, button_on_text=&#39;X&#39;):
        &#34;&#34;&#34;
        Specify EITHER `trs` OR `sec`, `twp`, and `rge`. If both sets
        are specified, will use `trs` only.

        :param ld: Same purpose as for pyTRSplat.grid.SectionGrid obj.
        :param allow_ld_defaults: Same purpose as for SectionGrid obj.
        :param button_on_text: Character that should be displayed inside
        a QQ button when it&#39;s clicked.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        self.master = master

        self.go_btn = tk.Button(self, text=&#39;Go&#39;, command=self.go_btn_clicked)
        self.go_btn.grid(row=0, column=1)

        if trs != &#39;&#39;:
            self.sec_grid = SectionGrid.from_trs(
                trs, ld=ld, allow_ld_defaults=allow_ld_defaults)
        else:
            self.sec_grid = SectionGrid(
                sec, twp, rge, ld=ld, allow_ld_defaults=allow_ld_defaults)

        self.twprge = self.sec_grid.twprge
        self.sec = self.sec_grid.sec
        self.trs = self.sec_grid.trs

        grid_frame = tk.Frame(self)
        grid_frame.grid(row=3, column=1, sticky=&#39;n&#39;)
        self.buttons = []
        for k, v in self.sec_grid.QQgrid.items():
            btn = self._QQButton(
                grid_frame, qq=k, qq_dict=v, on_text=button_on_text)
            self.buttons.append(btn)

    def go_btn_clicked(self):
        &#34;&#34;&#34;
        Customizable method. Redefine this method depending on
        application. Gets called any time a QQ button gets clicked.
        &#34;&#34;&#34;
        pass

    def qq_btn_clicked(self, qq_name):
        &#34;&#34;&#34;
        Customizable method. Redefine this method depending on
        application. Gets called any time a QQ button gets clicked.

        :param qq_name: The name of the QQ button that was clicked
            (e.g., &#39;NENE&#39;)
        &#34;&#34;&#34;
        pass

    class _QQButton(tk.Button):
        &#34;&#34;&#34;
        A button for toggling a QQ.
        &#34;&#34;&#34;
        W = 2
        H = 1
        def __init__(self, master=None, qq=&#39;&#39;, qq_dict=None, on_text=&#39;X&#39;, **kw):
            tk.Button.__init__(self, master, **kw)
            self.master = master
            self.qq = qq
            self.on_text = on_text
            self.qq_dict = qq_dict
            self.grid(row=qq_dict[&#39;coord&#39;][1], column=qq_dict[&#39;coord&#39;][0])
            self.config(command=self.toggle, width=self.W, height=self.H)
            self.config(text=self.on_text * self.qq_dict[&#39;val&#39;])

        def toggle(self):
            self.qq_dict[&#39;val&#39;] = (self.qq_dict[&#39;val&#39;] + 1) % 2
            self.config(text=self.on_text * self.qq_dict[&#39;val&#39;])
            self.master.master.qq_btn_clicked(self.qq)


class SeriesLotDefiner(tk.Toplevel):
    def __init__(
            self, master=None, top_owner=None, target_lddb=None,
            lots_to_define=None):
        &#34;&#34;&#34;
        :param top_owner: The main application, which contains a
        .trigger_update_preview() method.
        :param target_lddb: A LotDefDB object that should be modified.
        :param lots_to_define: A dict, specifying which lots need to be
        defined, in this format:   &lt;trs key&gt; -&gt; &lt;list of lots&gt;
            ex: {&#39;154n97w01&#39;: [&#39;L1, &#39;L2&#39;], &#39;154n97w02&#39;: [&#39;L1&#39;, &#39;L3&#39;]}
        &#34;&#34;&#34;
        tk.Toplevel.__init__(self, master)
        # The LotDefDB object that will be updated:
        self.target_lddb = target_lddb

        if top_owner is None:
            top_owner = master
        self.top_owner = top_owner

        # All of the lots we need to define -- i.e. an `unhandled_lots`
        # dict (`ret_uhl`) from `OutputFrame._check_for_unhandled_lots()`
        self.lots_to_define = lots_to_define
        self.cur_definer = None
        self.trs_keys = list(lots_to_define.keys())
        self.cur_trs = None
        self.cur_lots = []

        self.next_one()

    def next_one(self):
        try:
            self.cur_definer.destroy()
        except:
            pass

        if len(self.cur_lots) == 0:
            if len(self.trs_keys) == 0:
                self.done()
                return None
            self.cur_trs = self.trs_keys.pop(0)
            self.cur_lots = self.lots_to_define[self.cur_trs]

        lot = self.cur_lots.pop(0)
        self.cur_definer = SingleLotDefiner(
            self, target_lddb=self.target_lddb, trs=self.cur_trs, lot_num=lot)
        self.cur_definer.cancel_btn.grid(row=7, column=1)
        self.cur_definer.grid(row=0, column=0, padx=14, pady=14, sticky=&#39;nesw&#39;)
        self.cur_definer.focus()
        self.cur_definer.grab_set()

    def done(self):
        # TODO: Maybe a success message?
        self.top_owner.trigger_update_preview()
        self.destroy()

    def canceled(self):
        # TODO: Maybe a confirm / abandon message?
        self.top_owner.trigger_update_preview()
        self.destroy()


class LotRedefiner(SeriesLotDefiner):
    &#34;&#34;&#34;
    A class for RE-defining lots already in a LotDefDB object.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, top_owner=None, target_lddb=None,
            trs=None, lot=0, uid=None):
        lots_to_define = {trs: [lot]}
        SeriesLotDefiner.__init__(
            self, master=master, top_owner=top_owner, target_lddb=target_lddb,
            lots_to_define=lots_to_define)

        # A bit hack-ish, but remove the &#34;Leave Undefined&#34; button.
        self.cur_definer.leaveit_btn.grid_forget()

        self.uid = uid

    def done(self):
        if hasattr(self.master, &#39;update_table&#39;):
            self.master.update_table(self.uid)
        self.destroy()

    def canceled(self):
        self.destroy()


class SingleLotDefiner(SectionFiller):
    &#34;&#34;&#34;
    A simple frame for defining lots on the fly.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, target_lddb=None, sec=0, twp=&#39;&#39;, rge=&#39;&#39;, trs=&#39;&#39;,
            lot_num=0):
        &#34;&#34;&#34;
        Specify EITHER `trs` OR `sec`, `twp`, and `rge`. If both sets
        are specified, will use `trs` only.

        :param target_lddb: The LotDefDB object to be updated.
        :param button_on_text: Character that should be displayed inside
        a QQ button when it&#39;s clicked.
        &#34;&#34;&#34;
        lot_num = _simplify_lot_number(lot_num)

        SectionFiller.__init__(
            self, master, sec=sec, twp=twp, rge=rge, trs=trs,
            button_on_text=lot_num)
        self.lot_num = lot_num

        if not isinstance(target_lddb, LotDefDB):
            raise ValueError(
                &#39;Existing LotDefDB object must be provided as `lddb`&#39;)
        self.target_lddb = target_lddb

        self.go_btn.config(text=&#39;Confirm Lot Definition&#39;)
        lbl = Label(self, text=f&#34;{self.trs}: Lot {lot_num}&#34;)
        lbl.grid(row=1, column=1)

        self.leaveit_btn = tk.Button(
            self, text=&#39;Leave Undefined&#39;, command=self.leaveit_btn_clicked)
        self.leaveit_btn.grid(row=5, column=1)

        self.cancel_btn = tk.Button(
            self, text=&#39;Cancel&#39;, command=self.cancel_btn_clicked)

    def go_btn_clicked(self):
        &#34;&#34;&#34;
        Set or update the definition of this lot in the target_lddb.
        &#34;&#34;&#34;

        filled = self.sec_grid.filled_qqs()
        if len(filled) == 0:
            confirm = tk.messagebox.askokcancel(
                &#39;Are you sure?&#39;, &#34;Leave this lot undefined?&#34;)

            if not confirm:
                return None

        definition = &#39;,&#39;.join(filled)

        tld = self.target_lddb.get_tld(self.twprge, force_tld_return=True)

        try:
            sec_num = int(self.sec)
        except:
            sec_num = 0
        ld = tld.get_ld(sec_num, force_ld_return=True)
        ld.set_lot(self.lot_num, definition)
        tld.set_section(sec_num, ld)
        self.target_lddb.set_twp(self.twprge, tld)

        if hasattr(self.master, &#39;next_one&#39;):
            self.master.next_one()

    def leaveit_btn_clicked(self):
        if hasattr(self.master, &#39;next_one&#39;):
            self.master.next_one()

    def cancel_btn_clicked(self):
        if hasattr(self.master, &#39;canceled&#39;):
            self.master.canceled()


class LotDefEditor(tk.Toplevel):
    &#34;&#34;&#34;
    A frame for viewing, editing, and deleting LotDefinitions.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, top_owner=None, target_lddb=None, lots=None):
        &#34;&#34;&#34;
        :param top_owner: The main application, which contains a
        .trigger_update_preview() method.
        :param target_lddb: A LotDefDB object that should be modified.
        :param lots: A dict, keyed by TRS (e.g., &#39;154n9701&#39;), and whose
        values are a list of lots that should be viewed. See example:
            sample_lots = {
                &#39;154n97w25&#39;: [&#39;L5&#39;, &#39;L8&#39;],
                &#39;154n97w01&#39;: [&#39;L1&#39;, &#39;L3&#39;],
                &#39;155n97w04&#39;: [&#39;L1&#39;, &#39;L2&#39;, &#39;L3&#39;, &#39;L4&#39;]
            }
        &#34;&#34;&#34;
        tk.Toplevel.__init__(self, master)
        self.master = master
        self.target_lddb = target_lddb
        self.lots = lots.copy()
        self.orig_lots = lots
        self.top_owner = top_owner

        # The current LotDefEditor (if any).
        self.lde = None

        control_frm = tk.Frame(self)
        control_frm.grid(row=0, column=0, sticky=&#39;ns&#39;)

        define_all_btn = tk.Button(
            control_frm, text=&#39;Define All Remaining Lots&#39;,
            command=self.define_all_lots)
        define_all_btn.grid(row=0, column=1, padx=4, pady=4, sticky=&#39;ns&#39;)

        display_entire_lddb_btn = tk.Button(
            control_frm, text=&#39;Display All (SLOW)&#39;,
            command=self.toggle_all_lddb)
        display_entire_lddb_btn.grid(
            row=0, column=2, padx=4, pady=4, sticky=&#39;ns&#39;)

        del_btn = tk.Button(
            control_frm, text=&#39;Delete All Lot Definitions&#39;,
            command=self.del_btn_clicked)
        del_btn.grid(row=0, column=3, padx=4, pady=4, sticky=&#39;ns&#39;)

        close_btn = tk.Button(
            control_frm, text=&#39;Close Editor&#39;, command=self.close_btn_clicked)
        close_btn.grid(row=0, column=4, padx=4, pady=4, sticky=&#39;ns&#39;)

        # Our LotDefTable object, which will be populated shortly.
        self.table = None

        # Where to place the table in the grid
        self.table_row = 1
        self.table_column = 0

        # Populate the table.
        self.gen_new_table()

    def toggle_all_lddb(self):
        &#34;&#34;&#34;
        Include the entirety of the LotDefDB in the table.
        &#34;&#34;&#34;
        confirm = tk.messagebox.askokcancel(
            &#39;WARNING&#39;,
            &#34;Viewing ALL lot definitions can be very slow if there are &#34;
            &#34;too many defined lots. It may be more efficient to view and edit &#34;
            &#34;numerous lot definitions externally in a .csv file, and then load &#34;
            &#34;that file here.\n\n&#34;
            &#34;Display all lots now?&#34;)

        self.focus()

        if not confirm:
            return None

        for twprge, tld in self.target_lddb.items():
            for sec, ld in tld.items():
                trs = f&#34;{twprge}{str(sec).rjust(2, &#39;0&#39;)}&#34;
                self.lots.setdefault(trs, [])
                lots = list(ld.keys())
                for lot in lots:
                    if lot not in self.lots[trs]:
                        self.lots[trs].append(lot)
        self.gen_new_table()

    def del_btn_clicked(self):
        &#34;&#34;&#34;
        Remove all items from the LotDefDB. (Does not actually destroy
        the dict values; just pops their keys from the dict.)
        &#34;&#34;&#34;
        confirm = tk.messagebox.askokcancel(
            &#39;Are you sure?&#39;, &#34;Delete ALL current lot definitions?&#34;)

        self.focus()

        if not confirm:
            return None

        for i in range(len(self.target_lddb.keys())):
            self.target_lddb.pop(list(self.target_lddb.keys())[0], None)

        self.lots = self.orig_lots.copy()

        self.gen_new_table()

        self.top_owner.trigger_update_preview()

    def close_btn_clicked(self):
        self.destroy()

    def gen_new_table(self):
        &#34;&#34;&#34;
        Generate a new LotDefTable for the lots.
        &#34;&#34;&#34;
        try:
            self.table.destroy()
        except:
            pass

        self.table = LotDefTable(
            self, top_owner=self.top_owner, lots=self.lots,
            target_lddb=self.target_lddb)
        self.table.grid(
            row=self.table_row, column=self.table_column, sticky=&#39;nesw&#39;,
            padx=5, pady=5)

    def define_all_lots(self):
        &#34;&#34;&#34;
        Define any lots that have not already been defined, one-by-one.
        &#34;&#34;&#34;

        def no_lots():
            messagebox.showinfo(
                &#39;No lots to define&#39;,
                &#34;All lots have been defined. Click the respective edit buttons &#34;
                &#34;to re-define lots.&#34;
            )

        try:
            self.lde.destroy()
        except:
            pass

        if self.table is None:
            no_lots()
            return

        ld_dict = self.table.ld_dict
        if ld_dict is None:
            no_lots()
            return

        # Extract unhandled lots from the ld_dict (generated in the
        # LotDefTable object)
        uhl = {}
        for k, v in ld_dict.items():
            if v[&#39;definition&#39;] != &#39;Undefined&#39;:
                continue
            trs = v[&#39;trs&#39;]
            lot = v[&#39;lot&#39;]
            uhl.setdefault(trs, [])
            uhl[trs].append(lot)

        if len(uhl) == 0:
            no_lots()
            return

        self.lde = LotDefEditor.TableSeriesDefiner(
            self, top_owner=self.top_owner, target_lddb=self.target_lddb,
            lots_to_define=uhl)

    class TableSeriesDefiner(SeriesLotDefiner):
        &#34;&#34;&#34;
        A SeriesLotDefiner with slightly modified behavior for cancel
        and after completion.
        &#34;&#34;&#34;

        def __init__(
                self, master=None, top_owner=None, target_lddb=None,
                lots_to_define=None):
            SeriesLotDefiner.__init__(
                self, master=master, top_owner=top_owner,
                target_lddb=target_lddb, lots_to_define=lots_to_define)

            # A bit hack-ish, but remove the &#34;Leave Undefined&#34; button.
            self.cur_definer.leaveit_btn.grid_forget()

            # These methods have the same functionality for this object.
            self.canceled = self.done

        def done(self):
            self.master.gen_new_table()
            try:
                self.top_owner.trigger_update_preview()
            except:
                pass
            self.destroy()


class LDTableRow(TableRow):
    &#34;&#34;&#34;
    A TableRow object with added &#34;Edit&#34; and &#34;Delete&#34; buttons, specific
    to the lot definition editor.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, control_owner=None, column_data=None,
            col_widths=None, col_wraps=None, is_header=False, uid=None):
        &#34;&#34;&#34;
        All parameters are the same as for TableRow, except:
        :param uid: The unique identifier for a lot (ex: &#39;154n97w01_L1&#39;)
        :param control_owner: The tkinter object that controls this obj,
        and which has `.edit_btn_clicked()` and `.del_btn_clicked()`
        methods.
        &#34;&#34;&#34;
        TableRow.__init__(
            self, master, column_data, col_widths, col_wraps, is_header,
            first_tk_col=2)
        self.uid = uid
        self.control_owner = control_owner

        if not is_header:
            ed_btn = tk.Button(
                self, text=&#39;Edit&#39;, width=5, command=self.edit_btn_clicked)
            del_btn = tk.Button(
                self, text=&#39;Delete&#39;, width=5, command=self.del_btn_clicked)
            ed_btn.grid(row=0, column=0, padx=4, sticky=&#39;ns&#39;)
            del_btn.grid(row=0, column=5, padx=4, sticky=&#39;ns&#39;)

    def edit_btn_clicked(self):
        self.control_owner.edit_btn_clicked(self.uid)

    def del_btn_clicked(self):
        self.control_owner.del_btn_clicked(self.uid)


class LotDefTable(tk.Frame):
    &#34;&#34;&#34;
    A frame containing a table of LotDefinitions and edit/delete
    buttons.
    &#34;&#34;&#34;

    trs_col_width = 12
    lot_name_col_width = 6
    ld_col_width = 35
    ld_wraplength = 240
    col_width = [trs_col_width, lot_name_col_width, ld_col_width]
    col_wrap = [None, None, ld_wraplength]
    max_rows_per_page = 15

    # The tk grid column in the LotDefTable frame holding TableRow objs
    tbrow_col = 2

    def __init__(
            self, master=None, top_owner=None, lots=None, target_lddb=None,
            **kw):
        &#34;&#34;&#34;
        :param lots: A dict, keyed by TRS (e.g., &#39;154n9701&#39;), and whose
        values are a list of lots that should be viewed. See example:
            sample_lots = {
                &#39;154n97w25&#39;: [&#39;L5&#39;, &#39;L8&#39;],
                &#39;154n97w01&#39;: [&#39;L1&#39;, &#39;L3&#39;],
                &#39;155n97w04&#39;: [&#39;L1&#39;, &#39;L2&#39;, &#39;L3&#39;, &#39;L4&#39;]
            }

        Note: This is the same structure as an &#39;unhandled lots&#39; dict
        generated by the `MultiPlat.all_unhandled_lots` property.
        :param target_lddb: The LotDefDB object whose definitions should
        be displayed.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master
        self.btn = tk.Button(text=&#39;Edit&#39;)

        if top_owner is None:
            top_owner = master
        self.top_owner = top_owner

        ###################3
        # Scroll frame

        control_frame = tk.Frame(self)
        control_frame.grid(row=0, column=1)

        # Subframe for left/right scrol
        scroll_frame = tk.Frame(control_frame)
        scroll_frame.grid(row=1, column=1)

        self.header_lbl = tk.Label(control_frame, text=&#39;&#39;)
        self.header_lbl.grid(row=0, column=1)

        # Button to scroll preview right
        scroll_right_button = tk.Button(
            scroll_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_page)
        scroll_right_button.grid(
            row=1, column=2, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button to scroll preview left
        scroll_left_button = tk.Button(
            scroll_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_page(-1))
        scroll_left_button.grid(
            row=1, column=1, padx=8, pady=2, sticky=&#39;n&#39;)

        ##################
        # Gen pages
        ##################

        # A dict of pages (i.e. Frames), one of which is displayed at a time;
        # keyed by incremented ints, starting at 0
        self.pages = {}
        # The index of the currently displayed page.
        self.page_index = None
        # The current page (Frame) itself.
        self.current_page = None

        self.display_frame = tk.Frame(self)
        self.display_frame.grid(row=2, column=1, sticky=&#39;nesw&#39;)

        # A dict for keeping track of each TableRow, which lot definitions
        # it corresponds to, where to find it in the tk grid, etc. Keyed
        # by unique ID in the format of TRS_lotnumber (ex: &#39;154n97w01_L1&#39;)
        self.ld_dict = {}

        # The current LotRefiner object (if any)
        self.current_redefiner = None

        # Width and wrap configs for the table display

        if lots is None:
            lots = {}

        if target_lddb is None:
            target_lddb = LotDefDB()

        self.target_lddb = target_lddb

        uid_list = []

        def gen_header(page_num: int):
            &#34;&#34;&#34;
            Generate a header for a new page.
            &#34;&#34;&#34;

            uid = f&#34;headers_{page_num}&#34;
            header_data = [&#39;Twp/Rge/Sec&#39;, &#39;Lot&#39;, &#39;Definition&#39;]
            self.ld_dict[uid] = {}
            self.ld_dict[uid][&#39;row_data&#39;] = header_data
            self.ld_dict[uid][&#39;row_num&#39;] = 0
            self.ld_dict[uid][&#39;definition&#39;] = &#39;na_headers&#39;
            self.ld_dict[uid][&#39;page&#39;] = page_num
            uid_list.append(uid)

        i = 0
        for trs, lot_list in lots.items():
            ld = self.target_lddb.trs(trs)
            for lot in lot_list:
                definition = &#39;Undefined&#39;
                if ld is not None:
                    definition = ld.get(lot, &#39;Undefined&#39;)
                # &#39;unique ID&#39; to serve as dict key -- i.e. &#39;154n97w01_L1&#39;
                uid = f&#34;{trs}_{lot}&#34;
                uid_list.append(uid)

                twp, rge, sec = pyTRS.break_trs(trs)
                try:
                    sec = int(sec)
                except ValueError:
                    sec = 0

                self.ld_dict[uid] = {}
                self.ld_dict[uid][&#39;ld&#39;] = ld
                self.ld_dict[uid][&#39;row_data&#39;] = [trs, lot, definition]
                self.ld_dict[uid][&#39;row_num&#39;] = i % LotDefTable.max_rows_per_page + 1
                self.ld_dict[uid][&#39;page&#39;] = i // LotDefTable.max_rows_per_page
                self.ld_dict[uid][&#39;twprge&#39;] = twp + rge
                self.ld_dict[uid][&#39;sec&#39;] = sec
                self.ld_dict[uid][&#39;trs&#39;] = trs
                self.ld_dict[uid][&#39;lot&#39;] = lot
                self.ld_dict[uid][&#39;definition&#39;] = definition
                i += 1

        # Subtract the last one for an accurate total.
        i -= 1

        for page_num in range(i//LotDefTable.max_rows_per_page + 1):
            gen_header(page_num)
            new_frame = tk.Frame(self.display_frame)
            self.pages[page_num] = new_frame

        start_row = 2
        for uid in uid_list:
            # Generate a LDTableRow for each
            table_row_num = self.ld_dict[uid][&#39;row_num&#39;]
            self.ld_dict[uid][&#39;grid_row&#39;] = table_row_num + start_row
            self.ld_dict[uid][&#39;grid_col&#39;] = self.tbrow_col
            self.gen_tablerow(uid)

        if len(self.pages) &gt; 0:
            self.page_index = 0
            self.update_displayed_page()

    def scroll_page(self, direction=1):
        &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        if self.page_index is not None:
            self.page_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        if len(self.pages) not in [None, 0]:
            self.page_index %= len(self.pages)
        self.update_displayed_page()

    def update_displayed_page(self, page_index=None):
        &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
        `index`.&#34;&#34;&#34;
        if page_index is None:
            page_index = self.page_index

        if page_index is None:
            # If still None, don&#39;t do anything else.
            return

        if self.current_page is not None:
            # If we&#39;ve already displayed an sde, remove it from the grid now
            self.current_page.grid_remove()

        # Set the new page, and place it on the grid.
        self.current_page = self.pages[page_index]
        self.current_page.grid( row=0, column=0, sticky=&#39;nwse&#39;)
        self.update_header()

    def update_header(self):
        &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
        if self.page_index is not None:
            header_txt = f&#34;{self.page_index + 1} / {len(self.pages)}&#34;
        else:
            header_txt = &#34;[No lots to display.]&#34;
        self.header_lbl.config(text=header_txt)

    def gen_tablerow(self, uid, page=None, row_data=None):
        &#34;&#34;&#34;
        Generate a row in the table for the lot definition represented
        by the unique ID `uid`.
        :param uid: The unique ID of a lot, i.e. a key in `self.ld_dict`
        :param row_data: A list of strings to write for this row. (Leave
        unspecified, unless updating this row. If not specified, will
        use the data previously generated, e.g., at init.)
        &#34;&#34;&#34;
        if row_data is None:
            row_data = self.ld_dict[uid][&#39;row_data&#39;]
        if page is None:
            page = self.ld_dict[uid][&#39;page&#39;]
        is_header = self.ld_dict[uid][&#39;row_num&#39;] == 0
        row = self.ld_dict[uid][&#39;row_num&#39;]
        col = self.ld_dict[uid][&#39;grid_col&#39;]
        self.ld_dict[uid][&#39;tablerow&#39;] = LDTableRow(
            master=self.pages[page], control_owner=self, column_data=row_data,
            col_widths=self.col_width,
            col_wraps=self.col_wrap, is_header=is_header, uid=uid)
        self.ld_dict[uid][&#39;tablerow&#39;].grid(row=row, column=col, sticky=&#39;ns&#39;)

    def edit_btn_clicked(self, uid):
        &#34;&#34;&#34;
        Launch an editor for a target lot.

        :param uid: A key from `self.ld_dict`.
        &#34;&#34;&#34;
        # Close the current redefiner, if any.
        try:
            self.current_redefiner.destroy()
        except:
            pass

        # Launch a new redefiner for this lot.
        self.current_redefiner = LotRedefiner(
            self, target_lddb=self.target_lddb, trs=self.ld_dict[uid][&#39;trs&#39;],
            lot=self.ld_dict[uid][&#39;lot&#39;], top_owner=self.top_owner, uid=uid)

    def del_btn_clicked(self, uid):
        &#34;&#34;&#34;
        Delete the lot definition for this lot from the LDDB.
        &#34;&#34;&#34;

        trs = self.ld_dict[uid][&#39;trs&#39;]
        lot = self.ld_dict[uid][&#39;lot&#39;]
        cur_definition = self.ld_dict[uid][&#39;definition&#39;]
        ld = self.target_lddb.trs(trs)
        if ld is None or cur_definition == &#39;Undefined&#39;:
            return None

        confirm = tk.messagebox.askokcancel(
            &#39;Are you sure?&#39;,
            f&#34;Delete lot definition for {trs}: {lot}?&#34;
        )

        self.focus()

        if not confirm:
            return None

        # Remove this key from the ld
        ld.pop(lot, None)

        # If there are no more lots for this section in the LotDefinitions,
        # let&#39;s remove the LotDefinitions from the LDDB (which would optionally
        # allow default lot definitions to take over).
        if len(ld.keys()) == 0:
            twprge = self.ld_dict[uid][&#39;twprge&#39;]
            sec = self.ld_dict[uid][&#39;sec&#39;]
            tld = self.target_lddb.get_tld(twprge)
            # tld should never be None here, but just in case...
            if tld is not None:
                # Remove this section as key.
                tld.pop(sec, None)

        self.ld_dict[uid][&#39;row_data&#39;] = [trs, lot, &#39;Undefined&#39;]
        self.update_table(uid)
        self.top_owner.trigger_update_preview()

    def update_table(self, uid):
        &#34;&#34;&#34;
        Update the displayed table with the new definitions for the lot
        represented by the unique ID `uid`.
        &#34;&#34;&#34;
        self.ld_dict[uid][&#39;tablerow&#39;].destroy()
        d = self.ld_dict[uid]
        trs = d[&#39;trs&#39;]
        lot = d[&#39;lot&#39;]
        sec_num = d[&#39;sec&#39;]
        definition = &#39;Undefined&#39;

        tld = self.target_lddb.get_tld(d[&#39;twprge&#39;], force_tld_return=False)
        if tld is not None:
            ld = tld.get_ld(sec_num, force_ld_return=True)
            definition = ld.get(lot, &#39;Undefined&#39;)

        new_row_data = [trs, lot, definition]
        self.ld_dict[uid][&#39;row_data&#39;] = new_row_data
        self.ld_dict[uid][&#39;definition&#39;] = definition
        self.gen_tablerow(uid, row_data=new_row_data)


########################################################################
# Manually Adding QQ&#39;s to Plat
########################################################################

class ManualPlatter(tk.Frame):
    &#34;&#34;&#34;
    A frame for manually adding QQ&#39;s to the plats.
    &#34;&#34;&#34;

    PLATTER_ROW = 3
    PLATTER_COL = 1
    TWPRGE_WID = 5
    NSEW_WID = 2

    def __init__(self, master=None, mpq_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master
        if mpq_owner is None:
            mpq_owner = master
        self.mpq_owner = mpq_owner
        self.target_mpq = mpq_owner.ad_hoc_mpq

        # Space at the top.
        lbl = Label(self, text=&#39;&#39;)
        lbl.grid(row=0, column=1)

        # Frame for defining Twp, Rge, Sec
        trs_frame = tk.Frame(self)
        trs_frame.grid(row=1, column=1, padx=20)

        trs_col = 0

        lbl = tk.Label(trs_frame, text=&#39;Twp:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.twp_num = tk.Entry(trs_frame, width=self.TWPRGE_WID)
        self.twp_num.grid(row=0, column=trs_col)
        trs_col += 1

        self.twp_ns = Combobox(trs_frame, width=self.NSEW_WID)
        self.twp_ns[&#39;values&#39;] = [&#39;N&#39;, &#39;S&#39;]
        self.twp_ns.current(0)
        self.twp_ns.grid(row=0, column=trs_col)
        trs_col += 1

        lbl = tk.Label(trs_frame, text=&#39;  Rge:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.rge_num = tk.Entry(trs_frame, width=self.TWPRGE_WID)
        self.rge_num.grid(row=0, column=trs_col)
        trs_col += 1

        self.rge_ew = Combobox(trs_frame, width=self.NSEW_WID)
        self.rge_ew[&#39;values&#39;] = [&#39;W&#39;, &#39;E&#39;]
        self.rge_ew.current(0)
        self.rge_ew.grid(row=0, column=trs_col)
        trs_col += 1

        lbl = tk.Label(trs_frame, text=&#39;  Sec:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.sec_num = Combobox(trs_frame, width=self.NSEW_WID)
        self.sec_num[&#39;values&#39;] = [i for i in range(1,37)]
        self.sec_num.current(0)
        self.sec_num.grid(row=0, column=trs_col)
        trs_col += 1

        clear_all_btn = tk.Button(
            self, text=&#34;Clear All Manually Added QQ&#39;s&#34;, height=2,
            command=self.clear_btn_clicked)
        clear_all_btn.grid(row=10, column=1, padx=10, pady=30)

        # The current ManualSectionPlatter object -- initialized as
        # None, then set in `.new_platter().
        self.cur_platter = None
        self.new_platter()

    def child_go_btn_clicked(self):
        &#34;&#34;&#34;Add the QQ&#39;s to the target MultiPlatQueue.&#34;&#34;&#34;

        # Compile TRS
        twprge, sec = self._compile_trs()
        # If invalid characters were identified, `.compile_trs()` returns
        # `False`, so check for that now.
        if twprge is False:
            return

        # Assign sec number to the SectionGrid object in the current platter
        sg = self.cur_platter.sec_grid
        sg.sec = sec

        # Add the SectionGrid object to the target MPQ, for the specified twprge
        self.target_mpq.queue_add(sg, twprge)

        # Get a new platter
        self.new_platter()

        # Update mini-preview
        try:
            self.mpq_owner.trigger_update_preview()
        except:
            pass

    def _compile_trs(self):
        &#34;&#34;&#34;
        Compile the twprge (&#39;000x000x&#39;) from the current entry/combo
        boxes.
        :return:
        &#34;&#34;&#34;
        # Compile TRS
        twp_num = self.twp_num.get()
        NS = self.twp_ns.get().lower()
        rge_num = self.rge_num.get()
        EW = self.rge_ew.get().lower()
        sec = self.sec_num.get()

        for chk in [twp_num, rge_num]:
            if len(chk) &gt; 3 or not chk.isnumeric():
                tk.messagebox.showerror(
                    &#39;Invalid Twp / Rge&#39;,
                    &#39;Enter Township and Range as 1 to 3 digits.&#39;
                )
                return False, False

        if len(sec) &gt; 2 or not sec.isnumeric():
            tk.messagebox.showerror(
                &#39;Invalid Sec&#39;,
                &#39;Enter Section as 1 or 2 digits.&#39;
            )
            return False, False

        if NS.lower() not in [&#39;n&#39;, &#39;s&#39;]:
            tk.messagebox.showerror(
                &#39;Invalid N/S&#39;,
                &#39;Township must be designated as either N or S.&#39;
            )
            return False, False

        if EW.lower() not in [&#39;e&#39;, &#39;w&#39;]:
            tk.messagebox.showerror(
                &#39;Invalid E/W&#39;,
                &#39;Range must be designated as either E or W.&#39;
            )
            return False, False

        return (twp_num + NS.lower() + rge_num + EW.lower(), sec)

    def clear_btn_clicked(self):
        &#34;&#34;&#34;
        Clear all manually added QQ&#39;s from the plats.
        NOTE: Does NOT clear parsed descriptions.
        &#34;&#34;&#34;
        prompt = messagebox.askyesno(
            &#39;Confirm?&#39;,
            &#34;Delete all manually added QQ&#39;s from plats? (Does not delete &#34;
            &#34;parsed text descriptions.)&#34;,
            icon=&#39;warning&#39;)

        if prompt is True:
            # Set the mpq owner&#39;s `.ad_hoc_mpq` to an empty MPQ
            self.master.ad_hoc_mpq = MultiPlatQueue()

            # Re-define our target_mpq to point to this new MPQ
            self.target_mpq = self.master.ad_hoc_mpq

            # Generate a new preview (which will be an empty plat)
            self.master.preview_frame.gen_preview()

    def new_platter(self):
        try:
            self.cur_platter.destroy()
        except:
            pass
        self.cur_platter = ManualSectionPlatter(self)
        self.cur_platter.grid(
            row=self.PLATTER_ROW, column=self.PLATTER_COL, pady=10)


class ManualSectionPlatter(SectionFiller):
    &#34;&#34;&#34;
    For manually platting QQ&#39;s in a section.
    &#34;&#34;&#34;

    def __init__(self, master=None):
        SectionFiller.__init__(self, master)
        self.master = master
        self.go_btn.config(text=&#34;Add Selected QQ&#39;s to Plat&#34;, height=2)
        self.go_btn.grid(row=0, column=1, pady=20)

    def go_btn_clicked(self):
        self.master.child_go_btn_clicked()


########################################################################
# Main
########################################################################

def launch_app():
    app = MainWindow()
    app.mainloop()


if __name__ == &#39;__main__&#39;:
    launch_app()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.launch_app"><code class="name flex">
<span>def <span class="ident">launch_app</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def launch_app():
    app = MainWindow()
    app.mainloop()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.About"><code class="flex name class">
<span>class <span class="ident">About</span></span>
<span>(</span><span>master=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame containing the 'About' button, and corresponding
functionality.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class About(tk.Frame):
    &#34;&#34;&#34;A frame containing the &#39;About&#39; button, and corresponding
    functionality.&#34;&#34;&#34;

    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.master = master

        # Button to display &#39;about&#39; info
        about_button = tk.Button(
            self, text=&#39;About&#39;, height=1, width=6,
            command=self.about_btn_clicked)
        about_button.grid(row=1, column=1, padx=4, sticky=&#39;w&#39;)

        # Button to display pyTRS disclaimer
        disclaimer_button = tk.Button(
            self, text=&#39;pyTRS disclaimer&#39;, height=1,
            command=self.disclaimer_btn_clicked)
        disclaimer_button.grid(row=1, column=2, ipadx=2, padx=4, sticky=&#39;e&#39;)

    def about_btn_clicked(self):
        splash_info = (
            f&#34;pyTRSplat {version()}\n&#34;
            &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
            &#34;A program for generating plats from PLSS land descriptions (often &#34;
            &#34;called &#39;legal descriptions&#39;).\n\n&#34;

            f&#34;Built on pyTRS {pyTRS_version()}.\n&#34;
            &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
            &#34;A program for parsing PLSS land descriptions into their component &#34;
            &#34;parts.\n\n&#34;

            f&#34;Contact: &lt;{_constants.__email__}&gt;&#34;

        )
        messagebox.showinfo(&#39;pyTRSplat - About&#39;, splash_info)

    def disclaimer_btn_clicked(self):
        &#34;&#34;&#34;Display the disclaimer text from the pyTRS module.&#34;&#34;&#34;
        messagebox.showinfo(&#39;pyTRS disclaimer&#39;, pyTRS_constants.__disclaimer__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.About.about_btn_clicked"><code class="name flex">
<span>def <span class="ident">about_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def about_btn_clicked(self):
    splash_info = (
        f&#34;pyTRSplat {version()}\n&#34;
        &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
        &#34;A program for generating plats from PLSS land descriptions (often &#34;
        &#34;called &#39;legal descriptions&#39;).\n\n&#34;

        f&#34;Built on pyTRS {pyTRS_version()}.\n&#34;
        &#34;Copyright (c) 2020, James P. Imes, all rights reserved.\n&#34;
        &#34;A program for parsing PLSS land descriptions into their component &#34;
        &#34;parts.\n\n&#34;

        f&#34;Contact: &lt;{_constants.__email__}&gt;&#34;

    )
    messagebox.showinfo(&#39;pyTRSplat - About&#39;, splash_info)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.About.disclaimer_btn_clicked"><code class="name flex">
<span>def <span class="ident">disclaimer_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the disclaimer text from the pyTRS module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disclaimer_btn_clicked(self):
    &#34;&#34;&#34;Display the disclaimer text from the pyTRS module.&#34;&#34;&#34;
    messagebox.showinfo(&#39;pyTRS disclaimer&#39;, pyTRS_constants.__disclaimer__)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.CustomSettingsEditor"><code class="flex name class">
<span>class <span class="ident">CustomSettingsEditor</span></span>
<span>(</span><span>master=None, output_frame=None, first_settings_obj=None, show_save_preset=True, show_load_preset=True, show_save_custom=False, show_load_custom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An editor for configuring plat settings, somewhat customized for
this application.</p>
<p>The controller for an _EditorFrame object, including high-level
functions (Load, Save, etc.). Note that OK and Cancel buttons
can be placed or hidden with parameters <code>show_ok=True</code> and
<code>show_cancel=True</code>, but they have no effect in this class. To
give them any effect, create a subclass and customize
<code>ok_btn_clicked()</code> and <code>cancel_btn_clicked()</code>, as needed for a
given application.</p>
<p>:param master:
:param first_settings_obj: The Settings object whose data will
populate the fields when the frame is first loaded.
:param show_ok:
:param show_cancel:
:param show_save_preset:
:param show_load_preset:
:param show_save_custom:
:param show_load_custom:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomSettingsEditor(SettingsEditor):
    &#34;&#34;&#34;
    An editor for configuring plat settings, somewhat customized for
    this application.
    &#34;&#34;&#34;
    def __init__(self, master=None, output_frame=None, first_settings_obj=None,
            show_save_preset=True, show_load_preset=True,
            show_save_custom=False, show_load_custom=False):
        SettingsEditor.__init__(
            self, master, first_settings_obj=first_settings_obj, show_ok=True,
            show_save_preset=show_save_preset, show_load_preset=show_load_preset,
            show_save_custom=show_save_custom, show_load_custom=show_load_custom)
        self.master = master

        # Output frame is where the resulting data should be stored.
        self.output_frame = output_frame
        self.ok_button.config(text=&#39;Update Plat With These Settings&#39;)

    def ok_btn_clicked(self):
        &#34;&#34;&#34;
        Compile the Settings object and pass it to the main window.
        &#34;&#34;&#34;
        set_obj = self.editor.compile_settings()
        if set_obj is False:
            return
        output_frame = self.output_frame
        output_frame.current_custom_settings = set_obj

        # Update the displayed presets in the output frame
        output_frame.avail_settings = Settings.list_presets()
        output_frame.avail_settings.append(&#39;&lt;customized&gt;&#39;)
        output_frame.settings_combo[&#39;values&#39;] = output_frame.avail_settings
        output_frame.settings_combo.current(len(output_frame.avail_settings) - 1)

        # Destroy the toplevel containing this frame.
        self.master.destroy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyTRSplat.settingseditor.SettingsEditor.SettingsEditor" href="settingseditor/SettingsEditor.html#pyTRSplat.settingseditor.SettingsEditor.SettingsEditor">SettingsEditor</a></li>
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.CustomSettingsEditor.ok_btn_clicked"><code class="name flex">
<span>def <span class="ident">ok_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compile the Settings object and pass it to the main window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ok_btn_clicked(self):
    &#34;&#34;&#34;
    Compile the Settings object and pass it to the main window.
    &#34;&#34;&#34;
    set_obj = self.editor.compile_settings()
    if set_obj is False:
        return
    output_frame = self.output_frame
    output_frame.current_custom_settings = set_obj

    # Update the displayed presets in the output frame
    output_frame.avail_settings = Settings.list_presets()
    output_frame.avail_settings.append(&#39;&lt;customized&gt;&#39;)
    output_frame.settings_combo[&#39;values&#39;] = output_frame.avail_settings
    output_frame.settings_combo.current(len(output_frame.avail_settings) - 1)

    # Destroy the toplevel containing this frame.
    self.master.destroy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyTRSplat.settingseditor.SettingsEditor.SettingsEditor" href="settingseditor/SettingsEditor.html#pyTRSplat.settingseditor.SettingsEditor.SettingsEditor">SettingsEditor</a></b></code>:
<ul class="hlist">
<li><code><a title="pyTRSplat.settingseditor.SettingsEditor.SettingsEditor.preview_btn_clicked" href="settingseditor/SettingsEditor.html#pyTRSplat.settingseditor.SettingsEditor.SettingsEditor.preview_btn_clicked">preview_btn_clicked</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame"><code class="flex name class">
<span>class <span class="ident">DescFrame</span></span>
<span>(</span><span>master=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame for getting / clearing text of description to parse and
add to the plat, getting LotDefDB from .csv.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DescFrame(tk.Frame):
    &#34;&#34;&#34;A frame for getting / clearing text of description to parse and
    add to the plat, getting LotDefDB from .csv.&#34;&#34;&#34;
    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.master = master
        if not hasattr(master, &#39;warn_flawed_parse&#39;):
            master.warn_flawed_parse = True
        # a tk var containing Default config parameters for pyTRS parsing.
        self.config_text = tk.StringVar()
        self.config_text.set(&#39;&#39;)
        self.config_popup_tk = None

        # For getting the PLSS descriptions from user.
        desc_frame = tk.Frame(self)
        desc_frame.grid(row=0, column=1, sticky=&#39;n&#39;, padx=5, pady=5)

        # For getting .csv file for LotDefDB from user
        lddb_save_frame = tk.Frame(self)
        lddb_save_frame.grid(row=5, column=1, sticky=&#39;sw&#39;)

        # Button to configure pyTRS parameters
        cf_button = tk.Button(
            desc_frame, text=&#39;Configure Parse&#39;, height=2,
            command=self.cf_btn_clicked)
        cf_button.grid(row=3, column=1, pady=8, sticky=&#39;w&#39;)

        # Button to commence pyTRS parsing (and add resulting PLSSDesc to MPQ)
        parse_button = tk.Button(
            desc_frame, text=&#39;Parse Description / Add to Plat&#39;, height=2,
            command=self.parse_btn_clicked)
        parse_button.grid(row=3, column=1, pady=8, sticky=&#39;e&#39;)

        desc_box_header = tk.Label(
            desc_frame, text=&#39;Enter one or more land descriptions:&#39;)
        desc_box_header.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.desc_box_entry = tk.Text(desc_frame, width=36, height=9)
        self.desc_box_entry.grid(row=2, column=1)

        # Button to launch description editor
        editor_button = tk.Button(
            desc_frame, text=&#39;Description Editor&#39;, height=2,
            command=self.editor_btn_clicked)
        editor_button.grid(row=4, column=1, pady=5, sticky=&#39;w&#39;)

        # Button to clear all PLSSDesc&#39;s from the MPQ
        clear_button = tk.Button(
            desc_frame, text=&#39;Clear All Descriptions&#39;, height=2,
            command=self.clear_btn_clicked)
        clear_button.grid(row=4, column=1, pady=5, sticky=&#39;e&#39;)

        # Button to load LotDefDB from .csv file
        lddb_button = tk.Button(
            desc_frame, text=&#39;Get lot definitions from .csv&#39;, height=2,
            command=self.lddb_btn_clicked)
        lddb_button.grid(row=5, column=1, pady=5, sticky=&#39;w&#39;)

        # Button to view / manually define lots
        ld_editor_btn = tk.Button(
            desc_frame, text=&#39;View / define Lots&#39;, height=2,
            command=self.manual_lddb_clicked)
        ld_editor_btn.grid(row=5, column=1, pady=5, sticky=&#39;e&#39;)

        # Our current LotDefEditor toplevel (if any)
        self.lde = None

        self.lddp_fp_text = tk.StringVar(&#39;&#39;)
        self.lddp_fp_text.set(f&#34;Current lot definitions: [None loaded]&#34;)
        lddb_label = tk.Label(desc_frame, textvariable=self.lddp_fp_text)
        # lddb_label.grid(row=7, column=1, sticky=&#39;w&#39;)

        default_lots_frame = tk.Frame(desc_frame)
        default_lots_frame.grid(row=8, column=1, sticky=&#39;w&#39;)

        self.trust_default_lots = tk.BooleanVar(
            desc_frame, value=True, name=&#39;trust_default_lots&#39;)
        lots_chkbtn = Checkbutton(
            default_lots_frame, text=&#39;Trust Default Lots&#39;, onvalue=True,
            offvalue=False, variable=self.trust_default_lots,
            command=self.trigger_update_preview)
        lots_chkbtn.grid(row=1, column=2, sticky=&#39;w&#39;)

        lots_help_btn = tk.Button(
            default_lots_frame, text=&#39;?&#39;, padx=4,
            command=self.lots_help_btn_clicked)
        lots_help_btn.grid(
            row=1, column=1, sticky=&#39;w&#39;)

    def manual_lddb_clicked(self):
        &#34;&#34;&#34;
        Check if any lots currently exist in the parsed descriptions.
        If so, launch the lot viewer / editor window.
        &#34;&#34;&#34;
        try:
            self.lde.destroy()
        except:
            pass

        def unpack_tract(tract, lots):
            for lot in tract.lotList:
                lots.setdefault(tract.trs, [])
                if lot not in lots[tract.trs]:
                    lots[tract.trs].append(lot)

        # Use tiny settings for speed. Only want the unhandled lots.
        mp = self.master.output_frame.gen_plat(use_tiny=True)

        # Get a unhandled_lots dict, and set it to `lots` variable.
        # (Here we don&#39;t care about the first-returned value, a bool.)
        _, lots = self.master.output_frame._check_for_unhandled_lots(
            mp, warn=False, do_not_launch=True)

        for desc_obj in self.master.plssdesc_list:
            for tract in desc_obj.parsedTracts:
                unpack_tract(tract, lots)

        if len(lots) == 0:
            messagebox.showinfo(
                &#39;No Lots&#39;,
                &#39;There are currently no lots in parsed descriptions. Try &#39;
                &#39;adding one or more land descriptions above.&#39;
            )
            return

        self.lde = LotDefEditor(
            self, top_owner=self.master, target_lddb=self.master.lddb,
            lots=lots)
        self.lde.focus()

    def editor_btn_clicked(self):
        &#34;&#34;&#34;Launch (or refocus-on) a DescriptionEditor popup window, for
        editing already-added descriptions.&#34;&#34;&#34;
        if len(self.master.plssdesc_list) == 0:
            messagebox.showinfo(
                &#39;No descriptions&#39;,
                &#39;No descriptions to view / edit. Add land descriptions above.&#39;)
            return

        # Try grabbing the existing editor window, if it exists. If not,
        # launch a new editor window.
        try:
            self.editor_window.focus()
            self.editor_window.grab_set()
            return
        except:
            pass

        self.editor_window = DescriptionEditor(
            self, plssdesc_list=self.master.plssdesc_list,
            plssdesc_list_owner=self.master)
        self.editor_window.title(&#39;pyTRSplat - View / Edit Descriptions&#39;)
        self.editor_window.focus()
        self.editor_window.grab_set()

    def cf_btn_clicked(self):
        &#34;&#34;&#34;
        Config button was clicked; launch popup window to get Config
        parameters from user (results are stored in StringVar
        `self.config_text`).
        &#34;&#34;&#34;
        try:
            # Kill the previously opened config popup, if any.
            self.config_popup_tk.destroy()
        except:
            pass

        # Open a config popup, and store it to attrib.
        self.config_popup_tk = tk.Toplevel()
        self.config_popup_tk.focus()
        self.config_popup_tk.grab_set()
        self.config_popup_tk.title(&#39;Set pyTRS Config Parameters&#39;)
        after_prompt = None
        if len(self.master.plssdesc_list) &gt; 0:
            # If the user has already parsed one or more descriptions,
            # we&#39;ll give this notice after config parameters are set.
            after_prompt = (
                &#39;NOTE: &#39;
                &#39;The config parameters that have just been set will ONLY &#39;
                &#39;affect descriptions that are parsed AFTER this point. Any &#39;
                &#39;descriptions that have already been parsed and added to &#39;
                &#39;the plat will NOT be affected by changes to these config &#39;
                &#39;parameters. (To reconfigure already-parsed descriptions, &#39;
                &#39;use the Description Editor.)&#39;)
        pc = pyTRS.interface_tools.PromptConfig(
            master=self.config_popup_tk, target_config_var=self.config_text,
            parameters=[
                &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
            ],
            show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
            exit_after_ok=True)
        pc.pack(padx=20, pady=10)

    def parse_btn_clicked(self):
        &#34;&#34;&#34;
        Pull the entered text, and use the chosen config parameters (if
        any) to generate a PLSSDesc object, and add it to the queue to
        plat.
        &#34;&#34;&#34;
        config_text = self.config_text.get()
        descrip_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)

        if len(descrip_text) &lt; 2:
            return

        # Create a PLSSDesc object from the supplied text and parse it using the
        # specified config parameters (if any).
        desc = pyTRS.PLSSDesc(descrip_text, config=config_text, initParseQQ=True)

        if len(desc.eFlagList) &gt; 0 and self.master.warn_flawed_parse:
            eFlags = &#39;, &#39;.join(desc.eFlagList)
            confirm = tk.messagebox.askokcancel(
                &#39;Flawed Description Identified&#39;,
                &#39;One or more apparent flaws was identified when parsing this &#39;
                &#39;description, potentially due to non-standard abbreviations, &#39;
                &#39;typos, etc., or due to limitations in the parsing library:\n\n&#39;
                f&#34;&lt;flag codes:  {eFlags}&gt;&#34;
                &#39;\n\n&#39;
                &#39;The description can still be platted, although results may &#39;
                &#39;not be as intended.\n\n&#39;
                &#39;(The Description Editor can also be used at any time to view &#39;
                &#39;/ edit descriptions, and see additional parsing information.)&#39;
            )

            if not confirm:
                return

        # Add desc to the plssdesc_list
        self.master.plssdesc_list.append(desc)

        # Clear the text from the desc_box_entry
        self.desc_box_entry.delete(&#34;1.0&#34;, &#39;end-1c&#39;)

        # And update the preview plat.
        self.trigger_update_preview()

    def trigger_update_preview(self):
        self.master.preview_frame.gen_preview()

    def clear_btn_clicked(self):
        &#34;&#34;&#34;
        Clear all plats and descriptions (reset to start).
        NOTE: Does NOT clear manually added QQ&#39;s.
        &#34;&#34;&#34;
        prompt = messagebox.askyesno(
            &#39;Confirm?&#39;,
            &#39;Delete all added descriptions? (Does not delete manually added &#39;
            &#34;QQ&#39;s.)&#34;,
            icon=&#39;warning&#39;)

        if prompt is True:
            # Set the `.plssdesc_list` to an empty list
            self.master.plssdesc_list = []

            # Generate a new preview (which will be an empty plat)
            self.master.preview_frame.gen_preview()

    def lddb_btn_clicked(self):
        &#34;&#34;&#34;Prompt user for .csv file containing LotDefDB data. If
        selected, loads from that file into `master.lddb` attribute, and
        replaces the existing LotDefDB in that attribute.&#34;&#34;&#34;
        lddb_fp = filedialog.askopenfilename(
            initialdir=&#39;/&#39;,
            filetypes=[(&#34;CSV Files&#34;, &#34;*.csv&#34;)],
            title=&#39;CSV containing Lot Definition data...&#39;
        )
        if lddb_fp:
            if lddb_fp.lower().endswith(&#39;.csv&#39;):
                try:
                    # Load the LDDB
                    self.master.lddb._import_csv(lddb_fp)

                    # Update the preview window
                    self.master.preview_frame.gen_preview()

                    # Set the label
                    max_chars = 20
                    name = Path(lddb_fp).name
                    if len(name) &gt; max_chars:
                        name = name[:max_chars - 3] + &#39;...&#39;
                    self.lddp_fp_text.set(
                        f&#34;Current lot definitions: {name}&#34;)

                except:
                    messagebox.showerror(
                        &#39;Could Not Load File&#39;,
                        f&#34;Chosen file &#39;{lddb_fp}&#39; could not be loaded.&#34;)
            else:
                messagebox.showerror(
                    &#39;.csv Files Only&#39;, &#39;May only load \&#39;.csv\&#39; files containing &#39;
                                       &#39;lot definitions.&#39;)

    def lots_help_btn_clicked(self):
        &#34;&#34;&#34;Display info about LotDefDB and default lots.&#34;&#34;&#34;

        msg = (
            &#34;By checking &#39;Trust Default Lots&#39;, this program will interpret &#34;
            &#34;lots in Sections 1 - 7, 18, 19, 30, and 31 as though they are &#34;
            &#34;lots in a &#39;standard&#39; township, unless the user has otherwise &#34;
            &#34;defined lots for a given section manually (with the &#39;Define &#34;
            &#34;Lots&#39; function) and/or by loading a .csv file containing lot &#34;
            &#34;definitions (to see how to format such a .csv file, see the &#34;
            &#34;included `SAMPLE_LDDB.csv` and/or the documentation).&#34;
            &#34;\n\n&#34;
            &#34;NOTE: Default lots will ONLY be used where no lots have been &#34;
            &#34;defined for a given section individually or in a loaded .csv &#34;
            &#34;file. (If a .csv file has been loaded, and/or if some lots have &#34;
            &#34;been defined individually, but not any lots for Section 4, &#34;
            &#34;T154N-R97W, then default lots would be used for that Section 4 &#34;
            &#34;-- as long as this box is checked.)&#34;
            &#34;\n\n\n&#34;
            &#34;MORE INFO:\n&#34;
            &#34;A so-called &#39;standard&#39; township would have been surveyed in such &#34;
            &#34;a way that there are lots along the northern and western &#34;
            &#34;boundaries -- i.e. along the boundaries of Sections 1 - 7, 18, &#34;
            &#34;19, 30, and 31. These lot numbers are predictable (e.g. Lots 1, &#34;
            &#34;2, 3, and 4 in a &#39;standard&#39; Section 1 correspond with the NE¼NE¼, &#34;
            &#34;NW¼NE¼, NE¼NW¼, and NW¼NW¼, respectively). Every other square in &#34;
            &#34;a &#39;standard&#39; township is an essentially perfect 40-acre square &#34;
            &#34;called a &#39;quarter-quarter&#39; (or &#39;QQ&#39;).&#34;
            &#34;\n\n&#34;
            &#34;However, in practice, townships are rarely &#39;standard&#39;. Natural &#34;
            &#34;features like rivers, lakes, mountains, the curvature of the &#34;
            &#34;earth, etc. -- or faulty surveys -- may result in differently &#34;
            &#34;numbered lots in Sections 1 - 7, 18, 19, 30, and 31; as well as &#34;
            &#34;lots in any other sections.&#34;
            &#34;\n\n&#34;
            &#34;&#39;Trust Default Lots&#39; may be useful as a backup option, but &#34;
            &#34;a more accurate plat can be achieved by defining specific lots &#34;
            &#34;individually with the &#39;Define Lots&#39; feature, and/or by defining &#34;
            &#34;them in a .csv spreadsheet and loading from that.&#34;
        )
        messagebox.showinfo(&#39;Default Lots&#39;, msg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.cf_btn_clicked"><code class="name flex">
<span>def <span class="ident">cf_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Config button was clicked; launch popup window to get Config
parameters from user (results are stored in StringVar
<code>self.config_text</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cf_btn_clicked(self):
    &#34;&#34;&#34;
    Config button was clicked; launch popup window to get Config
    parameters from user (results are stored in StringVar
    `self.config_text`).
    &#34;&#34;&#34;
    try:
        # Kill the previously opened config popup, if any.
        self.config_popup_tk.destroy()
    except:
        pass

    # Open a config popup, and store it to attrib.
    self.config_popup_tk = tk.Toplevel()
    self.config_popup_tk.focus()
    self.config_popup_tk.grab_set()
    self.config_popup_tk.title(&#39;Set pyTRS Config Parameters&#39;)
    after_prompt = None
    if len(self.master.plssdesc_list) &gt; 0:
        # If the user has already parsed one or more descriptions,
        # we&#39;ll give this notice after config parameters are set.
        after_prompt = (
            &#39;NOTE: &#39;
            &#39;The config parameters that have just been set will ONLY &#39;
            &#39;affect descriptions that are parsed AFTER this point. Any &#39;
            &#39;descriptions that have already been parsed and added to &#39;
            &#39;the plat will NOT be affected by changes to these config &#39;
            &#39;parameters. (To reconfigure already-parsed descriptions, &#39;
            &#39;use the Description Editor.)&#39;)
    pc = pyTRS.interface_tools.PromptConfig(
        master=self.config_popup_tk, target_config_var=self.config_text,
        parameters=[
            &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
        ],
        show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
        exit_after_ok=True)
    pc.pack(padx=20, pady=10)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.clear_btn_clicked"><code class="name flex">
<span>def <span class="ident">clear_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all plats and descriptions (reset to start).
NOTE: Does NOT clear manually added QQ's.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_btn_clicked(self):
    &#34;&#34;&#34;
    Clear all plats and descriptions (reset to start).
    NOTE: Does NOT clear manually added QQ&#39;s.
    &#34;&#34;&#34;
    prompt = messagebox.askyesno(
        &#39;Confirm?&#39;,
        &#39;Delete all added descriptions? (Does not delete manually added &#39;
        &#34;QQ&#39;s.)&#34;,
        icon=&#39;warning&#39;)

    if prompt is True:
        # Set the `.plssdesc_list` to an empty list
        self.master.plssdesc_list = []

        # Generate a new preview (which will be an empty plat)
        self.master.preview_frame.gen_preview()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.editor_btn_clicked"><code class="name flex">
<span>def <span class="ident">editor_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch (or refocus-on) a DescriptionEditor popup window, for
editing already-added descriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editor_btn_clicked(self):
    &#34;&#34;&#34;Launch (or refocus-on) a DescriptionEditor popup window, for
    editing already-added descriptions.&#34;&#34;&#34;
    if len(self.master.plssdesc_list) == 0:
        messagebox.showinfo(
            &#39;No descriptions&#39;,
            &#39;No descriptions to view / edit. Add land descriptions above.&#39;)
        return

    # Try grabbing the existing editor window, if it exists. If not,
    # launch a new editor window.
    try:
        self.editor_window.focus()
        self.editor_window.grab_set()
        return
    except:
        pass

    self.editor_window = DescriptionEditor(
        self, plssdesc_list=self.master.plssdesc_list,
        plssdesc_list_owner=self.master)
    self.editor_window.title(&#39;pyTRSplat - View / Edit Descriptions&#39;)
    self.editor_window.focus()
    self.editor_window.grab_set()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.lddb_btn_clicked"><code class="name flex">
<span>def <span class="ident">lddb_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prompt user for .csv file containing LotDefDB data. If
selected, loads from that file into <code>master.lddb</code> attribute, and
replaces the existing LotDefDB in that attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lddb_btn_clicked(self):
    &#34;&#34;&#34;Prompt user for .csv file containing LotDefDB data. If
    selected, loads from that file into `master.lddb` attribute, and
    replaces the existing LotDefDB in that attribute.&#34;&#34;&#34;
    lddb_fp = filedialog.askopenfilename(
        initialdir=&#39;/&#39;,
        filetypes=[(&#34;CSV Files&#34;, &#34;*.csv&#34;)],
        title=&#39;CSV containing Lot Definition data...&#39;
    )
    if lddb_fp:
        if lddb_fp.lower().endswith(&#39;.csv&#39;):
            try:
                # Load the LDDB
                self.master.lddb._import_csv(lddb_fp)

                # Update the preview window
                self.master.preview_frame.gen_preview()

                # Set the label
                max_chars = 20
                name = Path(lddb_fp).name
                if len(name) &gt; max_chars:
                    name = name[:max_chars - 3] + &#39;...&#39;
                self.lddp_fp_text.set(
                    f&#34;Current lot definitions: {name}&#34;)

            except:
                messagebox.showerror(
                    &#39;Could Not Load File&#39;,
                    f&#34;Chosen file &#39;{lddb_fp}&#39; could not be loaded.&#34;)
        else:
            messagebox.showerror(
                &#39;.csv Files Only&#39;, &#39;May only load \&#39;.csv\&#39; files containing &#39;
                                   &#39;lot definitions.&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.lots_help_btn_clicked"><code class="name flex">
<span>def <span class="ident">lots_help_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display info about LotDefDB and default lots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lots_help_btn_clicked(self):
    &#34;&#34;&#34;Display info about LotDefDB and default lots.&#34;&#34;&#34;

    msg = (
        &#34;By checking &#39;Trust Default Lots&#39;, this program will interpret &#34;
        &#34;lots in Sections 1 - 7, 18, 19, 30, and 31 as though they are &#34;
        &#34;lots in a &#39;standard&#39; township, unless the user has otherwise &#34;
        &#34;defined lots for a given section manually (with the &#39;Define &#34;
        &#34;Lots&#39; function) and/or by loading a .csv file containing lot &#34;
        &#34;definitions (to see how to format such a .csv file, see the &#34;
        &#34;included `SAMPLE_LDDB.csv` and/or the documentation).&#34;
        &#34;\n\n&#34;
        &#34;NOTE: Default lots will ONLY be used where no lots have been &#34;
        &#34;defined for a given section individually or in a loaded .csv &#34;
        &#34;file. (If a .csv file has been loaded, and/or if some lots have &#34;
        &#34;been defined individually, but not any lots for Section 4, &#34;
        &#34;T154N-R97W, then default lots would be used for that Section 4 &#34;
        &#34;-- as long as this box is checked.)&#34;
        &#34;\n\n\n&#34;
        &#34;MORE INFO:\n&#34;
        &#34;A so-called &#39;standard&#39; township would have been surveyed in such &#34;
        &#34;a way that there are lots along the northern and western &#34;
        &#34;boundaries -- i.e. along the boundaries of Sections 1 - 7, 18, &#34;
        &#34;19, 30, and 31. These lot numbers are predictable (e.g. Lots 1, &#34;
        &#34;2, 3, and 4 in a &#39;standard&#39; Section 1 correspond with the NE¼NE¼, &#34;
        &#34;NW¼NE¼, NE¼NW¼, and NW¼NW¼, respectively). Every other square in &#34;
        &#34;a &#39;standard&#39; township is an essentially perfect 40-acre square &#34;
        &#34;called a &#39;quarter-quarter&#39; (or &#39;QQ&#39;).&#34;
        &#34;\n\n&#34;
        &#34;However, in practice, townships are rarely &#39;standard&#39;. Natural &#34;
        &#34;features like rivers, lakes, mountains, the curvature of the &#34;
        &#34;earth, etc. -- or faulty surveys -- may result in differently &#34;
        &#34;numbered lots in Sections 1 - 7, 18, 19, 30, and 31; as well as &#34;
        &#34;lots in any other sections.&#34;
        &#34;\n\n&#34;
        &#34;&#39;Trust Default Lots&#39; may be useful as a backup option, but &#34;
        &#34;a more accurate plat can be achieved by defining specific lots &#34;
        &#34;individually with the &#39;Define Lots&#39; feature, and/or by defining &#34;
        &#34;them in a .csv spreadsheet and loading from that.&#34;
    )
    messagebox.showinfo(&#39;Default Lots&#39;, msg)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.manual_lddb_clicked"><code class="name flex">
<span>def <span class="ident">manual_lddb_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if any lots currently exist in the parsed descriptions.
If so, launch the lot viewer / editor window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manual_lddb_clicked(self):
    &#34;&#34;&#34;
    Check if any lots currently exist in the parsed descriptions.
    If so, launch the lot viewer / editor window.
    &#34;&#34;&#34;
    try:
        self.lde.destroy()
    except:
        pass

    def unpack_tract(tract, lots):
        for lot in tract.lotList:
            lots.setdefault(tract.trs, [])
            if lot not in lots[tract.trs]:
                lots[tract.trs].append(lot)

    # Use tiny settings for speed. Only want the unhandled lots.
    mp = self.master.output_frame.gen_plat(use_tiny=True)

    # Get a unhandled_lots dict, and set it to `lots` variable.
    # (Here we don&#39;t care about the first-returned value, a bool.)
    _, lots = self.master.output_frame._check_for_unhandled_lots(
        mp, warn=False, do_not_launch=True)

    for desc_obj in self.master.plssdesc_list:
        for tract in desc_obj.parsedTracts:
            unpack_tract(tract, lots)

    if len(lots) == 0:
        messagebox.showinfo(
            &#39;No Lots&#39;,
            &#39;There are currently no lots in parsed descriptions. Try &#39;
            &#39;adding one or more land descriptions above.&#39;
        )
        return

    self.lde = LotDefEditor(
        self, top_owner=self.master, target_lddb=self.master.lddb,
        lots=lots)
    self.lde.focus()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.parse_btn_clicked"><code class="name flex">
<span>def <span class="ident">parse_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pull the entered text, and use the chosen config parameters (if
any) to generate a PLSSDesc object, and add it to the queue to
plat.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_btn_clicked(self):
    &#34;&#34;&#34;
    Pull the entered text, and use the chosen config parameters (if
    any) to generate a PLSSDesc object, and add it to the queue to
    plat.
    &#34;&#34;&#34;
    config_text = self.config_text.get()
    descrip_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)

    if len(descrip_text) &lt; 2:
        return

    # Create a PLSSDesc object from the supplied text and parse it using the
    # specified config parameters (if any).
    desc = pyTRS.PLSSDesc(descrip_text, config=config_text, initParseQQ=True)

    if len(desc.eFlagList) &gt; 0 and self.master.warn_flawed_parse:
        eFlags = &#39;, &#39;.join(desc.eFlagList)
        confirm = tk.messagebox.askokcancel(
            &#39;Flawed Description Identified&#39;,
            &#39;One or more apparent flaws was identified when parsing this &#39;
            &#39;description, potentially due to non-standard abbreviations, &#39;
            &#39;typos, etc., or due to limitations in the parsing library:\n\n&#39;
            f&#34;&lt;flag codes:  {eFlags}&gt;&#34;
            &#39;\n\n&#39;
            &#39;The description can still be platted, although results may &#39;
            &#39;not be as intended.\n\n&#39;
            &#39;(The Description Editor can also be used at any time to view &#39;
            &#39;/ edit descriptions, and see additional parsing information.)&#39;
        )

        if not confirm:
            return

    # Add desc to the plssdesc_list
    self.master.plssdesc_list.append(desc)

    # Clear the text from the desc_box_entry
    self.desc_box_entry.delete(&#34;1.0&#34;, &#39;end-1c&#39;)

    # And update the preview plat.
    self.trigger_update_preview()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescFrame.trigger_update_preview"><code class="name flex">
<span>def <span class="ident">trigger_update_preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_update_preview(self):
    self.master.preview_frame.gen_preview()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescTextEditWindow"><code class="flex name class">
<span>class <span class="ident">DescTextEditWindow</span></span>
<span>(</span><span>master=None, orig_text=None, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A pop-up window in which the user may make edits to the text of a
pyTRS.PLSSDesc object.</p>
<p>Construct a toplevel widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, menu, relief, screen, takefocus,
use, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DescTextEditWindow(tk.Toplevel):
    &#34;&#34;&#34;A pop-up window in which the user may make edits to the text of a
    pyTRS.PLSSDesc object.&#34;&#34;&#34;

    def __init__(self, master=None, orig_text=None, **kw):
        tk.Toplevel.__init__(self, master, **kw)
        self.master = master

        self.orig_text = orig_text

        desc_box_header = tk.Label(
            self, text=&#39;Replace existing land description with:&#39;)
        desc_box_header.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.desc_box_entry = tk.Text(self, width=64, height=16)
        self.desc_box_entry.grid(row=2, column=1, padx=4, pady=4)

        # Fill with the text box with the existing text.
        if orig_text is not None:
            self.desc_box_entry.insert(tk.END, orig_text)

        control_frame = tk.Frame(self)
        control_frame.grid(row=3, column=1)
        ok_button = tk.Button(
            control_frame, text=&#39;Confirm&#39;, width=12,
            command=self.ok_btn_clicked)
        ok_button.grid(row=1, column=2, padx=16, pady=10, sticky=&#39;n&#39;)

        cancel_button = tk.Button(
            control_frame, text=&#39;Cancel&#39;, width=12,
            command=self.cancel_btn_clicked)
        cancel_button.grid(row=1, column=1, padx=16, pady=10, sticky=&#39;n&#39;)

    def ok_btn_clicked(self):
        # Set the new description.
        self.master.new_desc_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)
        # Display it.
        self.master.display_new_descrip(status=&#39;not_activated&#39;)
        # Destroy this text pop_up.
        self.master.new_desc_pop_up_tk = None
        self.destroy()

    def cancel_btn_clicked(self):
        if self.orig_text != self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;):
            # If there were changes made to the text, confirm with user
            # that they should be discarded before destroying the window
            confirm = messagebox.askyesno(
                &#39;Discard changes?&#39;,
                &#34;Discard any changes you&#39;ve made to this text?&#34;)
            self.focus()
            self.grab_set()

            if confirm:
                self.destroy()
        else:
            self.destroy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.DescTextEditWindow.cancel_btn_clicked"><code class="name flex">
<span>def <span class="ident">cancel_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_btn_clicked(self):
    if self.orig_text != self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;):
        # If there were changes made to the text, confirm with user
        # that they should be discarded before destroying the window
        confirm = messagebox.askyesno(
            &#39;Discard changes?&#39;,
            &#34;Discard any changes you&#39;ve made to this text?&#34;)
        self.focus()
        self.grab_set()

        if confirm:
            self.destroy()
    else:
        self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescTextEditWindow.ok_btn_clicked"><code class="name flex">
<span>def <span class="ident">ok_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ok_btn_clicked(self):
    # Set the new description.
    self.master.new_desc_text = self.desc_box_entry.get(&#34;1.0&#34;, &#34;end-1c&#34;)
    # Display it.
    self.master.display_new_descrip(status=&#39;not_activated&#39;)
    # Destroy this text pop_up.
    self.master.new_desc_pop_up_tk = None
    self.destroy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor"><code class="flex name class">
<span>class <span class="ident">DescriptionEditor</span></span>
<span>(</span><span>master=None, plssdesc_list=None, plssdesc_list_owner=None, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A widget for viewing, editing, reconfiguring, and reparsing PLSSDesc
objects that are currently in the MultiPlatQueue.</p>
<p>NOTE: At init, specify <code>plssdesc_list_owner=&lt;object&gt;</code> (e.g., a root
Tk() object), if that's where the list of updated/saved PLSSDesc
objects should be stored to (defaults to same as <code>master</code>, but may
need to be a higher-level master).</p>
<p>Construct a toplevel widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, menu, relief, screen, takefocus,
use, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DescriptionEditor(tk.Toplevel):
    &#34;&#34;&#34;
    A widget for viewing, editing, reconfiguring, and reparsing PLSSDesc
    objects that are currently in the MultiPlatQueue.

    NOTE: At init, specify `plssdesc_list_owner=&lt;object&gt;` (e.g., a root
    Tk() object), if that&#39;s where the list of updated/saved PLSSDesc
    objects should be stored to (defaults to same as `master`, but may
    need to be a higher-level master).
    &#34;&#34;&#34;

    SDE_ROW = 1
    SDE_COL = 1

    def __init__(self, master=None, plssdesc_list=None,
                 plssdesc_list_owner=None, **kw):
        tk.Toplevel.__init__(self, master, **kw)
        self.master = master
        if plssdesc_list_owner is None:
            plssdesc_list_owner = master
        self.plssdesc_list_owner = plssdesc_list_owner
        if not hasattr(self.plssdesc_list_owner, &#39;plssdesc_list&#39;):
            self.plssdesc_list_owner.plssdesc_list = []
        if plssdesc_list is None:
            plssdesc_list = []

        self.plssdesc_list = plssdesc_list

        self.more_info = False

        # The index of the currently displayed SDE
        self.displayed_sde_index = None

        # A list of SingleDescriptionEditor objects (a tk.Frame subclass),
        # one for each PLSSDesc object in `self.plssdesc_list`
        self.editors = self.populate_editors()

        ##############################
        # Control Frame / Buttons
        ##############################
        control_frame = tk.Frame(self)
        control_frame.grid(row=0, column=1, sticky=&#39;nesw&#39;)

        self.header_lbl = tk.Label(control_frame, text=&#39;&#39;)
        self.header_lbl.grid(row=0, column=1)

        # Subframe for left/right scrol
        scroll_frame = tk.Frame(control_frame)
        scroll_frame.grid(row=1, column=1)

        # Button to scroll preview right
        scroll_right_button = tk.Button(
            scroll_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_sde)
        scroll_right_button.grid(
            row=1, column=2, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button to scroll preview left
        scroll_left_button = tk.Button(
            scroll_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_sde(-1))
        scroll_left_button.grid(
            row=1, column=1, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button for toggling more/less info to be displayed
        if self.more_info:
            more_info_btn_txt = &#39;Show less info&#39;
        else:
            more_info_btn_txt = &#39;Show more info&#39;
        self.more_info_btn = tk.Button(
            control_frame, text=more_info_btn_txt, width=14,
            command=self.toggle_more_info)
        self.more_info_btn.grid(row=2, column=1, padx=8, pady=5, sticky=&#39;n&#39;)

        ##############
        # Subframe for the &#39;big&#39; choices -- Restore / Apply / Delete
        ##############
        bc_padx = 16
        bc_ipadx = 4

        big_choices_frame = tk.Frame(control_frame)
        big_choices_frame.grid(row=1, column=2, padx=15, sticky=&#39;n&#39;)

        # Button to restore all descriptions (and SDE&#39;s) to their original
        # state, as of when this window was opened.
        restore_button = tk.Button(
            big_choices_frame, text=&#39;Restore All&#39;, height=2, padx=bc_ipadx,
            command=self.restore_clicked)
        restore_button.grid(row=1, column=3, padx=bc_padx, sticky=&#39;n&#39;)

        # Button to export saved results back to `master.plssdesc_list`
        # and optionally close this popup window
        export_button = tk.Button(
            big_choices_frame, text=&#39;Apply Changes to Plat&#39;,
            height=2, padx=bc_ipadx, command=self.export_to_master)
        export_button.grid(row=1, column=4, padx=bc_padx, sticky=&#39;n&#39;)

        # Button to delete current description
        delete_button = tk.Button(
            big_choices_frame, text=&#39;Delete This Description&#39;, height=2,
            padx=bc_ipadx, command=self.delete_desc_clicked)
        delete_button.grid(row=1, column=5, padx=bc_padx, sticky=&#39;n&#39;)

        ##############################
        # Currently Displayed SingleDescriptionEditor frame
        ##############################

        self.displayed_sde = None
        if len(self.editors) &gt; 0:
            self.displayed_sde_index = 0
            self.update_displayed_editor(0)
        self.update_header()

    def populate_editors(self):
        &#34;&#34;&#34;Populate a separate SingleDescriptionEditor object for each
        PLSSDesc object in `self.plssdesc_list`. Return the resulting
        list of SDE objects.&#34;&#34;&#34;
        editors = []
        for obj in self.plssdesc_list:
            sde = SingleDescriptionEditor(
                self, plssdesc_obj=obj, more_info=self.more_info)
            editors.append(sde)
        return editors

    def update_displayed_editor(self, index=None):
        &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
        `index`.&#34;&#34;&#34;
        if index is None:
            index = self.displayed_sde_index

        if index is None:
            # If still None, don&#39;t do anything else.
            return

        if self.displayed_sde is not None:
            # If we&#39;ve already displayed an sde, remove it from the grid now
            self.displayed_sde.grid_remove()

        # Set the new displayed_sde, and place it on the grid.
        self.displayed_sde = self.editors[index]
        self.displayed_sde.grid(
            row=DescriptionEditor.SDE_ROW,
            column=DescriptionEditor.SDE_COL,
            sticky=&#39;nwse&#39;)

    def scroll_sde(self, direction=1):
        &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        if self.displayed_sde_index is not None:
            self.displayed_sde_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        if len(self.editors) not in [None, 0]:
            self.displayed_sde_index %= len(self.editors)
        self.update_displayed_editor()
        self.update_header()

    def update_header(self):
        &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
        if self.displayed_sde_index is not None:
            header_txt = f&#34;{self.displayed_sde_index + 1} / {len(self.editors)}&#34;
        else:
            header_txt = &#34;[No descriptions to display.]&#34;
        self.header_lbl.config(text=header_txt)

    def toggle_more_info(self):
        &#34;&#34;&#34;Toggle whether `more_info` should be displayed, and enact the
        change for each SDE.&#34;&#34;&#34;
        self.more_info = not self.more_info

        for sde in self.editors:
            sde.set_more_info(self.more_info)
            sde.display_new_flags()
            sde.display_new_tracts()

        if self.more_info:
            text = &#39;Show less info&#39;
        else:
            text = &#39;Show more info&#39;
        self.more_info_btn.config(text=text)

    def collect_plssdesc_objects(self):
        &#34;&#34;&#34;Return a new list of the re-saved PLSSDesc objects.&#34;&#34;&#34;
        new_plssdesc_list = []
        for sde in self.editors:
            new_plssdesc_list.append(sde.cur_plssdesc_obj)
        return new_plssdesc_list

    def export_to_master(self):
        &#34;&#34;&#34;Collect the updated PLSSDesc objects in a new list, and set it
        to the plssdesc_list_owner&#39;s `.plssdesc_list`. Update the plat
        previews. And close this window.&#34;&#34;&#34;
        self.plssdesc_list_owner.plssdesc_list = self.collect_plssdesc_objects()
        try:
            self.plssdesc_list_owner.trigger_update_preview()
        except:
            pass

        self.destroy()

    def delete_desc_clicked(self):
        &#34;&#34;&#34;&#39;Delete&#39; the currently displayed SDE object. (In actuality,
        the SDE object will simply be removed from the `self.editors`
        list. As a result, the PLSSDesc object contained in said SDE
        will not be included when exporting back to owner -- but if this
        window is closed without exporting, this deletion will not have
        had any effect.)&#34;&#34;&#34;
        # Current index
        ind = self.displayed_sde_index

        if ind is None:
            return

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Delete&#39;, &#39;Delete this description?&#39;)
        self.focus()
        self.grab_set()

        if not confirm:
            return

        # Remove this SDE from the grid
        self.editors[ind].grid_remove()

        # Remove the SDE from the list of `editors`
        self.editors.pop(ind)

        # Set the index appropriately; and update the display, if there
        # are any left.
        if len(self.editors) == 0:
            self.displayed_sde_index = None
        else:
            self.displayed_sde_index %= len(self.editors)
            self.update_displayed_editor()

        # And update the header.
        self.update_header()

    def restore_clicked(self):
        &#34;&#34;&#34;Restore all PLSSDesc objects to how they were when this
        window was initialized (including un-deleting any).&#34;&#34;&#34;

        if len(self.plssdesc_list) == 0:
            return

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Restore&#39;,
            &#39;Discard all changes (including deletions) that have not &#39;
            &#39;yet been applied to the plat?&#39;)
        self.focus()
        self.grab_set()

        if not confirm:
            return

        for sde in self.editors:
            sde.destroy()

        self.editors = self.populate_editors()
        self.displayed_sde = None
        self.displayed_sde_index = None
        if len(self.editors) &gt; 0:
            self.displayed_sde_index = 0
        self.update_displayed_editor()

        self.update_header()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_COL"><code class="name">var <span class="ident">SDE_COL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_ROW"><code class="name">var <span class="ident">SDE_ROW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.collect_plssdesc_objects"><code class="name flex">
<span>def <span class="ident">collect_plssdesc_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new list of the re-saved PLSSDesc objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_plssdesc_objects(self):
    &#34;&#34;&#34;Return a new list of the re-saved PLSSDesc objects.&#34;&#34;&#34;
    new_plssdesc_list = []
    for sde in self.editors:
        new_plssdesc_list.append(sde.cur_plssdesc_obj)
    return new_plssdesc_list</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.delete_desc_clicked"><code class="name flex">
<span>def <span class="ident">delete_desc_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>'Delete' the currently displayed SDE object. (In actuality,
the SDE object will simply be removed from the <code>self.editors</code>
list. As a result, the PLSSDesc object contained in said SDE
will not be included when exporting back to owner &ndash; but if this
window is closed without exporting, this deletion will not have
had any effect.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_desc_clicked(self):
    &#34;&#34;&#34;&#39;Delete&#39; the currently displayed SDE object. (In actuality,
    the SDE object will simply be removed from the `self.editors`
    list. As a result, the PLSSDesc object contained in said SDE
    will not be included when exporting back to owner -- but if this
    window is closed without exporting, this deletion will not have
    had any effect.)&#34;&#34;&#34;
    # Current index
    ind = self.displayed_sde_index

    if ind is None:
        return

    confirm = tk.messagebox.askyesno(
        &#39;Confirm Delete&#39;, &#39;Delete this description?&#39;)
    self.focus()
    self.grab_set()

    if not confirm:
        return

    # Remove this SDE from the grid
    self.editors[ind].grid_remove()

    # Remove the SDE from the list of `editors`
    self.editors.pop(ind)

    # Set the index appropriately; and update the display, if there
    # are any left.
    if len(self.editors) == 0:
        self.displayed_sde_index = None
    else:
        self.displayed_sde_index %= len(self.editors)
        self.update_displayed_editor()

    # And update the header.
    self.update_header()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.export_to_master"><code class="name flex">
<span>def <span class="ident">export_to_master</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect the updated PLSSDesc objects in a new list, and set it
to the plssdesc_list_owner's <code>.plssdesc_list</code>. Update the plat
previews. And close this window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_master(self):
    &#34;&#34;&#34;Collect the updated PLSSDesc objects in a new list, and set it
    to the plssdesc_list_owner&#39;s `.plssdesc_list`. Update the plat
    previews. And close this window.&#34;&#34;&#34;
    self.plssdesc_list_owner.plssdesc_list = self.collect_plssdesc_objects()
    try:
        self.plssdesc_list_owner.trigger_update_preview()
    except:
        pass

    self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.populate_editors"><code class="name flex">
<span>def <span class="ident">populate_editors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Populate a separate SingleDescriptionEditor object for each
PLSSDesc object in <code>self.plssdesc_list</code>. Return the resulting
list of SDE objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_editors(self):
    &#34;&#34;&#34;Populate a separate SingleDescriptionEditor object for each
    PLSSDesc object in `self.plssdesc_list`. Return the resulting
    list of SDE objects.&#34;&#34;&#34;
    editors = []
    for obj in self.plssdesc_list:
        sde = SingleDescriptionEditor(
            self, plssdesc_obj=obj, more_info=self.more_info)
        editors.append(sde)
    return editors</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.restore_clicked"><code class="name flex">
<span>def <span class="ident">restore_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore all PLSSDesc objects to how they were when this
window was initialized (including un-deleting any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_clicked(self):
    &#34;&#34;&#34;Restore all PLSSDesc objects to how they were when this
    window was initialized (including un-deleting any).&#34;&#34;&#34;

    if len(self.plssdesc_list) == 0:
        return

    confirm = tk.messagebox.askyesno(
        &#39;Confirm Restore&#39;,
        &#39;Discard all changes (including deletions) that have not &#39;
        &#39;yet been applied to the plat?&#39;)
    self.focus()
    self.grab_set()

    if not confirm:
        return

    for sde in self.editors:
        sde.destroy()

    self.editors = self.populate_editors()
    self.displayed_sde = None
    self.displayed_sde_index = None
    if len(self.editors) &gt; 0:
        self.displayed_sde_index = 0
    self.update_displayed_editor()

    self.update_header()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.scroll_sde"><code class="name flex">
<span>def <span class="ident">scroll_sde</span></span>(<span>self, direction=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the SDE left or right. (1 -&gt; right;
-1 -&gt; left).
Defaults to scrolling right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_sde(self, direction=1):
    &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
    Defaults to scrolling right.&#34;&#34;&#34;
    if self.displayed_sde_index is not None:
        self.displayed_sde_index += direction

    # Wrap the index around, if it goes above or below the length
    # of our previews list.
    if len(self.editors) not in [None, 0]:
        self.displayed_sde_index %= len(self.editors)
    self.update_displayed_editor()
    self.update_header()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.toggle_more_info"><code class="name flex">
<span>def <span class="ident">toggle_more_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle whether <code>more_info</code> should be displayed, and enact the
change for each SDE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_more_info(self):
    &#34;&#34;&#34;Toggle whether `more_info` should be displayed, and enact the
    change for each SDE.&#34;&#34;&#34;
    self.more_info = not self.more_info

    for sde in self.editors:
        sde.set_more_info(self.more_info)
        sde.display_new_flags()
        sde.display_new_tracts()

    if self.more_info:
        text = &#39;Show less info&#39;
    else:
        text = &#39;Show more info&#39;
    self.more_info_btn.config(text=text)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.update_displayed_editor"><code class="name flex">
<span>def <span class="ident">update_displayed_editor</span></span>(<span>self, index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the SingleDescriptionEditor stored at the specified
<code>index</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_displayed_editor(self, index=None):
    &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
    `index`.&#34;&#34;&#34;
    if index is None:
        index = self.displayed_sde_index

    if index is None:
        # If still None, don&#39;t do anything else.
        return

    if self.displayed_sde is not None:
        # If we&#39;ve already displayed an sde, remove it from the grid now
        self.displayed_sde.grid_remove()

    # Set the new displayed_sde, and place it on the grid.
    self.displayed_sde = self.editors[index]
    self.displayed_sde.grid(
        row=DescriptionEditor.SDE_ROW,
        column=DescriptionEditor.SDE_COL,
        sticky=&#39;nwse&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.DescriptionEditor.update_header"><code class="name flex">
<span>def <span class="ident">update_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the label showing which index we're currently on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_header(self):
    &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
    if self.displayed_sde_index is not None:
        header_txt = f&#34;{self.displayed_sde_index + 1} / {len(self.editors)}&#34;
    else:
        header_txt = &#34;[No descriptions to display.]&#34;
    self.header_lbl.config(text=header_txt)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.FlagTable"><code class="flex name class">
<span>class <span class="ident">FlagTable</span></span>
<span>(</span><span>master=None, wflag_list=None, eflag_list=None, more_info=False, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame containing a table of warning/error flags from a parsed
pyTRS.PLSSDesc object.</p>
<p>:param more_info: Whether the user wants to display 'more info'.
In this case, all flag data is considered 'more info'.
:param wflag_list: The <code>.wFlagList</code> attribute from a
pyTRS.PLSSDesc object to display.
:param eflag_list: The <code>.eFlagList</code> attribute from a
pyTRS.PLSSDesc object to display.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlagTable(tk.Frame):
    &#34;&#34;&#34;A frame containing a table of warning/error flags from a parsed
    pyTRS.PLSSDesc object.&#34;&#34;&#34;

    flag_col_width = 35
    flag_wraplength = 240

    col_widths = [flag_col_width, flag_col_width]
    col_wraps = [flag_wraplength, flag_wraplength]

    def __init__(
            self, master=None, wflag_list=None, eflag_list=None,
            more_info=False, **kw):
        &#34;&#34;&#34;
        :param more_info: Whether the user wants to display &#39;more info&#39;.
        In this case, all flag data is considered &#39;more info&#39;.
        :param wflag_list: The `.wFlagList` attribute from a
        pyTRS.PLSSDesc object to display.
        :param eflag_list: The `.eFlagList` attribute from a
        pyTRS.PLSSDesc object to display.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master

        if not more_info:
            return

        if wflag_list is None:
            wflag_list = [&#39;None&#39;]
        elif len(wflag_list) == 0:
            wflag_list = [&#39;None&#39;]

        if eflag_list is None:
            eflag_list = [&#39;None&#39;]
        elif len(eflag_list) == 0:
            eflag_list = [&#39;None&#39;]

        headers = [&#39;Warning Flags&#39;, &#39;Error Flags&#39;]
        row_data = [&#39;, &#39;.join(wflag_list), &#39;, &#39;.join(eflag_list)]

        i = 0
        tr = TableRow(
            self, column_data=headers, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
        i += 1
        tr = TableRow(
            self, column_data=row_data, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.FlagTable.col_widths"><code class="name">var <span class="ident">col_widths</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.FlagTable.col_wraps"><code class="name">var <span class="ident">col_wraps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.FlagTable.flag_col_width"><code class="name">var <span class="ident">flag_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.FlagTable.flag_wraplength"><code class="name">var <span class="ident">flag_wraplength</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.FullPreviewWindow"><code class="flex name class">
<span>class <span class="ident">FullPreviewWindow</span></span>
<span>(</span><span>master=None, img=None, settings_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A popup window containing a full-size preview of the requested
plat page.</p>
<p>Construct a toplevel widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, menu, relief, screen, takefocus,
use, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FullPreviewWindow(tk.Toplevel):
    &#34;&#34;&#34;A popup window containing a full-size preview of the requested
    plat page.&#34;&#34;&#34;

    def __init__(self, master=None, img=None, settings_name=None):
        tk.Toplevel.__init__(self, master=master)
        self.master = master
        if settings_name is None:
            settings_name = &#39;&#39;
        else:
            settings_name = f&#39;   [settings: {settings_name}]&#39;
        self.title(f&#34;pyTRSplat - Page Preview{settings_name}&#34;)

        if img is None:
            self.destroy()
        else:
            display_window = ScrollResizeDisplay(self, img=img)
            display_window.grid(row=1, column=1, sticky=&#39;n&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LDTableRow"><code class="flex name class">
<span>class <span class="ident">LDTableRow</span></span>
<span>(</span><span>master=None, control_owner=None, column_data=None, col_widths=None, col_wraps=None, is_header=False, uid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A TableRow object with added "Edit" and "Delete" buttons, specific
to the lot definition editor.</p>
<p>All parameters are the same as for TableRow, except:
:param uid: The unique identifier for a lot (ex: '154n97w01_L1')
:param control_owner: The tkinter object that controls this obj,
and which has <code>.edit_btn_clicked()</code> and <code>.del_btn_clicked()</code>
methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LDTableRow(TableRow):
    &#34;&#34;&#34;
    A TableRow object with added &#34;Edit&#34; and &#34;Delete&#34; buttons, specific
    to the lot definition editor.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, control_owner=None, column_data=None,
            col_widths=None, col_wraps=None, is_header=False, uid=None):
        &#34;&#34;&#34;
        All parameters are the same as for TableRow, except:
        :param uid: The unique identifier for a lot (ex: &#39;154n97w01_L1&#39;)
        :param control_owner: The tkinter object that controls this obj,
        and which has `.edit_btn_clicked()` and `.del_btn_clicked()`
        methods.
        &#34;&#34;&#34;
        TableRow.__init__(
            self, master, column_data, col_widths, col_wraps, is_header,
            first_tk_col=2)
        self.uid = uid
        self.control_owner = control_owner

        if not is_header:
            ed_btn = tk.Button(
                self, text=&#39;Edit&#39;, width=5, command=self.edit_btn_clicked)
            del_btn = tk.Button(
                self, text=&#39;Delete&#39;, width=5, command=self.del_btn_clicked)
            ed_btn.grid(row=0, column=0, padx=4, sticky=&#39;ns&#39;)
            del_btn.grid(row=0, column=5, padx=4, sticky=&#39;ns&#39;)

    def edit_btn_clicked(self):
        self.control_owner.edit_btn_clicked(self.uid)

    def del_btn_clicked(self):
        self.control_owner.del_btn_clicked(self.uid)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.TableRow" href="#pyTRSplat.pyTRSplat_app.TableRow">TableRow</a></li>
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LDTableRow.del_btn_clicked"><code class="name flex">
<span>def <span class="ident">del_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_btn_clicked(self):
    self.control_owner.del_btn_clicked(self.uid)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LDTableRow.edit_btn_clicked"><code class="name flex">
<span>def <span class="ident">edit_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_btn_clicked(self):
    self.control_owner.edit_btn_clicked(self.uid)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor"><code class="flex name class">
<span>class <span class="ident">LotDefEditor</span></span>
<span>(</span><span>master=None, top_owner=None, target_lddb=None, lots=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame for viewing, editing, and deleting LotDefinitions.</p>
<p>:param top_owner: The main application, which contains a
.trigger_update_preview() method.
:param target_lddb: A LotDefDB object that should be modified.
:param lots: A dict, keyed by TRS (e.g., '154n9701'), and whose
values are a list of lots that should be viewed. See example:
sample_lots = {
'154n97w25': ['L5', 'L8'],
'154n97w01': ['L1', 'L3'],
'155n97w04': ['L1', 'L2', 'L3', 'L4']
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LotDefEditor(tk.Toplevel):
    &#34;&#34;&#34;
    A frame for viewing, editing, and deleting LotDefinitions.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, top_owner=None, target_lddb=None, lots=None):
        &#34;&#34;&#34;
        :param top_owner: The main application, which contains a
        .trigger_update_preview() method.
        :param target_lddb: A LotDefDB object that should be modified.
        :param lots: A dict, keyed by TRS (e.g., &#39;154n9701&#39;), and whose
        values are a list of lots that should be viewed. See example:
            sample_lots = {
                &#39;154n97w25&#39;: [&#39;L5&#39;, &#39;L8&#39;],
                &#39;154n97w01&#39;: [&#39;L1&#39;, &#39;L3&#39;],
                &#39;155n97w04&#39;: [&#39;L1&#39;, &#39;L2&#39;, &#39;L3&#39;, &#39;L4&#39;]
            }
        &#34;&#34;&#34;
        tk.Toplevel.__init__(self, master)
        self.master = master
        self.target_lddb = target_lddb
        self.lots = lots.copy()
        self.orig_lots = lots
        self.top_owner = top_owner

        # The current LotDefEditor (if any).
        self.lde = None

        control_frm = tk.Frame(self)
        control_frm.grid(row=0, column=0, sticky=&#39;ns&#39;)

        define_all_btn = tk.Button(
            control_frm, text=&#39;Define All Remaining Lots&#39;,
            command=self.define_all_lots)
        define_all_btn.grid(row=0, column=1, padx=4, pady=4, sticky=&#39;ns&#39;)

        display_entire_lddb_btn = tk.Button(
            control_frm, text=&#39;Display All (SLOW)&#39;,
            command=self.toggle_all_lddb)
        display_entire_lddb_btn.grid(
            row=0, column=2, padx=4, pady=4, sticky=&#39;ns&#39;)

        del_btn = tk.Button(
            control_frm, text=&#39;Delete All Lot Definitions&#39;,
            command=self.del_btn_clicked)
        del_btn.grid(row=0, column=3, padx=4, pady=4, sticky=&#39;ns&#39;)

        close_btn = tk.Button(
            control_frm, text=&#39;Close Editor&#39;, command=self.close_btn_clicked)
        close_btn.grid(row=0, column=4, padx=4, pady=4, sticky=&#39;ns&#39;)

        # Our LotDefTable object, which will be populated shortly.
        self.table = None

        # Where to place the table in the grid
        self.table_row = 1
        self.table_column = 0

        # Populate the table.
        self.gen_new_table()

    def toggle_all_lddb(self):
        &#34;&#34;&#34;
        Include the entirety of the LotDefDB in the table.
        &#34;&#34;&#34;
        confirm = tk.messagebox.askokcancel(
            &#39;WARNING&#39;,
            &#34;Viewing ALL lot definitions can be very slow if there are &#34;
            &#34;too many defined lots. It may be more efficient to view and edit &#34;
            &#34;numerous lot definitions externally in a .csv file, and then load &#34;
            &#34;that file here.\n\n&#34;
            &#34;Display all lots now?&#34;)

        self.focus()

        if not confirm:
            return None

        for twprge, tld in self.target_lddb.items():
            for sec, ld in tld.items():
                trs = f&#34;{twprge}{str(sec).rjust(2, &#39;0&#39;)}&#34;
                self.lots.setdefault(trs, [])
                lots = list(ld.keys())
                for lot in lots:
                    if lot not in self.lots[trs]:
                        self.lots[trs].append(lot)
        self.gen_new_table()

    def del_btn_clicked(self):
        &#34;&#34;&#34;
        Remove all items from the LotDefDB. (Does not actually destroy
        the dict values; just pops their keys from the dict.)
        &#34;&#34;&#34;
        confirm = tk.messagebox.askokcancel(
            &#39;Are you sure?&#39;, &#34;Delete ALL current lot definitions?&#34;)

        self.focus()

        if not confirm:
            return None

        for i in range(len(self.target_lddb.keys())):
            self.target_lddb.pop(list(self.target_lddb.keys())[0], None)

        self.lots = self.orig_lots.copy()

        self.gen_new_table()

        self.top_owner.trigger_update_preview()

    def close_btn_clicked(self):
        self.destroy()

    def gen_new_table(self):
        &#34;&#34;&#34;
        Generate a new LotDefTable for the lots.
        &#34;&#34;&#34;
        try:
            self.table.destroy()
        except:
            pass

        self.table = LotDefTable(
            self, top_owner=self.top_owner, lots=self.lots,
            target_lddb=self.target_lddb)
        self.table.grid(
            row=self.table_row, column=self.table_column, sticky=&#39;nesw&#39;,
            padx=5, pady=5)

    def define_all_lots(self):
        &#34;&#34;&#34;
        Define any lots that have not already been defined, one-by-one.
        &#34;&#34;&#34;

        def no_lots():
            messagebox.showinfo(
                &#39;No lots to define&#39;,
                &#34;All lots have been defined. Click the respective edit buttons &#34;
                &#34;to re-define lots.&#34;
            )

        try:
            self.lde.destroy()
        except:
            pass

        if self.table is None:
            no_lots()
            return

        ld_dict = self.table.ld_dict
        if ld_dict is None:
            no_lots()
            return

        # Extract unhandled lots from the ld_dict (generated in the
        # LotDefTable object)
        uhl = {}
        for k, v in ld_dict.items():
            if v[&#39;definition&#39;] != &#39;Undefined&#39;:
                continue
            trs = v[&#39;trs&#39;]
            lot = v[&#39;lot&#39;]
            uhl.setdefault(trs, [])
            uhl[trs].append(lot)

        if len(uhl) == 0:
            no_lots()
            return

        self.lde = LotDefEditor.TableSeriesDefiner(
            self, top_owner=self.top_owner, target_lddb=self.target_lddb,
            lots_to_define=uhl)

    class TableSeriesDefiner(SeriesLotDefiner):
        &#34;&#34;&#34;
        A SeriesLotDefiner with slightly modified behavior for cancel
        and after completion.
        &#34;&#34;&#34;

        def __init__(
                self, master=None, top_owner=None, target_lddb=None,
                lots_to_define=None):
            SeriesLotDefiner.__init__(
                self, master=master, top_owner=top_owner,
                target_lddb=target_lddb, lots_to_define=lots_to_define)

            # A bit hack-ish, but remove the &#34;Leave Undefined&#34; button.
            self.cur_definer.leaveit_btn.grid_forget()

            # These methods have the same functionality for this object.
            self.canceled = self.done

        def done(self):
            self.master.gen_new_table()
            try:
                self.top_owner.trigger_update_preview()
            except:
                pass
            self.destroy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.TableSeriesDefiner"><code class="name">var <span class="ident">TableSeriesDefiner</span></code></dt>
<dd>
<div class="desc"><p>A SeriesLotDefiner with slightly modified behavior for cancel
and after completion.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.close_btn_clicked"><code class="name flex">
<span>def <span class="ident">close_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_btn_clicked(self):
    self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.define_all_lots"><code class="name flex">
<span>def <span class="ident">define_all_lots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define any lots that have not already been defined, one-by-one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_all_lots(self):
    &#34;&#34;&#34;
    Define any lots that have not already been defined, one-by-one.
    &#34;&#34;&#34;

    def no_lots():
        messagebox.showinfo(
            &#39;No lots to define&#39;,
            &#34;All lots have been defined. Click the respective edit buttons &#34;
            &#34;to re-define lots.&#34;
        )

    try:
        self.lde.destroy()
    except:
        pass

    if self.table is None:
        no_lots()
        return

    ld_dict = self.table.ld_dict
    if ld_dict is None:
        no_lots()
        return

    # Extract unhandled lots from the ld_dict (generated in the
    # LotDefTable object)
    uhl = {}
    for k, v in ld_dict.items():
        if v[&#39;definition&#39;] != &#39;Undefined&#39;:
            continue
        trs = v[&#39;trs&#39;]
        lot = v[&#39;lot&#39;]
        uhl.setdefault(trs, [])
        uhl[trs].append(lot)

    if len(uhl) == 0:
        no_lots()
        return

    self.lde = LotDefEditor.TableSeriesDefiner(
        self, top_owner=self.top_owner, target_lddb=self.target_lddb,
        lots_to_define=uhl)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.del_btn_clicked"><code class="name flex">
<span>def <span class="ident">del_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all items from the LotDefDB. (Does not actually destroy
the dict values; just pops their keys from the dict.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_btn_clicked(self):
    &#34;&#34;&#34;
    Remove all items from the LotDefDB. (Does not actually destroy
    the dict values; just pops their keys from the dict.)
    &#34;&#34;&#34;
    confirm = tk.messagebox.askokcancel(
        &#39;Are you sure?&#39;, &#34;Delete ALL current lot definitions?&#34;)

    self.focus()

    if not confirm:
        return None

    for i in range(len(self.target_lddb.keys())):
        self.target_lddb.pop(list(self.target_lddb.keys())[0], None)

    self.lots = self.orig_lots.copy()

    self.gen_new_table()

    self.top_owner.trigger_update_preview()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.gen_new_table"><code class="name flex">
<span>def <span class="ident">gen_new_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a new LotDefTable for the lots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_new_table(self):
    &#34;&#34;&#34;
    Generate a new LotDefTable for the lots.
    &#34;&#34;&#34;
    try:
        self.table.destroy()
    except:
        pass

    self.table = LotDefTable(
        self, top_owner=self.top_owner, lots=self.lots,
        target_lddb=self.target_lddb)
    self.table.grid(
        row=self.table_row, column=self.table_column, sticky=&#39;nesw&#39;,
        padx=5, pady=5)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefEditor.toggle_all_lddb"><code class="name flex">
<span>def <span class="ident">toggle_all_lddb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Include the entirety of the LotDefDB in the table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_all_lddb(self):
    &#34;&#34;&#34;
    Include the entirety of the LotDefDB in the table.
    &#34;&#34;&#34;
    confirm = tk.messagebox.askokcancel(
        &#39;WARNING&#39;,
        &#34;Viewing ALL lot definitions can be very slow if there are &#34;
        &#34;too many defined lots. It may be more efficient to view and edit &#34;
        &#34;numerous lot definitions externally in a .csv file, and then load &#34;
        &#34;that file here.\n\n&#34;
        &#34;Display all lots now?&#34;)

    self.focus()

    if not confirm:
        return None

    for twprge, tld in self.target_lddb.items():
        for sec, ld in tld.items():
            trs = f&#34;{twprge}{str(sec).rjust(2, &#39;0&#39;)}&#34;
            self.lots.setdefault(trs, [])
            lots = list(ld.keys())
            for lot in lots:
                if lot not in self.lots[trs]:
                    self.lots[trs].append(lot)
    self.gen_new_table()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable"><code class="flex name class">
<span>class <span class="ident">LotDefTable</span></span>
<span>(</span><span>master=None, top_owner=None, lots=None, target_lddb=None, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame containing a table of LotDefinitions and edit/delete
buttons.</p>
<p>:param lots: A dict, keyed by TRS (e.g., '154n9701'), and whose
values are a list of lots that should be viewed. See example:
sample_lots = {
'154n97w25': ['L5', 'L8'],
'154n97w01': ['L1', 'L3'],
'155n97w04': ['L1', 'L2', 'L3', 'L4']
}</p>
<p>Note: This is the same structure as an 'unhandled lots' dict
generated by the <code>MultiPlat.all_unhandled_lots</code> property.
:param target_lddb: The LotDefDB object whose definitions should
be displayed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LotDefTable(tk.Frame):
    &#34;&#34;&#34;
    A frame containing a table of LotDefinitions and edit/delete
    buttons.
    &#34;&#34;&#34;

    trs_col_width = 12
    lot_name_col_width = 6
    ld_col_width = 35
    ld_wraplength = 240
    col_width = [trs_col_width, lot_name_col_width, ld_col_width]
    col_wrap = [None, None, ld_wraplength]
    max_rows_per_page = 15

    # The tk grid column in the LotDefTable frame holding TableRow objs
    tbrow_col = 2

    def __init__(
            self, master=None, top_owner=None, lots=None, target_lddb=None,
            **kw):
        &#34;&#34;&#34;
        :param lots: A dict, keyed by TRS (e.g., &#39;154n9701&#39;), and whose
        values are a list of lots that should be viewed. See example:
            sample_lots = {
                &#39;154n97w25&#39;: [&#39;L5&#39;, &#39;L8&#39;],
                &#39;154n97w01&#39;: [&#39;L1&#39;, &#39;L3&#39;],
                &#39;155n97w04&#39;: [&#39;L1&#39;, &#39;L2&#39;, &#39;L3&#39;, &#39;L4&#39;]
            }

        Note: This is the same structure as an &#39;unhandled lots&#39; dict
        generated by the `MultiPlat.all_unhandled_lots` property.
        :param target_lddb: The LotDefDB object whose definitions should
        be displayed.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master
        self.btn = tk.Button(text=&#39;Edit&#39;)

        if top_owner is None:
            top_owner = master
        self.top_owner = top_owner

        ###################3
        # Scroll frame

        control_frame = tk.Frame(self)
        control_frame.grid(row=0, column=1)

        # Subframe for left/right scrol
        scroll_frame = tk.Frame(control_frame)
        scroll_frame.grid(row=1, column=1)

        self.header_lbl = tk.Label(control_frame, text=&#39;&#39;)
        self.header_lbl.grid(row=0, column=1)

        # Button to scroll preview right
        scroll_right_button = tk.Button(
            scroll_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_page)
        scroll_right_button.grid(
            row=1, column=2, padx=8, pady=2, sticky=&#39;n&#39;)

        # Button to scroll preview left
        scroll_left_button = tk.Button(
            scroll_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_page(-1))
        scroll_left_button.grid(
            row=1, column=1, padx=8, pady=2, sticky=&#39;n&#39;)

        ##################
        # Gen pages
        ##################

        # A dict of pages (i.e. Frames), one of which is displayed at a time;
        # keyed by incremented ints, starting at 0
        self.pages = {}
        # The index of the currently displayed page.
        self.page_index = None
        # The current page (Frame) itself.
        self.current_page = None

        self.display_frame = tk.Frame(self)
        self.display_frame.grid(row=2, column=1, sticky=&#39;nesw&#39;)

        # A dict for keeping track of each TableRow, which lot definitions
        # it corresponds to, where to find it in the tk grid, etc. Keyed
        # by unique ID in the format of TRS_lotnumber (ex: &#39;154n97w01_L1&#39;)
        self.ld_dict = {}

        # The current LotRefiner object (if any)
        self.current_redefiner = None

        # Width and wrap configs for the table display

        if lots is None:
            lots = {}

        if target_lddb is None:
            target_lddb = LotDefDB()

        self.target_lddb = target_lddb

        uid_list = []

        def gen_header(page_num: int):
            &#34;&#34;&#34;
            Generate a header for a new page.
            &#34;&#34;&#34;

            uid = f&#34;headers_{page_num}&#34;
            header_data = [&#39;Twp/Rge/Sec&#39;, &#39;Lot&#39;, &#39;Definition&#39;]
            self.ld_dict[uid] = {}
            self.ld_dict[uid][&#39;row_data&#39;] = header_data
            self.ld_dict[uid][&#39;row_num&#39;] = 0
            self.ld_dict[uid][&#39;definition&#39;] = &#39;na_headers&#39;
            self.ld_dict[uid][&#39;page&#39;] = page_num
            uid_list.append(uid)

        i = 0
        for trs, lot_list in lots.items():
            ld = self.target_lddb.trs(trs)
            for lot in lot_list:
                definition = &#39;Undefined&#39;
                if ld is not None:
                    definition = ld.get(lot, &#39;Undefined&#39;)
                # &#39;unique ID&#39; to serve as dict key -- i.e. &#39;154n97w01_L1&#39;
                uid = f&#34;{trs}_{lot}&#34;
                uid_list.append(uid)

                twp, rge, sec = pyTRS.break_trs(trs)
                try:
                    sec = int(sec)
                except ValueError:
                    sec = 0

                self.ld_dict[uid] = {}
                self.ld_dict[uid][&#39;ld&#39;] = ld
                self.ld_dict[uid][&#39;row_data&#39;] = [trs, lot, definition]
                self.ld_dict[uid][&#39;row_num&#39;] = i % LotDefTable.max_rows_per_page + 1
                self.ld_dict[uid][&#39;page&#39;] = i // LotDefTable.max_rows_per_page
                self.ld_dict[uid][&#39;twprge&#39;] = twp + rge
                self.ld_dict[uid][&#39;sec&#39;] = sec
                self.ld_dict[uid][&#39;trs&#39;] = trs
                self.ld_dict[uid][&#39;lot&#39;] = lot
                self.ld_dict[uid][&#39;definition&#39;] = definition
                i += 1

        # Subtract the last one for an accurate total.
        i -= 1

        for page_num in range(i//LotDefTable.max_rows_per_page + 1):
            gen_header(page_num)
            new_frame = tk.Frame(self.display_frame)
            self.pages[page_num] = new_frame

        start_row = 2
        for uid in uid_list:
            # Generate a LDTableRow for each
            table_row_num = self.ld_dict[uid][&#39;row_num&#39;]
            self.ld_dict[uid][&#39;grid_row&#39;] = table_row_num + start_row
            self.ld_dict[uid][&#39;grid_col&#39;] = self.tbrow_col
            self.gen_tablerow(uid)

        if len(self.pages) &gt; 0:
            self.page_index = 0
            self.update_displayed_page()

    def scroll_page(self, direction=1):
        &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        if self.page_index is not None:
            self.page_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        if len(self.pages) not in [None, 0]:
            self.page_index %= len(self.pages)
        self.update_displayed_page()

    def update_displayed_page(self, page_index=None):
        &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
        `index`.&#34;&#34;&#34;
        if page_index is None:
            page_index = self.page_index

        if page_index is None:
            # If still None, don&#39;t do anything else.
            return

        if self.current_page is not None:
            # If we&#39;ve already displayed an sde, remove it from the grid now
            self.current_page.grid_remove()

        # Set the new page, and place it on the grid.
        self.current_page = self.pages[page_index]
        self.current_page.grid( row=0, column=0, sticky=&#39;nwse&#39;)
        self.update_header()

    def update_header(self):
        &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
        if self.page_index is not None:
            header_txt = f&#34;{self.page_index + 1} / {len(self.pages)}&#34;
        else:
            header_txt = &#34;[No lots to display.]&#34;
        self.header_lbl.config(text=header_txt)

    def gen_tablerow(self, uid, page=None, row_data=None):
        &#34;&#34;&#34;
        Generate a row in the table for the lot definition represented
        by the unique ID `uid`.
        :param uid: The unique ID of a lot, i.e. a key in `self.ld_dict`
        :param row_data: A list of strings to write for this row. (Leave
        unspecified, unless updating this row. If not specified, will
        use the data previously generated, e.g., at init.)
        &#34;&#34;&#34;
        if row_data is None:
            row_data = self.ld_dict[uid][&#39;row_data&#39;]
        if page is None:
            page = self.ld_dict[uid][&#39;page&#39;]
        is_header = self.ld_dict[uid][&#39;row_num&#39;] == 0
        row = self.ld_dict[uid][&#39;row_num&#39;]
        col = self.ld_dict[uid][&#39;grid_col&#39;]
        self.ld_dict[uid][&#39;tablerow&#39;] = LDTableRow(
            master=self.pages[page], control_owner=self, column_data=row_data,
            col_widths=self.col_width,
            col_wraps=self.col_wrap, is_header=is_header, uid=uid)
        self.ld_dict[uid][&#39;tablerow&#39;].grid(row=row, column=col, sticky=&#39;ns&#39;)

    def edit_btn_clicked(self, uid):
        &#34;&#34;&#34;
        Launch an editor for a target lot.

        :param uid: A key from `self.ld_dict`.
        &#34;&#34;&#34;
        # Close the current redefiner, if any.
        try:
            self.current_redefiner.destroy()
        except:
            pass

        # Launch a new redefiner for this lot.
        self.current_redefiner = LotRedefiner(
            self, target_lddb=self.target_lddb, trs=self.ld_dict[uid][&#39;trs&#39;],
            lot=self.ld_dict[uid][&#39;lot&#39;], top_owner=self.top_owner, uid=uid)

    def del_btn_clicked(self, uid):
        &#34;&#34;&#34;
        Delete the lot definition for this lot from the LDDB.
        &#34;&#34;&#34;

        trs = self.ld_dict[uid][&#39;trs&#39;]
        lot = self.ld_dict[uid][&#39;lot&#39;]
        cur_definition = self.ld_dict[uid][&#39;definition&#39;]
        ld = self.target_lddb.trs(trs)
        if ld is None or cur_definition == &#39;Undefined&#39;:
            return None

        confirm = tk.messagebox.askokcancel(
            &#39;Are you sure?&#39;,
            f&#34;Delete lot definition for {trs}: {lot}?&#34;
        )

        self.focus()

        if not confirm:
            return None

        # Remove this key from the ld
        ld.pop(lot, None)

        # If there are no more lots for this section in the LotDefinitions,
        # let&#39;s remove the LotDefinitions from the LDDB (which would optionally
        # allow default lot definitions to take over).
        if len(ld.keys()) == 0:
            twprge = self.ld_dict[uid][&#39;twprge&#39;]
            sec = self.ld_dict[uid][&#39;sec&#39;]
            tld = self.target_lddb.get_tld(twprge)
            # tld should never be None here, but just in case...
            if tld is not None:
                # Remove this section as key.
                tld.pop(sec, None)

        self.ld_dict[uid][&#39;row_data&#39;] = [trs, lot, &#39;Undefined&#39;]
        self.update_table(uid)
        self.top_owner.trigger_update_preview()

    def update_table(self, uid):
        &#34;&#34;&#34;
        Update the displayed table with the new definitions for the lot
        represented by the unique ID `uid`.
        &#34;&#34;&#34;
        self.ld_dict[uid][&#39;tablerow&#39;].destroy()
        d = self.ld_dict[uid]
        trs = d[&#39;trs&#39;]
        lot = d[&#39;lot&#39;]
        sec_num = d[&#39;sec&#39;]
        definition = &#39;Undefined&#39;

        tld = self.target_lddb.get_tld(d[&#39;twprge&#39;], force_tld_return=False)
        if tld is not None:
            ld = tld.get_ld(sec_num, force_ld_return=True)
            definition = ld.get(lot, &#39;Undefined&#39;)

        new_row_data = [trs, lot, definition]
        self.ld_dict[uid][&#39;row_data&#39;] = new_row_data
        self.ld_dict[uid][&#39;definition&#39;] = definition
        self.gen_tablerow(uid, row_data=new_row_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.col_width"><code class="name">var <span class="ident">col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.col_wrap"><code class="name">var <span class="ident">col_wrap</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.ld_col_width"><code class="name">var <span class="ident">ld_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.ld_wraplength"><code class="name">var <span class="ident">ld_wraplength</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.lot_name_col_width"><code class="name">var <span class="ident">lot_name_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.max_rows_per_page"><code class="name">var <span class="ident">max_rows_per_page</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.tbrow_col"><code class="name">var <span class="ident">tbrow_col</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.trs_col_width"><code class="name">var <span class="ident">trs_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.del_btn_clicked"><code class="name flex">
<span>def <span class="ident">del_btn_clicked</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the lot definition for this lot from the LDDB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_btn_clicked(self, uid):
    &#34;&#34;&#34;
    Delete the lot definition for this lot from the LDDB.
    &#34;&#34;&#34;

    trs = self.ld_dict[uid][&#39;trs&#39;]
    lot = self.ld_dict[uid][&#39;lot&#39;]
    cur_definition = self.ld_dict[uid][&#39;definition&#39;]
    ld = self.target_lddb.trs(trs)
    if ld is None or cur_definition == &#39;Undefined&#39;:
        return None

    confirm = tk.messagebox.askokcancel(
        &#39;Are you sure?&#39;,
        f&#34;Delete lot definition for {trs}: {lot}?&#34;
    )

    self.focus()

    if not confirm:
        return None

    # Remove this key from the ld
    ld.pop(lot, None)

    # If there are no more lots for this section in the LotDefinitions,
    # let&#39;s remove the LotDefinitions from the LDDB (which would optionally
    # allow default lot definitions to take over).
    if len(ld.keys()) == 0:
        twprge = self.ld_dict[uid][&#39;twprge&#39;]
        sec = self.ld_dict[uid][&#39;sec&#39;]
        tld = self.target_lddb.get_tld(twprge)
        # tld should never be None here, but just in case...
        if tld is not None:
            # Remove this section as key.
            tld.pop(sec, None)

    self.ld_dict[uid][&#39;row_data&#39;] = [trs, lot, &#39;Undefined&#39;]
    self.update_table(uid)
    self.top_owner.trigger_update_preview()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.edit_btn_clicked"><code class="name flex">
<span>def <span class="ident">edit_btn_clicked</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch an editor for a target lot.</p>
<p>:param uid: A key from <code>self.ld_dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_btn_clicked(self, uid):
    &#34;&#34;&#34;
    Launch an editor for a target lot.

    :param uid: A key from `self.ld_dict`.
    &#34;&#34;&#34;
    # Close the current redefiner, if any.
    try:
        self.current_redefiner.destroy()
    except:
        pass

    # Launch a new redefiner for this lot.
    self.current_redefiner = LotRedefiner(
        self, target_lddb=self.target_lddb, trs=self.ld_dict[uid][&#39;trs&#39;],
        lot=self.ld_dict[uid][&#39;lot&#39;], top_owner=self.top_owner, uid=uid)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.gen_tablerow"><code class="name flex">
<span>def <span class="ident">gen_tablerow</span></span>(<span>self, uid, page=None, row_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a row in the table for the lot definition represented
by the unique ID <code>uid</code>.
:param uid: The unique ID of a lot, i.e. a key in <code>self.ld_dict</code>
:param row_data: A list of strings to write for this row. (Leave
unspecified, unless updating this row. If not specified, will
use the data previously generated, e.g., at init.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_tablerow(self, uid, page=None, row_data=None):
    &#34;&#34;&#34;
    Generate a row in the table for the lot definition represented
    by the unique ID `uid`.
    :param uid: The unique ID of a lot, i.e. a key in `self.ld_dict`
    :param row_data: A list of strings to write for this row. (Leave
    unspecified, unless updating this row. If not specified, will
    use the data previously generated, e.g., at init.)
    &#34;&#34;&#34;
    if row_data is None:
        row_data = self.ld_dict[uid][&#39;row_data&#39;]
    if page is None:
        page = self.ld_dict[uid][&#39;page&#39;]
    is_header = self.ld_dict[uid][&#39;row_num&#39;] == 0
    row = self.ld_dict[uid][&#39;row_num&#39;]
    col = self.ld_dict[uid][&#39;grid_col&#39;]
    self.ld_dict[uid][&#39;tablerow&#39;] = LDTableRow(
        master=self.pages[page], control_owner=self, column_data=row_data,
        col_widths=self.col_width,
        col_wraps=self.col_wrap, is_header=is_header, uid=uid)
    self.ld_dict[uid][&#39;tablerow&#39;].grid(row=row, column=col, sticky=&#39;ns&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.scroll_page"><code class="name flex">
<span>def <span class="ident">scroll_page</span></span>(<span>self, direction=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the SDE left or right. (1 -&gt; right;
-1 -&gt; left).
Defaults to scrolling right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page(self, direction=1):
    &#34;&#34;&#34;Scroll the SDE left or right. (1 -&gt; right;  -1 -&gt; left).
    Defaults to scrolling right.&#34;&#34;&#34;
    if self.page_index is not None:
        self.page_index += direction

    # Wrap the index around, if it goes above or below the length
    # of our previews list.
    if len(self.pages) not in [None, 0]:
        self.page_index %= len(self.pages)
    self.update_displayed_page()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.update_displayed_page"><code class="name flex">
<span>def <span class="ident">update_displayed_page</span></span>(<span>self, page_index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the SingleDescriptionEditor stored at the specified
<code>index</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_displayed_page(self, page_index=None):
    &#34;&#34;&#34;Display the SingleDescriptionEditor stored at the specified
    `index`.&#34;&#34;&#34;
    if page_index is None:
        page_index = self.page_index

    if page_index is None:
        # If still None, don&#39;t do anything else.
        return

    if self.current_page is not None:
        # If we&#39;ve already displayed an sde, remove it from the grid now
        self.current_page.grid_remove()

    # Set the new page, and place it on the grid.
    self.current_page = self.pages[page_index]
    self.current_page.grid( row=0, column=0, sticky=&#39;nwse&#39;)
    self.update_header()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.update_header"><code class="name flex">
<span>def <span class="ident">update_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the label showing which index we're currently on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_header(self):
    &#34;&#34;&#34;Update the label showing which index we&#39;re currently on.&#34;&#34;&#34;
    if self.page_index is not None:
        header_txt = f&#34;{self.page_index + 1} / {len(self.pages)}&#34;
    else:
        header_txt = &#34;[No lots to display.]&#34;
    self.header_lbl.config(text=header_txt)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotDefTable.update_table"><code class="name flex">
<span>def <span class="ident">update_table</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the displayed table with the new definitions for the lot
represented by the unique ID <code>uid</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_table(self, uid):
    &#34;&#34;&#34;
    Update the displayed table with the new definitions for the lot
    represented by the unique ID `uid`.
    &#34;&#34;&#34;
    self.ld_dict[uid][&#39;tablerow&#39;].destroy()
    d = self.ld_dict[uid]
    trs = d[&#39;trs&#39;]
    lot = d[&#39;lot&#39;]
    sec_num = d[&#39;sec&#39;]
    definition = &#39;Undefined&#39;

    tld = self.target_lddb.get_tld(d[&#39;twprge&#39;], force_tld_return=False)
    if tld is not None:
        ld = tld.get_ld(sec_num, force_ld_return=True)
        definition = ld.get(lot, &#39;Undefined&#39;)

    new_row_data = [trs, lot, definition]
    self.ld_dict[uid][&#39;row_data&#39;] = new_row_data
    self.ld_dict[uid][&#39;definition&#39;] = definition
    self.gen_tablerow(uid, row_data=new_row_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotRedefiner"><code class="flex name class">
<span>class <span class="ident">LotRedefiner</span></span>
<span>(</span><span>master=None, top_owner=None, target_lddb=None, trs=None, lot=0, uid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for RE-defining lots already in a LotDefDB object.</p>
<p>:param top_owner: The main application, which contains a
.trigger_update_preview() method.
:param target_lddb: A LotDefDB object that should be modified.
:param lots_to_define: A dict, specifying which lots need to be
defined, in this format:
<trs key> -&gt; <list of lots>
ex: {'154n97w01': ['L1, 'L2'], '154n97w02': ['L1', 'L3']}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LotRedefiner(SeriesLotDefiner):
    &#34;&#34;&#34;
    A class for RE-defining lots already in a LotDefDB object.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, top_owner=None, target_lddb=None,
            trs=None, lot=0, uid=None):
        lots_to_define = {trs: [lot]}
        SeriesLotDefiner.__init__(
            self, master=master, top_owner=top_owner, target_lddb=target_lddb,
            lots_to_define=lots_to_define)

        # A bit hack-ish, but remove the &#34;Leave Undefined&#34; button.
        self.cur_definer.leaveit_btn.grid_forget()

        self.uid = uid

    def done(self):
        if hasattr(self.master, &#39;update_table&#39;):
            self.master.update_table(self.uid)
        self.destroy()

    def canceled(self):
        self.destroy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.SeriesLotDefiner" href="#pyTRSplat.pyTRSplat_app.SeriesLotDefiner">SeriesLotDefiner</a></li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.LotRedefiner.canceled"><code class="name flex">
<span>def <span class="ident">canceled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canceled(self):
    self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.LotRedefiner.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self):
    if hasattr(self.master, &#39;update_table&#39;):
        self.master.update_table(self.uid)
    self.destroy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>Toplevel widget of Tk which represents mostly the main window
of an application. It has an associated Tcl interpreter.</p>
<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
be created. BASENAME will be used for the identification of the profile file (see
readprofile).
It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
is the name of the widget class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(tk.Tk):

    def __init__(self):
        tk.Tk.__init__(self)
        self.title(&#39;pyTRSplat - Text-to-Plat Generator&#39;)

        # Store an empty LotDefDB object as `.lddb`
        self.lddb = LotDefDB()

        # Store (initially empty) queue of ad-hoc objects to be added to
        # the plat(s) -- e.g. SectionGrid, TownshipGrid, etc.
        self.ad_hoc_mpq = MultiPlatQueue()

        # Store a plain list (currently empty) of PLSSDesc objects that
        # will be platted
        self.plssdesc_list = []

        # A tab-notebook for switching between adding descriptions and
        # manually adding QQ&#39;s
        self.adder_tabs = tk.ttk.Notebook(self)
        self.adder_tabs.grid(row=1, column=1)

        # A widget for entering land descriptions, configuring parse,
        # loading LotDefDB, etc.
        self.desc_frame = DescFrame(master=self)
        self.adder_tabs.add(
            self.desc_frame, text=&#39;Add lands by description text&#39;)

        # A widget for adding QQ&#39;s manually (into `.ad_hoc_mpq`)
        self.manual_platter = ManualPlatter(
            master=self, mpq_owner=self)
        self.adder_tabs.add(self.manual_platter, text=&#34;Add QQ&#39;s manually&#34;)

        right_side_frame = tk.Frame(self)
        right_side_frame.grid(row=1, column=2, sticky=&#39;ns&#39;)

        # A widget for displaying a mini preview of the plat so far
        self.preview_frame = PlatPreview(right_side_frame, preview_owner=self)
        self.preview_frame.grid(row=1, column=2, sticky=&#39;n&#39;)

        # A widget for output settings / buttons. (Contains the plat
        # generator at `.output_frame.gen_plat()`
        self.output_frame = OutputFrame(right_side_frame, output_owner=self)
        self.output_frame.grid(row=2, column=2, pady=24, sticky=&#39;s&#39;)

        # Widget containing &#39;About&#39; and &#39;disclaimer&#39; buttons.
        self.about = About(master=self)
        self.about.grid(row=2, column=1, padx=4, pady=4, sticky=&#39;sw&#39;)

        #################################
        # Configurables:
        #################################

        # Whether to display a pop-up message every time a flawed parse
        # is noticed in the `.desc_frame`
        self.warn_flawed_parse = True

        # When clicking preview/save buttons, warn about any lots that
        # were not defined. If True and any are found, will prompt user
        # to define them now.
        self.warn_unhandled_lots = True

    @property
    def mpq(self):
        &#34;&#34;&#34;Return a MultiPlatQueue object from the `self.plssdesc_list`
        and `self.ad_hoc_mpq`.&#34;&#34;&#34;
        mpq = MultiPlatQueue()
        for obj in self.plssdesc_list:
            mpq.queue_add(obj)
        mpq.absorb(self.ad_hoc_mpq)
        return mpq

    def trigger_update_preview(self):
        &#34;&#34;&#34;Update the preview in `.preview_frame`.&#34;&#34;&#34;
        self.preview_frame.gen_preview()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Tk</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.MainWindow.mpq"><code class="name">var <span class="ident">mpq</span></code></dt>
<dd>
<div class="desc"><p>Return a MultiPlatQueue object from the <code>self.plssdesc_list</code>
and <code>self.ad_hoc_mpq</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mpq(self):
    &#34;&#34;&#34;Return a MultiPlatQueue object from the `self.plssdesc_list`
    and `self.ad_hoc_mpq`.&#34;&#34;&#34;
    mpq = MultiPlatQueue()
    for obj in self.plssdesc_list:
        mpq.queue_add(obj)
    mpq.absorb(self.ad_hoc_mpq)
    return mpq</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.MainWindow.trigger_update_preview"><code class="name flex">
<span>def <span class="ident">trigger_update_preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the preview in <code>.preview_frame</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_update_preview(self):
    &#34;&#34;&#34;Update the preview in `.preview_frame`.&#34;&#34;&#34;
    self.preview_frame.gen_preview()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter"><code class="flex name class">
<span>class <span class="ident">ManualPlatter</span></span>
<span>(</span><span>master=None, mpq_owner=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame for manually adding QQ's to the plats.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManualPlatter(tk.Frame):
    &#34;&#34;&#34;
    A frame for manually adding QQ&#39;s to the plats.
    &#34;&#34;&#34;

    PLATTER_ROW = 3
    PLATTER_COL = 1
    TWPRGE_WID = 5
    NSEW_WID = 2

    def __init__(self, master=None, mpq_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master
        if mpq_owner is None:
            mpq_owner = master
        self.mpq_owner = mpq_owner
        self.target_mpq = mpq_owner.ad_hoc_mpq

        # Space at the top.
        lbl = Label(self, text=&#39;&#39;)
        lbl.grid(row=0, column=1)

        # Frame for defining Twp, Rge, Sec
        trs_frame = tk.Frame(self)
        trs_frame.grid(row=1, column=1, padx=20)

        trs_col = 0

        lbl = tk.Label(trs_frame, text=&#39;Twp:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.twp_num = tk.Entry(trs_frame, width=self.TWPRGE_WID)
        self.twp_num.grid(row=0, column=trs_col)
        trs_col += 1

        self.twp_ns = Combobox(trs_frame, width=self.NSEW_WID)
        self.twp_ns[&#39;values&#39;] = [&#39;N&#39;, &#39;S&#39;]
        self.twp_ns.current(0)
        self.twp_ns.grid(row=0, column=trs_col)
        trs_col += 1

        lbl = tk.Label(trs_frame, text=&#39;  Rge:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.rge_num = tk.Entry(trs_frame, width=self.TWPRGE_WID)
        self.rge_num.grid(row=0, column=trs_col)
        trs_col += 1

        self.rge_ew = Combobox(trs_frame, width=self.NSEW_WID)
        self.rge_ew[&#39;values&#39;] = [&#39;W&#39;, &#39;E&#39;]
        self.rge_ew.current(0)
        self.rge_ew.grid(row=0, column=trs_col)
        trs_col += 1

        lbl = tk.Label(trs_frame, text=&#39;  Sec:&#39;)
        lbl.grid(row=0, column=trs_col)
        trs_col += 1

        self.sec_num = Combobox(trs_frame, width=self.NSEW_WID)
        self.sec_num[&#39;values&#39;] = [i for i in range(1,37)]
        self.sec_num.current(0)
        self.sec_num.grid(row=0, column=trs_col)
        trs_col += 1

        clear_all_btn = tk.Button(
            self, text=&#34;Clear All Manually Added QQ&#39;s&#34;, height=2,
            command=self.clear_btn_clicked)
        clear_all_btn.grid(row=10, column=1, padx=10, pady=30)

        # The current ManualSectionPlatter object -- initialized as
        # None, then set in `.new_platter().
        self.cur_platter = None
        self.new_platter()

    def child_go_btn_clicked(self):
        &#34;&#34;&#34;Add the QQ&#39;s to the target MultiPlatQueue.&#34;&#34;&#34;

        # Compile TRS
        twprge, sec = self._compile_trs()
        # If invalid characters were identified, `.compile_trs()` returns
        # `False`, so check for that now.
        if twprge is False:
            return

        # Assign sec number to the SectionGrid object in the current platter
        sg = self.cur_platter.sec_grid
        sg.sec = sec

        # Add the SectionGrid object to the target MPQ, for the specified twprge
        self.target_mpq.queue_add(sg, twprge)

        # Get a new platter
        self.new_platter()

        # Update mini-preview
        try:
            self.mpq_owner.trigger_update_preview()
        except:
            pass

    def _compile_trs(self):
        &#34;&#34;&#34;
        Compile the twprge (&#39;000x000x&#39;) from the current entry/combo
        boxes.
        :return:
        &#34;&#34;&#34;
        # Compile TRS
        twp_num = self.twp_num.get()
        NS = self.twp_ns.get().lower()
        rge_num = self.rge_num.get()
        EW = self.rge_ew.get().lower()
        sec = self.sec_num.get()

        for chk in [twp_num, rge_num]:
            if len(chk) &gt; 3 or not chk.isnumeric():
                tk.messagebox.showerror(
                    &#39;Invalid Twp / Rge&#39;,
                    &#39;Enter Township and Range as 1 to 3 digits.&#39;
                )
                return False, False

        if len(sec) &gt; 2 or not sec.isnumeric():
            tk.messagebox.showerror(
                &#39;Invalid Sec&#39;,
                &#39;Enter Section as 1 or 2 digits.&#39;
            )
            return False, False

        if NS.lower() not in [&#39;n&#39;, &#39;s&#39;]:
            tk.messagebox.showerror(
                &#39;Invalid N/S&#39;,
                &#39;Township must be designated as either N or S.&#39;
            )
            return False, False

        if EW.lower() not in [&#39;e&#39;, &#39;w&#39;]:
            tk.messagebox.showerror(
                &#39;Invalid E/W&#39;,
                &#39;Range must be designated as either E or W.&#39;
            )
            return False, False

        return (twp_num + NS.lower() + rge_num + EW.lower(), sec)

    def clear_btn_clicked(self):
        &#34;&#34;&#34;
        Clear all manually added QQ&#39;s from the plats.
        NOTE: Does NOT clear parsed descriptions.
        &#34;&#34;&#34;
        prompt = messagebox.askyesno(
            &#39;Confirm?&#39;,
            &#34;Delete all manually added QQ&#39;s from plats? (Does not delete &#34;
            &#34;parsed text descriptions.)&#34;,
            icon=&#39;warning&#39;)

        if prompt is True:
            # Set the mpq owner&#39;s `.ad_hoc_mpq` to an empty MPQ
            self.master.ad_hoc_mpq = MultiPlatQueue()

            # Re-define our target_mpq to point to this new MPQ
            self.target_mpq = self.master.ad_hoc_mpq

            # Generate a new preview (which will be an empty plat)
            self.master.preview_frame.gen_preview()

    def new_platter(self):
        try:
            self.cur_platter.destroy()
        except:
            pass
        self.cur_platter = ManualSectionPlatter(self)
        self.cur_platter.grid(
            row=self.PLATTER_ROW, column=self.PLATTER_COL, pady=10)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.NSEW_WID"><code class="name">var <span class="ident">NSEW_WID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_COL"><code class="name">var <span class="ident">PLATTER_COL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_ROW"><code class="name">var <span class="ident">PLATTER_ROW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.TWPRGE_WID"><code class="name">var <span class="ident">TWPRGE_WID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.child_go_btn_clicked"><code class="name flex">
<span>def <span class="ident">child_go_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the QQ's to the target MultiPlatQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def child_go_btn_clicked(self):
    &#34;&#34;&#34;Add the QQ&#39;s to the target MultiPlatQueue.&#34;&#34;&#34;

    # Compile TRS
    twprge, sec = self._compile_trs()
    # If invalid characters were identified, `.compile_trs()` returns
    # `False`, so check for that now.
    if twprge is False:
        return

    # Assign sec number to the SectionGrid object in the current platter
    sg = self.cur_platter.sec_grid
    sg.sec = sec

    # Add the SectionGrid object to the target MPQ, for the specified twprge
    self.target_mpq.queue_add(sg, twprge)

    # Get a new platter
    self.new_platter()

    # Update mini-preview
    try:
        self.mpq_owner.trigger_update_preview()
    except:
        pass</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.clear_btn_clicked"><code class="name flex">
<span>def <span class="ident">clear_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all manually added QQ's from the plats.
NOTE: Does NOT clear parsed descriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_btn_clicked(self):
    &#34;&#34;&#34;
    Clear all manually added QQ&#39;s from the plats.
    NOTE: Does NOT clear parsed descriptions.
    &#34;&#34;&#34;
    prompt = messagebox.askyesno(
        &#39;Confirm?&#39;,
        &#34;Delete all manually added QQ&#39;s from plats? (Does not delete &#34;
        &#34;parsed text descriptions.)&#34;,
        icon=&#39;warning&#39;)

    if prompt is True:
        # Set the mpq owner&#39;s `.ad_hoc_mpq` to an empty MPQ
        self.master.ad_hoc_mpq = MultiPlatQueue()

        # Re-define our target_mpq to point to this new MPQ
        self.target_mpq = self.master.ad_hoc_mpq

        # Generate a new preview (which will be an empty plat)
        self.master.preview_frame.gen_preview()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualPlatter.new_platter"><code class="name flex">
<span>def <span class="ident">new_platter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_platter(self):
    try:
        self.cur_platter.destroy()
    except:
        pass
    self.cur_platter = ManualSectionPlatter(self)
    self.cur_platter.grid(
        row=self.PLATTER_ROW, column=self.PLATTER_COL, pady=10)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.ManualSectionPlatter"><code class="flex name class">
<span>class <span class="ident">ManualSectionPlatter</span></span>
<span>(</span><span>master=None)</span>
</code></dt>
<dd>
<div class="desc"><p>For manually platting QQ's in a section.</p>
<p>Specify EITHER <code>trs</code> OR <code>sec</code>, <code>twp</code>, and <code>rge</code>. If both sets
are specified, will use <code>trs</code> only.</p>
<p>:param ld: Same purpose as for pyTRSplat.grid.SectionGrid obj.
:param allow_ld_defaults: Same purpose as for SectionGrid obj.
:param button_on_text: Character that should be displayed inside
a QQ button when it's clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManualSectionPlatter(SectionFiller):
    &#34;&#34;&#34;
    For manually platting QQ&#39;s in a section.
    &#34;&#34;&#34;

    def __init__(self, master=None):
        SectionFiller.__init__(self, master)
        self.master = master
        self.go_btn.config(text=&#34;Add Selected QQ&#39;s to Plat&#34;, height=2)
        self.go_btn.grid(row=0, column=1, pady=20)

    def go_btn_clicked(self):
        self.master.child_go_btn_clicked()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.SectionFiller" href="#pyTRSplat.pyTRSplat_app.SectionFiller">SectionFiller</a></li>
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyTRSplat.pyTRSplat_app.SectionFiller" href="#pyTRSplat.pyTRSplat_app.SectionFiller">SectionFiller</a></b></code>:
<ul class="hlist">
<li><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller.go_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SectionFiller.go_btn_clicked">go_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked">qq_btn_clicked</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.OutputFrame"><code class="flex name class">
<span>class <span class="ident">OutputFrame</span></span>
<span>(</span><span>master=None, output_owner=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame containing output settings, preview button, and save
button, and corresponding functionality. Also contains the plat
generator. (Interacts with the <code>preview_frame</code> and <code>.mpq</code> of
<code>master</code>.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputFrame(tk.Frame):
    &#34;&#34;&#34;A frame containing output settings, preview button, and save
    button, and corresponding functionality. Also contains the plat
    generator. (Interacts with the `preview_frame` and `.mpq` of
    `master`.&#34;&#34;&#34;
    def __init__(self, master=None, output_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master

        if output_owner is None:
            output_owner = master
        self.output_owner = output_owner

        # Most recent custom Settings object, as configured in SettingsEditor
        self.current_custom_settings = None

        ####################################
        # Choosing Plat Settings
        ####################################

        # Subframe for getting the plat settings from user.
        self.settings_frame = tk.Frame(self)
        self.settings_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        self.settings_label = Label(
            self.settings_frame, text=&#39;Output settings:&#39;)
        self.settings_label.grid(row=2, column=1, pady=3, sticky=&#39;e&#39;)

        self.avail_settings = Settings.list_presets()
        self.settings_combo = Combobox(self.settings_frame, width=9)
        self.settings_combo[&#39;values&#39;] = self.avail_settings
        self.settings_combo.grid(row=2, column=2, sticky=&#39;w&#39;)
        # Set the combo to &#39;default&#39; preset. (If that doesn&#39;t exist, set to
        # whatever&#39;s first in the list.)
        try:
            settings_index = self.avail_settings.index(&#39;default&#39;)
        except ValueError:
            settings_index = 0
        self.settings_combo.current(settings_index)

        self.current_editor = None
        launch_editor_btn = tk.Button(
            self.settings_frame, text=&#39;Customize Settings&#39;, padx=3,
            command=self.editor_btn_clicked)
        launch_editor_btn.grid(row=3, column=1, sticky=&#39;w&#39;)

        ####################################
        # Full Page Preview / Save buttons
        ####################################

        # Subframe for &#39;save&#39; button and &#39;show full preview&#39; button
        self.save_full_preview_frame = tk.Frame(self)
        self.save_full_preview_frame.grid(row=2, column=1, sticky=&#39;n&#39;)

        # Button to show a full-sized version of the preview, using
        # current settings of the master window
        self.preview_full_button = tk.Button(
            self.save_full_preview_frame, text=&#39;Page Preview&#39;, height=2,
            width=12, command=self.preview_btn_clicked)
        self.preview_full_button.grid(
            row=2, column=1, padx=4, pady=5, sticky=&#39;w&#39;)

        # Button to save plats
        self.save_button = tk.Button(
            self.save_full_preview_frame, text=&#39;Save Plats&#39;, height=2,
            width=12, command=self.save_btn_clicked)
        self.save_button.grid(row=2, column=2, padx=4, pady=5, sticky=&#39;e&#39;)

    def editor_btn_clicked(self):
        &#34;&#34;&#34;
        Launch a CustomSettingsEditor window.
        :return:
        &#34;&#34;&#34;
        try:
            self.current_editor.destroy()
        except:
            pass
        self.current_editor = tk.Toplevel(self)
        self.current_editor.title(&#39;pyTRSplat - Customize Plat Settings&#39;)

        set_obj = self._get_settings(force_settings_return=True)

        editor = CustomSettingsEditor(
            master=self.current_editor, output_frame=self,
            first_settings_obj=set_obj)
        # Pre-fill the &#39;Load Preset&#39; combo with what was set in the OutputFrame
        editor.load_preset_name.delete(0, tk.END)
        editor.load_preset_name.insert(tk.END, self.settings_combo.get())

        editor.pack()
        self.current_editor.focus()
        self.current_editor.grab_set()

    ####################################
    # Generating the Plat(s)
    ####################################

    def _get_settings(self, force_settings_return=False):
        &#34;&#34;&#34;
        Get the appropriate Settings object, according to prior user
        input.
        &#34;&#34;&#34;
        cur_set_name = self.settings_combo.get()
        if cur_set_name == &#39;&lt;customized&gt;&#39;:
            set_obj = self.current_custom_settings
        elif cur_set_name in self.avail_settings:
            set_obj = Settings(preset=cur_set_name)
        elif force_settings_return:
            set_obj = Settings(preset=None)
        else:
            tk.messagebox.showerror(
                &#39;Unrecognized Settings Name&#39;,
                &#34;Choose one of the available settings. Or use &#39;Customize &#34;
                &#34;Settings&#39; to configure the plats.&#34;)
            self.focus()
            self.grab_set()
            return False

        return set_obj

    def gen_plat(self, use_tiny=False):
        &#34;&#34;&#34;
        Generate and return the Plat(s).
        :param use_tiny: Whether to use &#39;tiny&#39; settings, when we don&#39;t
        actually care about the output, and just want to process as
        quickly as possible to see what issues would pop up for when we
        eventually create the plat for real (e.g., unhandled lots).
        &#34;&#34;&#34;

        if use_tiny:
            set_obj = PlatPreview.PREVIEW_SETTINGS
        else:
            # Get the name of the preset `Settings` object we&#39;ll use.
            set_obj = self._get_settings()
        if set_obj is False:
            return

        # Get the bool var that decides whether we&#39;re supposed to trust
        # default lots (i.e. pass through to `allow_ld_defaults=`)
        trust_default_lots = self.output_owner.desc_frame.getvar(
            name=&#39;trust_default_lots&#39;)
        trust_default_lots = bool(trust_default_lots)

        return MultiPlat.from_queue(
            mpq=self.output_owner.mpq, settings=set_obj,
            lddb=self.output_owner.lddb, allow_ld_defaults=trust_default_lots)

    def _check_for_unhandled_lots(self, mp, warn=None, do_not_launch=False):
        &#34;&#34;&#34;
        Check for any unhandled lots in any of the plats. Raise a
        warning if any are found. (Warning may be disabled in main
        window settings.)
        :param mp: A MultiPlat object.
        :param warn: Whether to warn of discovered unhandled lots and
        ask the user whether to define them now. (If not specified,
        defaults to what is configured in `.warn_unhandled_lots` in main
        app Tk window.) If set to `False`, will automatically launch the
        definer if any undefined lots were identified.
        :param do_not_launch: A bool, whether to simply return what is
        found, without prompting the user to launch the editor or
        warning the user first. (Defaults to False.)
        :return: If user declines to define lots now (or if
        `do_not_launch` is passed as True), returns a 2-tuple:
            First element: bool (whether or not unhandled lots are found
                -- i.e. `True` means there is at least 1 unhandled lot;
            Second element: A dict containing all the unhandled lots,
                keyed by TRS (a string -- i.e. `154n97w01` for Sec 1,
                T154N-R97W), whose values are a list of lots that had
                no definition.
        If the user DOES decide to define lots now, this returns None
        and starts up a series of lot definers.
        &#34;&#34;&#34;
        confirm = True
        if warn is None:
            warn = self.output_owner.warn_unhandled_lots
            confirm = False

        if do_not_launch:
            warn = False
            confirm = False

        uhl = mp.all_unhandled_lots
        ret_uhl = {}  # the unhandled lots that will be returned (keyed by TRS)
        for twprge, plat_level_uhl in uhl.items():
            for sec_num, sec_uhl in plat_level_uhl.items():
                if len(sec_uhl) &gt; 0:
                    trs = twprge + str(sec_num).rjust(2, &#39;0&#39;)
                    ret_uhl[trs] = sec_uhl
                    # TODO: check if it&#39;s a &#39;default&#39; lot
                    #   (i.e. Sections 1-7 etc.)

        uhl_found = len(ret_uhl) &gt; 0
        if uhl_found and warn:
            txt = &#39;&#39;
            for trs, lots in ret_uhl.items():
                txt = f&#34;{txt}\n{trs}: {&#39;, &#39;.join(lots)}&#34;
            txt.strip()
            confirm = tk.messagebox.askyesno(
                &#39;Undefined Lots&#39;,
                &#39;One or more lots were identified in the parsed &#39;
                &#39;description(s) for which no definitions have been given:\n&#39;
                f&#34;{txt}\n\n&#34;
                &#39;These cannot be depicted on the plat until defined. &#39;
                &#39;Do so now?&#39;
            )

        if confirm and uhl_found:
            self.lot_definers = SeriesLotDefiner(
                self, top_owner=self.output_owner,
                target_lddb=self.output_owner.lddb, lots_to_define=ret_uhl)
            return None

        return (uhl_found, ret_uhl)

    def preview_btn_clicked(self):
        &#34;&#34;&#34;Generate the MultiPlat and display one of the plats from it. If
        the desired `index` is greater than the number of plats generated,
        will show the final one.&#34;&#34;&#34;
        mp = self.gen_plat()
        if mp is None:
            return

        if self.output_owner.warn_unhandled_lots:
            confirm = self._check_for_unhandled_lots(mp)
            if confirm is None:
                return

        if len(mp.plats) == 0:
            messagebox.showinfo(
                &#39;No plats&#39;,
                &#34;No plats to preview. Add land descriptions or manually add &#34;
                &#34;QQ&#39;s and try again.&#34;)
            return

        index = self.output_owner.preview_frame.preview_index
        if index &gt;= len(mp.plats):
            index = len(mp.plats) - 1

        # output() returns a list (in this case, only one page), so grab
        # the first (only) element from it.
        preview_img = mp.output(pages=index)[0]
        preview_window = FullPreviewWindow(
            self, img=preview_img, settings_name=self.settings_combo.get())

    def save_btn_clicked(self):
        &#34;&#34;&#34;Generate plats and save them to .png or .pdf at user-selected
        filepath.&#34;&#34;&#34;

        mp = self.gen_plat()
        if mp is None:
            return

        if self.output_owner.warn_unhandled_lots:
            confirm = self._check_for_unhandled_lots(mp)
            if confirm is None:
                return

        if len(mp.plats) == 0:
            messagebox.showinfo(
                &#39;No plats&#39;,
                &#34;No plats to save. Add land descriptions or manually add &#34;
                &#34;QQ&#39;s and try again.&#34;)
            return

        write_it = False
        multi_png = False
        start_dir = &#39;/&#39;
        ext = &#39;&#39;

        # Look at how many images are in the `previews` list to see how
        # many plats there will be.
        num_plats = len(self.output_owner.preview_frame.previews)

        while True:
            save_fp = filedialog.asksaveasfilename(
                initialdir=start_dir,
                filetypes=[(&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;PDF Files&#34;, &#34;*.pdf&#34;)],
                title=&#39;Save to PDF or PNG...&#39;
            )

            if save_fp == &#39;&#39;:
                break
            else:
                # If we need to re-prompt for filepath, we&#39;ll go back to the
                # same directory at least.
                start_dir = str(Path(save_fp).parent)
                stem = str(Path(save_fp).stem)

            if save_fp.lower().endswith(&#39;.pdf&#39;):
                write_it = True
                ext = &#39;.pdf&#39;
                break

            elif save_fp.lower().endswith(&#39;.png&#39;) and num_plats &gt; 1:

                # Generate the warning message, that `.png` will save multiple.
                msg_txt = (
                    &#39;Multiple plats have been generated. When saving to &#39;
                    &#39;.png specifically, each file will be saved separately, &#39;
                    &#39;as follows:\n&#39;
                )
                for i in range(num_plats):
                    msg_txt = f&#34;{msg_txt}\n{stem}_{str(i).rjust(3, &#39;0&#39;)}.png&#34;
                    if i == 3 and num_plats &gt; i:
                        msg_txt = msg_txt + &#39;\netc.&#39;
                        break
                msg_txt = msg_txt + &#39;\n\nIt will NOT prompt before overwriting files.&#39;
                msg_txt = msg_txt + &#39;\n\nContinue with saving?&#39;

                confirm = messagebox.askyesno(
                    &#39;Confirm saving to multiple files?&#39;, msg_txt)
                if confirm:
                    write_it = True
                    multi_png = True
                    ext = &#39;.png&#39;
                    break
                else:
                    continue

            elif save_fp.lower().endswith(&#39;.png&#39;):
                write_it = True
                ext = &#39;.png&#39;
                break

            else:
                messagebox.showerror(
                    &#39;.png and .pdf Files Only&#39;,
                    &#39;May only save to \&#39;.pdf\&#39; or \&#39;.png\&#39; files.&#39;)

        if not write_it:
            # If the user hasn&#39;t confirmed a good filepath,
            return

        if ext == &#39;.png&#39;:
            mp.output_to_png(save_fp)
        else:
            mp.output_to_pdf(save_fp)

        open_confirm = tk.messagebox.askyesno(
            &#39;Success!&#39;, &#39;Plat saved. Open file now?&#39;)

        if not open_confirm:
            return

        import os
        if not multi_png:
            os.startfile(save_fp)
            return

        # If we saved more than one .png, cut the ext off the fp, add the
        # numeral for the first file, and re-add the ext
        first_png = save_fp[:-4] + &#39;_000.png&#39;
        os.startfile(first_png)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.OutputFrame.editor_btn_clicked"><code class="name flex">
<span>def <span class="ident">editor_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch a CustomSettingsEditor window.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editor_btn_clicked(self):
    &#34;&#34;&#34;
    Launch a CustomSettingsEditor window.
    :return:
    &#34;&#34;&#34;
    try:
        self.current_editor.destroy()
    except:
        pass
    self.current_editor = tk.Toplevel(self)
    self.current_editor.title(&#39;pyTRSplat - Customize Plat Settings&#39;)

    set_obj = self._get_settings(force_settings_return=True)

    editor = CustomSettingsEditor(
        master=self.current_editor, output_frame=self,
        first_settings_obj=set_obj)
    # Pre-fill the &#39;Load Preset&#39; combo with what was set in the OutputFrame
    editor.load_preset_name.delete(0, tk.END)
    editor.load_preset_name.insert(tk.END, self.settings_combo.get())

    editor.pack()
    self.current_editor.focus()
    self.current_editor.grab_set()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.OutputFrame.gen_plat"><code class="name flex">
<span>def <span class="ident">gen_plat</span></span>(<span>self, use_tiny=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the Plat(s).
:param use_tiny: Whether to use 'tiny' settings, when we don't
actually care about the output, and just want to process as
quickly as possible to see what issues would pop up for when we
eventually create the plat for real (e.g., unhandled lots).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_plat(self, use_tiny=False):
    &#34;&#34;&#34;
    Generate and return the Plat(s).
    :param use_tiny: Whether to use &#39;tiny&#39; settings, when we don&#39;t
    actually care about the output, and just want to process as
    quickly as possible to see what issues would pop up for when we
    eventually create the plat for real (e.g., unhandled lots).
    &#34;&#34;&#34;

    if use_tiny:
        set_obj = PlatPreview.PREVIEW_SETTINGS
    else:
        # Get the name of the preset `Settings` object we&#39;ll use.
        set_obj = self._get_settings()
    if set_obj is False:
        return

    # Get the bool var that decides whether we&#39;re supposed to trust
    # default lots (i.e. pass through to `allow_ld_defaults=`)
    trust_default_lots = self.output_owner.desc_frame.getvar(
        name=&#39;trust_default_lots&#39;)
    trust_default_lots = bool(trust_default_lots)

    return MultiPlat.from_queue(
        mpq=self.output_owner.mpq, settings=set_obj,
        lddb=self.output_owner.lddb, allow_ld_defaults=trust_default_lots)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.OutputFrame.preview_btn_clicked"><code class="name flex">
<span>def <span class="ident">preview_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the MultiPlat and display one of the plats from it. If
the desired <code>index</code> is greater than the number of plats generated,
will show the final one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preview_btn_clicked(self):
    &#34;&#34;&#34;Generate the MultiPlat and display one of the plats from it. If
    the desired `index` is greater than the number of plats generated,
    will show the final one.&#34;&#34;&#34;
    mp = self.gen_plat()
    if mp is None:
        return

    if self.output_owner.warn_unhandled_lots:
        confirm = self._check_for_unhandled_lots(mp)
        if confirm is None:
            return

    if len(mp.plats) == 0:
        messagebox.showinfo(
            &#39;No plats&#39;,
            &#34;No plats to preview. Add land descriptions or manually add &#34;
            &#34;QQ&#39;s and try again.&#34;)
        return

    index = self.output_owner.preview_frame.preview_index
    if index &gt;= len(mp.plats):
        index = len(mp.plats) - 1

    # output() returns a list (in this case, only one page), so grab
    # the first (only) element from it.
    preview_img = mp.output(pages=index)[0]
    preview_window = FullPreviewWindow(
        self, img=preview_img, settings_name=self.settings_combo.get())</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.OutputFrame.save_btn_clicked"><code class="name flex">
<span>def <span class="ident">save_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate plats and save them to .png or .pdf at user-selected
filepath.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_btn_clicked(self):
    &#34;&#34;&#34;Generate plats and save them to .png or .pdf at user-selected
    filepath.&#34;&#34;&#34;

    mp = self.gen_plat()
    if mp is None:
        return

    if self.output_owner.warn_unhandled_lots:
        confirm = self._check_for_unhandled_lots(mp)
        if confirm is None:
            return

    if len(mp.plats) == 0:
        messagebox.showinfo(
            &#39;No plats&#39;,
            &#34;No plats to save. Add land descriptions or manually add &#34;
            &#34;QQ&#39;s and try again.&#34;)
        return

    write_it = False
    multi_png = False
    start_dir = &#39;/&#39;
    ext = &#39;&#39;

    # Look at how many images are in the `previews` list to see how
    # many plats there will be.
    num_plats = len(self.output_owner.preview_frame.previews)

    while True:
        save_fp = filedialog.asksaveasfilename(
            initialdir=start_dir,
            filetypes=[(&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;PDF Files&#34;, &#34;*.pdf&#34;)],
            title=&#39;Save to PDF or PNG...&#39;
        )

        if save_fp == &#39;&#39;:
            break
        else:
            # If we need to re-prompt for filepath, we&#39;ll go back to the
            # same directory at least.
            start_dir = str(Path(save_fp).parent)
            stem = str(Path(save_fp).stem)

        if save_fp.lower().endswith(&#39;.pdf&#39;):
            write_it = True
            ext = &#39;.pdf&#39;
            break

        elif save_fp.lower().endswith(&#39;.png&#39;) and num_plats &gt; 1:

            # Generate the warning message, that `.png` will save multiple.
            msg_txt = (
                &#39;Multiple plats have been generated. When saving to &#39;
                &#39;.png specifically, each file will be saved separately, &#39;
                &#39;as follows:\n&#39;
            )
            for i in range(num_plats):
                msg_txt = f&#34;{msg_txt}\n{stem}_{str(i).rjust(3, &#39;0&#39;)}.png&#34;
                if i == 3 and num_plats &gt; i:
                    msg_txt = msg_txt + &#39;\netc.&#39;
                    break
            msg_txt = msg_txt + &#39;\n\nIt will NOT prompt before overwriting files.&#39;
            msg_txt = msg_txt + &#39;\n\nContinue with saving?&#39;

            confirm = messagebox.askyesno(
                &#39;Confirm saving to multiple files?&#39;, msg_txt)
            if confirm:
                write_it = True
                multi_png = True
                ext = &#39;.png&#39;
                break
            else:
                continue

        elif save_fp.lower().endswith(&#39;.png&#39;):
            write_it = True
            ext = &#39;.png&#39;
            break

        else:
            messagebox.showerror(
                &#39;.png and .pdf Files Only&#39;,
                &#39;May only save to \&#39;.pdf\&#39; or \&#39;.png\&#39; files.&#39;)

    if not write_it:
        # If the user hasn&#39;t confirmed a good filepath,
        return

    if ext == &#39;.png&#39;:
        mp.output_to_png(save_fp)
    else:
        mp.output_to_pdf(save_fp)

    open_confirm = tk.messagebox.askyesno(
        &#39;Success!&#39;, &#39;Plat saved. Open file now?&#39;)

    if not open_confirm:
        return

    import os
    if not multi_png:
        os.startfile(save_fp)
        return

    # If we saved more than one .png, cut the ext off the fp, add the
    # numeral for the first file, and re-add the ext
    first_png = save_fp[:-4] + &#39;_000.png&#39;
    os.startfile(first_png)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview"><code class="flex name class">
<span>class <span class="ident">PlatPreview</span></span>
<span>(</span><span>master=None, preview_owner=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame displaying a preview of the plat, plus its controls.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlatPreview(tk.Frame):
    &#34;&#34;&#34;A frame displaying a preview of the plat, plus its controls.&#34;&#34;&#34;

    ###################
    # pyTRSplat.settings.Settings object
    ###################
    # Generate a Settings object for the mini-preview, with no
    # margins. (Hard-coded here, rather than creating it as a preset,
    # so that it will never be changed to unexpected settings.)
    PREVIEW_SETTINGS = Settings(preset=None)
    PREVIEW_SETTINGS_NONE = Settings(preset=None)
    for set_obj in [PREVIEW_SETTINGS, PREVIEW_SETTINGS_NONE]:
        set_obj.qq_side = 8
        set_obj.centerbox_wh = 12
        set_obj.sec_line_stroke = 1
        set_obj.qql_stroke = 1
        set_obj.ql_stroke = 1
        set_obj.sec_line_RGBA = (0, 0, 0, 255)
        set_obj.ql_RGBA = (128, 128, 128, 255)
        set_obj.qql_RGBA = (230, 230, 230, 255)
        set_obj.dim = (
            set_obj.qq_side * 4 * 6 + set_obj.sec_line_stroke,
            set_obj.qq_side * 4 * 6 + set_obj.sec_line_stroke)
        set_obj.y_top_marg = 0
        set_obj.set_font(&#39;sec&#39;, size=11)
        set_obj.write_header = False
        set_obj.write_tracts = False
        set_obj.write_lot_numbers = False

    # When there is nothing to preview, will show a grayed-out dummy plat.
    PREVIEW_SETTINGS_NONE.sec_line_RGBA = (148, 148, 148, 255)
    PREVIEW_SETTINGS_NONE.secfont_RGBA = (168, 168, 168, 255)
    PREVIEW_SETTINGS_NONE.ql_RGBA = (196, 196, 196, 255)
    PREVIEW_SETTINGS_NONE.centerbox_wh = 14

    def __init__(self, master=None, preview_owner=None):
        tk.Frame.__init__(self, master)
        self.master = master

        if preview_owner is None:
            preview_owner = master
        self.preview_owner = preview_owner

        # A list of Image objects of previews of the plats
        self.previews = []
        # A list of twp/rge (strings) to use as headers for previews of the plats
        self.previews_twprge = []
        # Current index of the preview
        self.preview_index = 0
        # Tracking if we&#39;re displaying a dummy (empty plat) in the preview
        self.dummy_set = False

        # Subframe for handling everything with the plat, other than getting
        # the PLSS descrips.
        plat_frame = tk.Frame(self)
        plat_frame.grid(row=0, column=2, sticky=&#39;n&#39;)

        # # Subframe for showing a preview of the plat, and controls for
        # # left/right
        # plat_preview_frame = tk.Frame(plat_frame)
        # plat_preview_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        # Subframe for showing the preview (this one does get stored to
        # self, because it gets updated with a new image periodically.
        self.plat_preview_display_frame = tk.Frame(master=self)
        self.plat_preview_display_frame.grid(row=1, column=1, sticky=&#39;n&#39;)

        # Subframe for controlling the preview (scroll left/right)
        plat_preview_control_frame = tk.Frame(master=self)
        plat_preview_control_frame.grid(row=2, column=1, sticky=&#39;n&#39;)

        preview_disp_header = Label(
            self.plat_preview_display_frame, text=&#39;Quick Preview&#39;)
        preview_disp_header.grid(row=1, column=1, pady=2, sticky=&#39;n&#39;)

        # A label below the preview image to display T&amp;R
        self.preview_footer_text = tk.StringVar()
        preview_disp_footer = Label(
            self.plat_preview_display_frame,
            textvariable=self.preview_footer_text)
        preview_disp_footer.grid(row=3, column=1, sticky=&#39;n&#39;)

        self.preview_disp_label = None

        # Update the `self.previews` list (starts as an empty list).
        self.gen_preview()

        # Button to scroll preview right
        preview_right_button = tk.Button(
            plat_preview_control_frame, text=&#39;&gt;&#39;, height=1, width=8,
            command=self.scroll_preview)
        preview_right_button.grid(
            row=1, column=2, padx=8, pady=5, sticky=&#39;n&#39;)

        # Button to scroll preview left
        preview_left_button = tk.Button(
            plat_preview_control_frame, text=&#39;&lt;&#39;, height=1, width=8,
            command=lambda: self.scroll_preview(-1))
        preview_left_button.grid(
            row=1, column=1, padx=8, pady=5, sticky=&#39;n&#39;)

    def gen_preview(self):
        &#34;&#34;&#34;Generate a new list of preview plats (Image objects) and set
        it to `self.previews`. (Discards the old previews.) Updates
        `self.dummy_set` as appropriate.&#34;&#34;&#34;
        mpq = self.preview_owner.mpq
        lddb = self.preview_owner.lddb

        # Get the bool var that decides whether we&#39;re supposed to trust
        # default lots (i.e. pass through to `allow_ld_defaults=`)
        trust_default_lots = self.preview_owner.desc_frame.getvar(
            name=&#39;trust_default_lots&#39;)
        trust_default_lots = bool(trust_default_lots)

        # Create a new MP
        new_preview_mp = MultiPlat.from_queue(
            mpq, settings=self.PREVIEW_SETTINGS, lddb=lddb,
            allow_ld_defaults=trust_default_lots)

        self.dummy_set = False

        # If there&#39;s nothing yet in the MPQ, manually create a &#39;dummy&#39; plat
        # and append it, so that there&#39;s something to show (an empty plat)
        if len(mpq.keys()) == 0:
            dummy = Plat(settings=self.PREVIEW_SETTINGS_NONE)
            new_preview_mp.plats.append(dummy)
            self.dummy_set = True

        # Output the plat images to a list, and set to `.previews`
        self.previews = new_preview_mp.output()

        # And create a list of &#39;twprge&#39; values for each of the images, and
        # set to `.previews_twprge`.
        self.previews_twprge = []
        for plObj in new_preview_mp.plats:
            self.previews_twprge.append(plObj.twprge)

        # Update the preview display
        self.update_preview_display()

    def update_preview_display(self, index=None):
        &#34;&#34;&#34;Update the preview image and header in this widget.&#34;&#34;&#34;

        if index is None:
            index = self.preview_index

        # Pull the image from the `.previews` list, and convert it to
        # `ImageTk.PhotoImage` obj
        if index &gt; len(self.previews) - 1:
            index = 0
            self.preview_index = 0
        img = self.previews[index]
        preview = ImageTk.PhotoImage(img, master=self)

        # Display the preview in this label.
        self.preview_disp_label = Label(
            self.plat_preview_display_frame, image=preview)
        self.preview_disp_label.image = preview
        self.preview_disp_label.grid(row=2, column=1, sticky=&#39;n&#39;)

        # Also update the footer.
        foot_txt = self.previews_twprge[index]
        foot_txt = f&#34;{foot_txt}  [{index + 1} / {len(self.previews)}]&#34;
        self.preview_footer_text.set(foot_txt)

        # But if we&#39;ve most recently set a dummy, clear the footer.
        if self.dummy_set:
            self.preview_footer_text.set(&#39;[No plats to display.]&#39;)

    def scroll_preview(self, direction=1):
        &#34;&#34;&#34;Scroll the preview left or right. (1 -&gt; right;  -1 -&gt; left).
        Defaults to scrolling right.&#34;&#34;&#34;
        self.preview_index += direction

        # Wrap the index around, if it goes above or below the length
        # of our previews list.
        self.preview_index %= len(self.previews)
        self.update_preview_display()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS"><code class="name">var <span class="ident">PREVIEW_SETTINGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS_NONE"><code class="name">var <span class="ident">PREVIEW_SETTINGS_NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.set_obj"><code class="name">var <span class="ident">set_obj</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.gen_preview"><code class="name flex">
<span>def <span class="ident">gen_preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a new list of preview plats (Image objects) and set
it to <code>self.previews</code>. (Discards the old previews.) Updates
<code>self.dummy_set</code> as appropriate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_preview(self):
    &#34;&#34;&#34;Generate a new list of preview plats (Image objects) and set
    it to `self.previews`. (Discards the old previews.) Updates
    `self.dummy_set` as appropriate.&#34;&#34;&#34;
    mpq = self.preview_owner.mpq
    lddb = self.preview_owner.lddb

    # Get the bool var that decides whether we&#39;re supposed to trust
    # default lots (i.e. pass through to `allow_ld_defaults=`)
    trust_default_lots = self.preview_owner.desc_frame.getvar(
        name=&#39;trust_default_lots&#39;)
    trust_default_lots = bool(trust_default_lots)

    # Create a new MP
    new_preview_mp = MultiPlat.from_queue(
        mpq, settings=self.PREVIEW_SETTINGS, lddb=lddb,
        allow_ld_defaults=trust_default_lots)

    self.dummy_set = False

    # If there&#39;s nothing yet in the MPQ, manually create a &#39;dummy&#39; plat
    # and append it, so that there&#39;s something to show (an empty plat)
    if len(mpq.keys()) == 0:
        dummy = Plat(settings=self.PREVIEW_SETTINGS_NONE)
        new_preview_mp.plats.append(dummy)
        self.dummy_set = True

    # Output the plat images to a list, and set to `.previews`
    self.previews = new_preview_mp.output()

    # And create a list of &#39;twprge&#39; values for each of the images, and
    # set to `.previews_twprge`.
    self.previews_twprge = []
    for plObj in new_preview_mp.plats:
        self.previews_twprge.append(plObj.twprge)

    # Update the preview display
    self.update_preview_display()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.scroll_preview"><code class="name flex">
<span>def <span class="ident">scroll_preview</span></span>(<span>self, direction=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the preview left or right. (1 -&gt; right;
-1 -&gt; left).
Defaults to scrolling right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_preview(self, direction=1):
    &#34;&#34;&#34;Scroll the preview left or right. (1 -&gt; right;  -1 -&gt; left).
    Defaults to scrolling right.&#34;&#34;&#34;
    self.preview_index += direction

    # Wrap the index around, if it goes above or below the length
    # of our previews list.
    self.preview_index %= len(self.previews)
    self.update_preview_display()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.PlatPreview.update_preview_display"><code class="name flex">
<span>def <span class="ident">update_preview_display</span></span>(<span>self, index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the preview image and header in this widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_preview_display(self, index=None):
    &#34;&#34;&#34;Update the preview image and header in this widget.&#34;&#34;&#34;

    if index is None:
        index = self.preview_index

    # Pull the image from the `.previews` list, and convert it to
    # `ImageTk.PhotoImage` obj
    if index &gt; len(self.previews) - 1:
        index = 0
        self.preview_index = 0
    img = self.previews[index]
    preview = ImageTk.PhotoImage(img, master=self)

    # Display the preview in this label.
    self.preview_disp_label = Label(
        self.plat_preview_display_frame, image=preview)
    self.preview_disp_label.image = preview
    self.preview_disp_label.grid(row=2, column=1, sticky=&#39;n&#39;)

    # Also update the footer.
    foot_txt = self.previews_twprge[index]
    foot_txt = f&#34;{foot_txt}  [{index + 1} / {len(self.previews)}]&#34;
    self.preview_footer_text.set(foot_txt)

    # But if we&#39;ve most recently set a dummy, clear the footer.
    if self.dummy_set:
        self.preview_footer_text.set(&#39;[No plats to display.]&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SectionFiller"><code class="flex name class">
<span>class <span class="ident">SectionFiller</span></span>
<span>(</span><span>master=None, sec=0, twp='', rge='', trs='', ld=None, allow_ld_defaults=False, button_on_text='X')</span>
</code></dt>
<dd>
<div class="desc"><p>A frame with 4x4 button grid for manually turning on/off QQ's.</p>
<p>Specify EITHER <code>trs</code> OR <code>sec</code>, <code>twp</code>, and <code>rge</code>. If both sets
are specified, will use <code>trs</code> only.</p>
<p>:param ld: Same purpose as for pyTRSplat.grid.SectionGrid obj.
:param allow_ld_defaults: Same purpose as for SectionGrid obj.
:param button_on_text: Character that should be displayed inside
a QQ button when it's clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SectionFiller(tk.Frame):
    &#34;&#34;&#34;
    A frame with 4x4 button grid for manually turning on/off QQ&#39;s.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, sec=0, twp=&#39;&#39;, rge=&#39;&#39;, trs=&#39;&#39;, ld=None,
            allow_ld_defaults=False, button_on_text=&#39;X&#39;):
        &#34;&#34;&#34;
        Specify EITHER `trs` OR `sec`, `twp`, and `rge`. If both sets
        are specified, will use `trs` only.

        :param ld: Same purpose as for pyTRSplat.grid.SectionGrid obj.
        :param allow_ld_defaults: Same purpose as for SectionGrid obj.
        :param button_on_text: Character that should be displayed inside
        a QQ button when it&#39;s clicked.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        self.master = master

        self.go_btn = tk.Button(self, text=&#39;Go&#39;, command=self.go_btn_clicked)
        self.go_btn.grid(row=0, column=1)

        if trs != &#39;&#39;:
            self.sec_grid = SectionGrid.from_trs(
                trs, ld=ld, allow_ld_defaults=allow_ld_defaults)
        else:
            self.sec_grid = SectionGrid(
                sec, twp, rge, ld=ld, allow_ld_defaults=allow_ld_defaults)

        self.twprge = self.sec_grid.twprge
        self.sec = self.sec_grid.sec
        self.trs = self.sec_grid.trs

        grid_frame = tk.Frame(self)
        grid_frame.grid(row=3, column=1, sticky=&#39;n&#39;)
        self.buttons = []
        for k, v in self.sec_grid.QQgrid.items():
            btn = self._QQButton(
                grid_frame, qq=k, qq_dict=v, on_text=button_on_text)
            self.buttons.append(btn)

    def go_btn_clicked(self):
        &#34;&#34;&#34;
        Customizable method. Redefine this method depending on
        application. Gets called any time a QQ button gets clicked.
        &#34;&#34;&#34;
        pass

    def qq_btn_clicked(self, qq_name):
        &#34;&#34;&#34;
        Customizable method. Redefine this method depending on
        application. Gets called any time a QQ button gets clicked.

        :param qq_name: The name of the QQ button that was clicked
            (e.g., &#39;NENE&#39;)
        &#34;&#34;&#34;
        pass

    class _QQButton(tk.Button):
        &#34;&#34;&#34;
        A button for toggling a QQ.
        &#34;&#34;&#34;
        W = 2
        H = 1
        def __init__(self, master=None, qq=&#39;&#39;, qq_dict=None, on_text=&#39;X&#39;, **kw):
            tk.Button.__init__(self, master, **kw)
            self.master = master
            self.qq = qq
            self.on_text = on_text
            self.qq_dict = qq_dict
            self.grid(row=qq_dict[&#39;coord&#39;][1], column=qq_dict[&#39;coord&#39;][0])
            self.config(command=self.toggle, width=self.W, height=self.H)
            self.config(text=self.on_text * self.qq_dict[&#39;val&#39;])

        def toggle(self):
            self.qq_dict[&#39;val&#39;] = (self.qq_dict[&#39;val&#39;] + 1) % 2
            self.config(text=self.on_text * self.qq_dict[&#39;val&#39;])
            self.master.master.qq_btn_clicked(self.qq)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.ManualSectionPlatter" href="#pyTRSplat.pyTRSplat_app.ManualSectionPlatter">ManualSectionPlatter</a></li>
<li><a title="pyTRSplat.pyTRSplat_app.SingleLotDefiner" href="#pyTRSplat.pyTRSplat_app.SingleLotDefiner">SingleLotDefiner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.SectionFiller.go_btn_clicked"><code class="name flex">
<span>def <span class="ident">go_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Customizable method. Redefine this method depending on
application. Gets called any time a QQ button gets clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def go_btn_clicked(self):
    &#34;&#34;&#34;
    Customizable method. Redefine this method depending on
    application. Gets called any time a QQ button gets clicked.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked"><code class="name flex">
<span>def <span class="ident">qq_btn_clicked</span></span>(<span>self, qq_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Customizable method. Redefine this method depending on
application. Gets called any time a QQ button gets clicked.</p>
<p>:param qq_name: The name of the QQ button that was clicked
(e.g., 'NENE')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qq_btn_clicked(self, qq_name):
    &#34;&#34;&#34;
    Customizable method. Redefine this method depending on
    application. Gets called any time a QQ button gets clicked.

    :param qq_name: The name of the QQ button that was clicked
        (e.g., &#39;NENE&#39;)
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SeriesLotDefiner"><code class="flex name class">
<span>class <span class="ident">SeriesLotDefiner</span></span>
<span>(</span><span>master=None, top_owner=None, target_lddb=None, lots_to_define=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Toplevel widget, e.g. for dialogs.</p>
<p>:param top_owner: The main application, which contains a
.trigger_update_preview() method.
:param target_lddb: A LotDefDB object that should be modified.
:param lots_to_define: A dict, specifying which lots need to be
defined, in this format:
<trs key> -&gt; <list of lots>
ex: {'154n97w01': ['L1, 'L2'], '154n97w02': ['L1', 'L3']}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeriesLotDefiner(tk.Toplevel):
    def __init__(
            self, master=None, top_owner=None, target_lddb=None,
            lots_to_define=None):
        &#34;&#34;&#34;
        :param top_owner: The main application, which contains a
        .trigger_update_preview() method.
        :param target_lddb: A LotDefDB object that should be modified.
        :param lots_to_define: A dict, specifying which lots need to be
        defined, in this format:   &lt;trs key&gt; -&gt; &lt;list of lots&gt;
            ex: {&#39;154n97w01&#39;: [&#39;L1, &#39;L2&#39;], &#39;154n97w02&#39;: [&#39;L1&#39;, &#39;L3&#39;]}
        &#34;&#34;&#34;
        tk.Toplevel.__init__(self, master)
        # The LotDefDB object that will be updated:
        self.target_lddb = target_lddb

        if top_owner is None:
            top_owner = master
        self.top_owner = top_owner

        # All of the lots we need to define -- i.e. an `unhandled_lots`
        # dict (`ret_uhl`) from `OutputFrame._check_for_unhandled_lots()`
        self.lots_to_define = lots_to_define
        self.cur_definer = None
        self.trs_keys = list(lots_to_define.keys())
        self.cur_trs = None
        self.cur_lots = []

        self.next_one()

    def next_one(self):
        try:
            self.cur_definer.destroy()
        except:
            pass

        if len(self.cur_lots) == 0:
            if len(self.trs_keys) == 0:
                self.done()
                return None
            self.cur_trs = self.trs_keys.pop(0)
            self.cur_lots = self.lots_to_define[self.cur_trs]

        lot = self.cur_lots.pop(0)
        self.cur_definer = SingleLotDefiner(
            self, target_lddb=self.target_lddb, trs=self.cur_trs, lot_num=lot)
        self.cur_definer.cancel_btn.grid(row=7, column=1)
        self.cur_definer.grid(row=0, column=0, padx=14, pady=14, sticky=&#39;nesw&#39;)
        self.cur_definer.focus()
        self.cur_definer.grab_set()

    def done(self):
        # TODO: Maybe a success message?
        self.top_owner.trigger_update_preview()
        self.destroy()

    def canceled(self):
        # TODO: Maybe a confirm / abandon message?
        self.top_owner.trigger_update_preview()
        self.destroy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.TableSeriesDefiner" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.TableSeriesDefiner">LotDefEditor.TableSeriesDefiner</a></li>
<li><a title="pyTRSplat.pyTRSplat_app.LotRedefiner" href="#pyTRSplat.pyTRSplat_app.LotRedefiner">LotRedefiner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.canceled"><code class="name flex">
<span>def <span class="ident">canceled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canceled(self):
    # TODO: Maybe a confirm / abandon message?
    self.top_owner.trigger_update_preview()
    self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self):
    # TODO: Maybe a success message?
    self.top_owner.trigger_update_preview()
    self.destroy()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.next_one"><code class="name flex">
<span>def <span class="ident">next_one</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_one(self):
    try:
        self.cur_definer.destroy()
    except:
        pass

    if len(self.cur_lots) == 0:
        if len(self.trs_keys) == 0:
            self.done()
            return None
        self.cur_trs = self.trs_keys.pop(0)
        self.cur_lots = self.lots_to_define[self.cur_trs]

    lot = self.cur_lots.pop(0)
    self.cur_definer = SingleLotDefiner(
        self, target_lddb=self.target_lddb, trs=self.cur_trs, lot_num=lot)
    self.cur_definer.cancel_btn.grid(row=7, column=1)
    self.cur_definer.grid(row=0, column=0, padx=14, pady=14, sticky=&#39;nesw&#39;)
    self.cur_definer.focus()
    self.cur_definer.grab_set()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor"><code class="flex name class">
<span>class <span class="ident">SingleDescriptionEditor</span></span>
<span>(</span><span>master=None, plssdesc_obj=None, more_info=False, display_more_info_btn=False, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A subframe for viewing, editing, reconfiguring, and reparsing a
single pyTRS.PLSSDesc object.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleDescriptionEditor(tk.Frame):
    &#34;&#34;&#34;A subframe for viewing, editing, reconfiguring, and reparsing a
    single pyTRS.PLSSDesc object.&#34;&#34;&#34;

    # Display colors of text, depending on whether it&#39;s original data,
    # edited data that has not yet been activated, or edited data that
    # has been activated but not yet saved
    SAVED_COLOR = &#39;black&#39;
    EDIT_UNACTIVATED_COLOR = &#39;red&#39;
    EDIT_UNSAVED_COLOR = &#39;blue&#39;

    def __init__(
            self, master=None, plssdesc_obj=None, more_info=False,
            display_more_info_btn=False, **kw):
        tk.Frame.__init__(self, master, **kw)
        if plssdesc_obj is None:
            plssdesc_obj = pyTRS.PLSSDesc(&#39;&#39;)
        self.cur_plssdesc_obj = plssdesc_obj
        self._orig_plssdesc_obj = plssdesc_obj

        # Tracking the PLSSDesc object from which we&#39;re currently viewing
        # tracts and flags, and whether the displayed data has been &#39;saved&#39;
        self.current_display_tract_source = plssdesc_obj
        self.current_display_flag_source = plssdesc_obj
        self.current_display_tract_status = &#39;parsed&#39;
        self.current_display_flag_status = &#39;parsed&#39;

        # Tracking whether this Editor object has created a new PLSSDesc
        # object (may also be reset to False by the &#39;Restore&#39; button)
        self.created_new_plssdesc = False

        # The first &#39;original description&#39; (`.origDesc`) that had been
        # stored in the PLSSDesc object as of init. (`.origDesc` may
        # change after this point, but this will not.)
        self._first_orig_desc = plssdesc_obj.origDesc
        # The new description that we&#39;ll use, if we end up replacing
        # our original PLSSDesc object.
        self.new_desc_text = self._first_orig_desc
        self.current_display_desc_status = &#39;parsed&#39;

        # The pyTRS Config text (decompiled from our PLSSDesc obj&#39;s
        # `.config` attrib) that was last used to parse the text. Hold
        # onto it to use in case the user hits the &#39;CANCEL&#39; button in
        # the config_popup.
        cf = plssdesc_obj.config  # currently a pyTRS.Config obj
        if not plssdesc_obj.layout_specified:
            # If the layout was NOT specified in `config` param when the
            # PLSSDesc obj was parsed (i.e. layout was deduced), we want
            # to deduce the layout for our replacement PLSSDesc object
            # too, rather than use the layout that this PLSSDesc ended
            # up with
            cf.layout = None
        first_config = cf.decompile_to_text()
        self._last_used_config = first_config

        # The new config parameters that we&#39;ll use, if we end up
        # replacing our original PLSSDesc object. (Can be changed by
        # clicking &#39;Reconfigure&#39; button.)
        self.config_text = tk.StringVar()
        self.config_text.set(self._last_used_config)

        # Frame holding controls and orig description
        control_orig_desc_frame = tk.Frame(self)
        control_orig_desc_frame.grid(row=0, column=0, pady=5, sticky=&#39;nws&#39;)

        #####################################
        # Edit / Reconfig / Reparse Controls
        #####################################

        # Whether the user wants to see more info on parsed data
        # (e.g., lots/QQ&#39;s, warning/error flags)
        self.more_info = more_info

        control_frame = tk.Frame(control_orig_desc_frame)
        control_frame.grid(row=0, column=0, sticky=&#39;nw&#39;)

        # Keeping track of the config_popup and/or new_desc_pop_up we&#39;ve
        # lauched from this editor, if any
        self.config_popup_tk = None
        self.new_desc_pop_up_tk = None

        btn_padx = 4

        reconfig_btn = tk.Button(
            control_frame, text=&#39;Reconfigure&#39;, height=2, padx=2,
            command=self.reconfig_btn_clicked)
        reconfig_btn.grid(row=0, column=0, padx=btn_padx, sticky=&#39;n&#39;)

        edit_desc_btn = tk.Button(
            control_frame, text=&#39;Edit Text&#39;, height=2, padx=2,
            command=self.edit_desc_btn_clicked)
        edit_desc_btn.grid(row=0, column=1, padx=btn_padx, sticky=&#39;n&#39;)

        reparse_btn = tk.Button(
            control_frame, text=&#39;Reparse&#39;, height=2, padx=2,
            command=self.reparse)
        reparse_btn.grid(row=0, column=2, padx=btn_padx, sticky=&#39;n&#39;)

        restore_btn = tk.Button(
            control_frame, text=&#39;Restore&#39;, height=2, padx=2,
            command=self.restore)
        restore_btn.grid(row=0, column=3, padx=btn_padx, sticky=&#39;n&#39;)

        # We display more info (i.e. lots/QQs, warning/error flags) in
        # the tables, depending on `.more_info`. However, we only show
        # a `Show More/Less Info` button if `display_more_info_btn=True`
        # was specified at init. (Allows control from higher-level
        # widget, but also the option to create a SDE with this
        # functionality.)
        if self.more_info:
            more_info_btn_txt = &#39;Show less info&#39;
        else:
            more_info_btn_txt = &#39;Show more info&#39;
        self.more_info_btn = tk.Button(
            control_frame, text=more_info_btn_txt, height=2, width=14,
            command=self.toggle_more_info)
        self.display_more_info_btn = display_more_info_btn
        if display_more_info_btn:
            self.more_info_btn.grid(row=0, column=4, padx=btn_padx, sticky=&#39;n&#39;)

        #####################################
        # Display
        #####################################

        # Displaying the original description.
        self.orig_desc_frame = tk.Frame(control_orig_desc_frame)
        self.orig_desc_frame.grid(row=2, column=0, padx=btn_padx, sticky=&#39;nswe&#39;)

        self.orig_desc_lbl_width = 40
        self.orig_desc_lbl_wraplength = 240

        # Orig Descrip
        self.orig_desc_lbl = tk.Label(self.orig_desc_frame, anchor=&#39;nw&#39;)
        self.orig_desc_lbl.config(
            fg=SingleDescriptionEditor.SAVED_COLOR,
            text=self._first_orig_desc,
            width=self.orig_desc_lbl_width,
            wraplength=self.orig_desc_lbl_wraplength,
            justify=&#39;left&#39;)
        self.orig_desc_lbl.grid(row=0, column=0, sticky=&#39;nw&#39;)

        self.pytrs_display_frame = tk.Frame(self)
        self.pytrs_display_frame.grid(row=0, column=3, sticky=&#39;n&#39;)

        # Variables to configure how/where the TractTable and FlagTable
        # should be placed in the grid.
        self.tract_table_row_col = (1, 1)
        self.tract_table_padx_pady = (5, 5)
        self.flag_table_row_col = (3, 1)
        self.flag_table_padx_pady = (5, 10)

        # The parsed tracts are displayed in `.tract_table` (set to None
        # here, but initialized as a TractTable obj in `.display_new_tracts`)
        self.tract_table = None
        self.display_new_tracts(
            source_plssdesc=self.cur_plssdesc_obj, status=&#39;saved&#39;)

        # Warning and Error Flags are displayed in `.flag_table` (set to
        # None here, but initialized as a FlagTable obj in `.display_new_flags`)
        self.flag_table = None
        self.display_new_flags(
            source_plssdesc=self.cur_plssdesc_obj, status=&#39;saved&#39;)

    def toggle_more_info(self):
        &#34;&#34;&#34;Toggle whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
        self.more_info = not self.more_info
        self.set_more_info()

    def set_more_info(self, set_to=None):
        &#34;&#34;&#34;Set whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
        if set_to is None:
            set_to = self.more_info
        self.more_info = set_to
        self.display_new_flags()
        self.display_new_tracts()
        if self.more_info:
            text=&#39;Show less info&#39;
        else:
            text=&#39;Show more info&#39;
        self.more_info_btn.config(text=text)

    def edit_desc_btn_clicked(self):
        &#34;&#34;&#34;Prompt the user to make edits to the original description.&#34;&#34;&#34;
        if self.new_desc_pop_up_tk is not None:
            self.new_desc_pop_up_tk.destroy()
        self.new_desc_pop_up_tk = DescTextEditWindow(
            master=self, orig_text=self.new_desc_text)
        self.new_desc_pop_up_tk.focus()
        self.new_desc_pop_up_tk.grab_set()

    def display_new_descrip(self, status=&#39;not_activated&#39;):
        &#34;&#34;&#34;Update the displayed description for the PLSSDesc object
        (pulled from `self.new_desc_text`). If the text has been edited
        but not enacted, set the color to red. If it has been enacted,
        but not yet saved, set to blue. If saved, set to black.&#34;&#34;&#34;
        if status == &#39;not_activated&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR
        elif status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        self.orig_desc_lbl.config(fg=text_color, text=self.new_desc_text)
        self.current_display_desc_status = status

    def display_new_flags(self, source_plssdesc=None, status=None):

        # If status not specified, get it from `self`. Also update `self`
        # on the status.
        if status is None:
            status = self.current_display_flag_status
        self.current_display_flag_status = status

        if status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        if source_plssdesc is None:
            source_plssdesc = self.current_display_flag_source

        # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
        # tracts from
        self.current_display_flag_source = source_plssdesc

        # Destroy the old flag_table, and replace it with a new one
        if self.flag_table is not None:
            self.flag_table.destroy()
        self.flag_table = FlagTable(
            self.pytrs_display_frame, wflag_list=source_plssdesc.wFlagList,
            eflag_list=source_plssdesc.eFlagList, more_info=self.more_info)
        if self.more_info:
            # Only if `.more_info==True` do we place this on the grid.
            self.flag_table.grid(
                row=self.flag_table_row_col[0],
                column=self.flag_table_row_col[1],
                padx=self.flag_table_padx_pady[0],
                pady=self.flag_table_padx_pady[1], sticky=&#39;nws&#39;)

    def display_new_tracts(self, source_plssdesc=None, status=None):
        &#34;&#34;&#34;Display the data for the parsed pyTRS.Tract in the specified
        `source_plssdesc`.&#34;&#34;&#34;
        # If status not specified, get it from `self`. Also update `self`
        # on the status.
        if status is None:
            status = self.current_display_tract_status
        self.current_display_tract_status = status

        if status == &#39;not_saved&#39;:
            text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
        else:
            text_color = SingleDescriptionEditor.SAVED_COLOR

        if source_plssdesc is None:
            # Default to pulling the replacement.
            source_plssdesc = self.current_display_tract_source

        # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
        # tracts from
        self.current_display_tract_source = source_plssdesc

        # Destroy the old tract_table, and replace it with a new one,
        # using as the tract_list the `.parsedTracts` from the chosen
        # source PLSSDesc object.
        if self.tract_table is not None:
            self.tract_table.destroy()
        self.tract_table = TractTable(
            self.pytrs_display_frame,
            tract_list=source_plssdesc.parsedTracts, more_info=self.more_info)
        self.tract_table.grid(
            row=self.tract_table_row_col[0],
            column=self.tract_table_row_col[1],
            padx=self.tract_table_padx_pady[0],
            pady=self.tract_table_padx_pady[1], sticky=&#39;nw&#39;)

    def reparse(self):
        &#34;&#34;&#34;
        Reparse the pyTRS.PLSSDesc object at the specified index in
        `self.plssdesc_list`, using the optionally re-specified `config`
        parameters. (If `config` has not been specified, will use
        whatever was already in the PLSSDesc object.)

        Note: This will create a new PLSSDesc object and set it to
        `self.cur_plssdesc_obj`. Beware lists that contain the original
        PLSSDesc object, as those will NOT be automatically updated with
        this new object.
        &#34;&#34;&#34;

        # Close any subordinate popups.
        try:
            self.config_popup_tk.destroy()
        except:
            pass
        try:
            self.new_desc_pop_up_tk.destroy()
        except:
            pass

        config = self.config_text.get()
        if config == &#39;CANCEL&#39;:
            # If the user hit the cancel button in the config popup, use
            # the original config
            config = self._last_used_config
        desc = self.new_desc_text
        d_obj = pyTRS.PLSSDesc(desc, config=config, initParseQQ=True)
        # Set the main PLSSDesc obj to the new replacement.
        self.cur_plssdesc_obj = d_obj
        # Update our last-used config text (again stripping out layout,
        # if it was deduced, rather than dictated by user)
        cf = d_obj.config  # currently a pyTRS.Config obj
        if not d_obj.layout_specified:
            cf.layout = None
        self._last_used_config = cf.decompile_to_text()

        # Update our displays.
        self.display_new_descrip(status=&#39;parsed&#39;)
        self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        # And keep track of the fact that we&#39;ve created a new PLSSDesc obj.
        self.created_new_plssdesc = True

    def restore(self):
        &#34;&#34;&#34;
        Restore the original pyTRS.PLSSDesc object, as it existed at the
        creation of this editor instance.
        &#34;&#34;&#34;

        confirm = tk.messagebox.askyesno(
            &#39;Confirm Restore&#39;,
            &#39;Discard all changes made to this description since opening &#39;
            &#39;this editor window?&#39;)
        if not confirm:
            return

        # TODO: Prompt &#34;Are You Sure&#34;

        # Close any subordinate popups.
        try:
            self.config_popup_tk.destroy()
            self.config_popup_tk = None
        except:
            pass
        try:
            self.new_desc_pop_up_tk.destroy()
            self.new_desc_pop_up_tk = None
        except:
            pass

        d_obj = self._orig_plssdesc_obj
        self.cur_plssdesc_obj = d_obj
        self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
        self.created_new_plssdesc = False
        self.new_desc_text = self.cur_plssdesc_obj.origDesc
        self.display_new_descrip(status=&#39;parsed&#39;)

    def reconfig_btn_clicked(self):
        &#34;&#34;&#34;
        Re-Config button was clicked; launch popup window to get Config
        parameters from user (results are stored in StringVar
        `self.config_text`).
        &#34;&#34;&#34;
        try:
            # Kill the previously opened config popup, if any.
            self.config_popup_tk.destroy()
        except:
            pass

        # Open a config popup, and store it to attrib.
        self.config_popup_tk = tk.Toplevel()
        self.config_popup_tk.focus()
        self.config_popup_tk.grab_set()
        self.config_popup_tk.title(&#39;Change pyTRS Config Parameters&#39;)
        after_prompt = (
            &#39;NOTE: &#39;
            &#39;The config parameters that have just been set will ONLY &#39;
            &#39;affect THIS description. You MUST hit \&#39;Reparse\&#39; &#39;
            &#39;for these config parameters to have any effect.&#39;)
        pc = pyTRS.interface_tools.PromptConfig(
            master=self.config_popup_tk, target_config_var=self.config_text,
            parameters=[
                &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
            ],
            show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
            exit_after_ok=True)
        pc.pack(padx=20, pady=10)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR"><code class="name">var <span class="ident">EDIT_UNACTIVATED_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNSAVED_COLOR"><code class="name">var <span class="ident">EDIT_UNSAVED_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.SAVED_COLOR"><code class="name">var <span class="ident">SAVED_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_descrip"><code class="name flex">
<span>def <span class="ident">display_new_descrip</span></span>(<span>self, status='not_activated')</span>
</code></dt>
<dd>
<div class="desc"><p>Update the displayed description for the PLSSDesc object
(pulled from <code>self.new_desc_text</code>). If the text has been edited
but not enacted, set the color to red. If it has been enacted,
but not yet saved, set to blue. If saved, set to black.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_new_descrip(self, status=&#39;not_activated&#39;):
    &#34;&#34;&#34;Update the displayed description for the PLSSDesc object
    (pulled from `self.new_desc_text`). If the text has been edited
    but not enacted, set the color to red. If it has been enacted,
    but not yet saved, set to blue. If saved, set to black.&#34;&#34;&#34;
    if status == &#39;not_activated&#39;:
        text_color = SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR
    elif status == &#39;not_saved&#39;:
        text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
    else:
        text_color = SingleDescriptionEditor.SAVED_COLOR

    self.orig_desc_lbl.config(fg=text_color, text=self.new_desc_text)
    self.current_display_desc_status = status</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_flags"><code class="name flex">
<span>def <span class="ident">display_new_flags</span></span>(<span>self, source_plssdesc=None, status=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_new_flags(self, source_plssdesc=None, status=None):

    # If status not specified, get it from `self`. Also update `self`
    # on the status.
    if status is None:
        status = self.current_display_flag_status
    self.current_display_flag_status = status

    if status == &#39;not_saved&#39;:
        text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
    else:
        text_color = SingleDescriptionEditor.SAVED_COLOR

    if source_plssdesc is None:
        source_plssdesc = self.current_display_flag_source

    # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
    # tracts from
    self.current_display_flag_source = source_plssdesc

    # Destroy the old flag_table, and replace it with a new one
    if self.flag_table is not None:
        self.flag_table.destroy()
    self.flag_table = FlagTable(
        self.pytrs_display_frame, wflag_list=source_plssdesc.wFlagList,
        eflag_list=source_plssdesc.eFlagList, more_info=self.more_info)
    if self.more_info:
        # Only if `.more_info==True` do we place this on the grid.
        self.flag_table.grid(
            row=self.flag_table_row_col[0],
            column=self.flag_table_row_col[1],
            padx=self.flag_table_padx_pady[0],
            pady=self.flag_table_padx_pady[1], sticky=&#39;nws&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_tracts"><code class="name flex">
<span>def <span class="ident">display_new_tracts</span></span>(<span>self, source_plssdesc=None, status=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the data for the parsed pyTRS.Tract in the specified
<code>source_plssdesc</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_new_tracts(self, source_plssdesc=None, status=None):
    &#34;&#34;&#34;Display the data for the parsed pyTRS.Tract in the specified
    `source_plssdesc`.&#34;&#34;&#34;
    # If status not specified, get it from `self`. Also update `self`
    # on the status.
    if status is None:
        status = self.current_display_tract_status
    self.current_display_tract_status = status

    if status == &#39;not_saved&#39;:
        text_color = SingleDescriptionEditor.EDIT_UNSAVED_COLOR
    else:
        text_color = SingleDescriptionEditor.SAVED_COLOR

    if source_plssdesc is None:
        # Default to pulling the replacement.
        source_plssdesc = self.current_display_tract_source

    # Update the tracker, as to which PLSSDesc obj we&#39;re displaying
    # tracts from
    self.current_display_tract_source = source_plssdesc

    # Destroy the old tract_table, and replace it with a new one,
    # using as the tract_list the `.parsedTracts` from the chosen
    # source PLSSDesc object.
    if self.tract_table is not None:
        self.tract_table.destroy()
    self.tract_table = TractTable(
        self.pytrs_display_frame,
        tract_list=source_plssdesc.parsedTracts, more_info=self.more_info)
    self.tract_table.grid(
        row=self.tract_table_row_col[0],
        column=self.tract_table_row_col[1],
        padx=self.tract_table_padx_pady[0],
        pady=self.tract_table_padx_pady[1], sticky=&#39;nw&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.edit_desc_btn_clicked"><code class="name flex">
<span>def <span class="ident">edit_desc_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prompt the user to make edits to the original description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_desc_btn_clicked(self):
    &#34;&#34;&#34;Prompt the user to make edits to the original description.&#34;&#34;&#34;
    if self.new_desc_pop_up_tk is not None:
        self.new_desc_pop_up_tk.destroy()
    self.new_desc_pop_up_tk = DescTextEditWindow(
        master=self, orig_text=self.new_desc_text)
    self.new_desc_pop_up_tk.focus()
    self.new_desc_pop_up_tk.grab_set()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reconfig_btn_clicked"><code class="name flex">
<span>def <span class="ident">reconfig_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-Config button was clicked; launch popup window to get Config
parameters from user (results are stored in StringVar
<code>self.config_text</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconfig_btn_clicked(self):
    &#34;&#34;&#34;
    Re-Config button was clicked; launch popup window to get Config
    parameters from user (results are stored in StringVar
    `self.config_text`).
    &#34;&#34;&#34;
    try:
        # Kill the previously opened config popup, if any.
        self.config_popup_tk.destroy()
    except:
        pass

    # Open a config popup, and store it to attrib.
    self.config_popup_tk = tk.Toplevel()
    self.config_popup_tk.focus()
    self.config_popup_tk.grab_set()
    self.config_popup_tk.title(&#39;Change pyTRS Config Parameters&#39;)
    after_prompt = (
        &#39;NOTE: &#39;
        &#39;The config parameters that have just been set will ONLY &#39;
        &#39;affect THIS description. You MUST hit \&#39;Reparse\&#39; &#39;
        &#39;for these config parameters to have any effect.&#39;)
    pc = pyTRS.interface_tools.PromptConfig(
        master=self.config_popup_tk, target_config_var=self.config_text,
        parameters=[
            &#39;cleanQQ&#39;, &#39;requireColon&#39;, &#39;ocrScrub&#39;, &#39;segment&#39;, &#39;layout&#39;
        ],
        show_save=False, show_cancel=False, prompt_after_ok=after_prompt,
        exit_after_ok=True)
    pc.pack(padx=20, pady=10)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reparse"><code class="name flex">
<span>def <span class="ident">reparse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reparse the pyTRS.PLSSDesc object at the specified index in
<code>self.plssdesc_list</code>, using the optionally re-specified <code>config</code>
parameters. (If <code>config</code> has not been specified, will use
whatever was already in the PLSSDesc object.)</p>
<p>Note: This will create a new PLSSDesc object and set it to
<code>self.cur_plssdesc_obj</code>. Beware lists that contain the original
PLSSDesc object, as those will NOT be automatically updated with
this new object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparse(self):
    &#34;&#34;&#34;
    Reparse the pyTRS.PLSSDesc object at the specified index in
    `self.plssdesc_list`, using the optionally re-specified `config`
    parameters. (If `config` has not been specified, will use
    whatever was already in the PLSSDesc object.)

    Note: This will create a new PLSSDesc object and set it to
    `self.cur_plssdesc_obj`. Beware lists that contain the original
    PLSSDesc object, as those will NOT be automatically updated with
    this new object.
    &#34;&#34;&#34;

    # Close any subordinate popups.
    try:
        self.config_popup_tk.destroy()
    except:
        pass
    try:
        self.new_desc_pop_up_tk.destroy()
    except:
        pass

    config = self.config_text.get()
    if config == &#39;CANCEL&#39;:
        # If the user hit the cancel button in the config popup, use
        # the original config
        config = self._last_used_config
    desc = self.new_desc_text
    d_obj = pyTRS.PLSSDesc(desc, config=config, initParseQQ=True)
    # Set the main PLSSDesc obj to the new replacement.
    self.cur_plssdesc_obj = d_obj
    # Update our last-used config text (again stripping out layout,
    # if it was deduced, rather than dictated by user)
    cf = d_obj.config  # currently a pyTRS.Config obj
    if not d_obj.layout_specified:
        cf.layout = None
    self._last_used_config = cf.decompile_to_text()

    # Update our displays.
    self.display_new_descrip(status=&#39;parsed&#39;)
    self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
    self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
    # And keep track of the fact that we&#39;ve created a new PLSSDesc obj.
    self.created_new_plssdesc = True</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.restore"><code class="name flex">
<span>def <span class="ident">restore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore the original pyTRS.PLSSDesc object, as it existed at the
creation of this editor instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore(self):
    &#34;&#34;&#34;
    Restore the original pyTRS.PLSSDesc object, as it existed at the
    creation of this editor instance.
    &#34;&#34;&#34;

    confirm = tk.messagebox.askyesno(
        &#39;Confirm Restore&#39;,
        &#39;Discard all changes made to this description since opening &#39;
        &#39;this editor window?&#39;)
    if not confirm:
        return

    # TODO: Prompt &#34;Are You Sure&#34;

    # Close any subordinate popups.
    try:
        self.config_popup_tk.destroy()
        self.config_popup_tk = None
    except:
        pass
    try:
        self.new_desc_pop_up_tk.destroy()
        self.new_desc_pop_up_tk = None
    except:
        pass

    d_obj = self._orig_plssdesc_obj
    self.cur_plssdesc_obj = d_obj
    self.display_new_tracts(source_plssdesc=d_obj, status=&#39;parsed&#39;)
    self.display_new_flags(source_plssdesc=d_obj, status=&#39;parsed&#39;)
    self.created_new_plssdesc = False
    self.new_desc_text = self.cur_plssdesc_obj.origDesc
    self.display_new_descrip(status=&#39;parsed&#39;)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.set_more_info"><code class="name flex">
<span>def <span class="ident">set_more_info</span></span>(<span>self, set_to=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set whether 'more info' should be displayed, and enact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_more_info(self, set_to=None):
    &#34;&#34;&#34;Set whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
    if set_to is None:
        set_to = self.more_info
    self.more_info = set_to
    self.display_new_flags()
    self.display_new_tracts()
    if self.more_info:
        text=&#39;Show less info&#39;
    else:
        text=&#39;Show more info&#39;
    self.more_info_btn.config(text=text)</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.toggle_more_info"><code class="name flex">
<span>def <span class="ident">toggle_more_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle whether 'more info' should be displayed, and enact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_more_info(self):
    &#34;&#34;&#34;Toggle whether &#39;more info&#39; should be displayed, and enact.&#34;&#34;&#34;
    self.more_info = not self.more_info
    self.set_more_info()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleLotDefiner"><code class="flex name class">
<span>class <span class="ident">SingleLotDefiner</span></span>
<span>(</span><span>master=None, target_lddb=None, sec=0, twp='', rge='', trs='', lot_num=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple frame for defining lots on the fly.</p>
<p>Specify EITHER <code>trs</code> OR <code>sec</code>, <code>twp</code>, and <code>rge</code>. If both sets
are specified, will use <code>trs</code> only.</p>
<p>:param target_lddb: The LotDefDB object to be updated.
:param button_on_text: Character that should be displayed inside
a QQ button when it's clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleLotDefiner(SectionFiller):
    &#34;&#34;&#34;
    A simple frame for defining lots on the fly.
    &#34;&#34;&#34;
    def __init__(
            self, master=None, target_lddb=None, sec=0, twp=&#39;&#39;, rge=&#39;&#39;, trs=&#39;&#39;,
            lot_num=0):
        &#34;&#34;&#34;
        Specify EITHER `trs` OR `sec`, `twp`, and `rge`. If both sets
        are specified, will use `trs` only.

        :param target_lddb: The LotDefDB object to be updated.
        :param button_on_text: Character that should be displayed inside
        a QQ button when it&#39;s clicked.
        &#34;&#34;&#34;
        lot_num = _simplify_lot_number(lot_num)

        SectionFiller.__init__(
            self, master, sec=sec, twp=twp, rge=rge, trs=trs,
            button_on_text=lot_num)
        self.lot_num = lot_num

        if not isinstance(target_lddb, LotDefDB):
            raise ValueError(
                &#39;Existing LotDefDB object must be provided as `lddb`&#39;)
        self.target_lddb = target_lddb

        self.go_btn.config(text=&#39;Confirm Lot Definition&#39;)
        lbl = Label(self, text=f&#34;{self.trs}: Lot {lot_num}&#34;)
        lbl.grid(row=1, column=1)

        self.leaveit_btn = tk.Button(
            self, text=&#39;Leave Undefined&#39;, command=self.leaveit_btn_clicked)
        self.leaveit_btn.grid(row=5, column=1)

        self.cancel_btn = tk.Button(
            self, text=&#39;Cancel&#39;, command=self.cancel_btn_clicked)

    def go_btn_clicked(self):
        &#34;&#34;&#34;
        Set or update the definition of this lot in the target_lddb.
        &#34;&#34;&#34;

        filled = self.sec_grid.filled_qqs()
        if len(filled) == 0:
            confirm = tk.messagebox.askokcancel(
                &#39;Are you sure?&#39;, &#34;Leave this lot undefined?&#34;)

            if not confirm:
                return None

        definition = &#39;,&#39;.join(filled)

        tld = self.target_lddb.get_tld(self.twprge, force_tld_return=True)

        try:
            sec_num = int(self.sec)
        except:
            sec_num = 0
        ld = tld.get_ld(sec_num, force_ld_return=True)
        ld.set_lot(self.lot_num, definition)
        tld.set_section(sec_num, ld)
        self.target_lddb.set_twp(self.twprge, tld)

        if hasattr(self.master, &#39;next_one&#39;):
            self.master.next_one()

    def leaveit_btn_clicked(self):
        if hasattr(self.master, &#39;next_one&#39;):
            self.master.next_one()

    def cancel_btn_clicked(self):
        if hasattr(self.master, &#39;canceled&#39;):
            self.master.canceled()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.SectionFiller" href="#pyTRSplat.pyTRSplat_app.SectionFiller">SectionFiller</a></li>
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.SingleLotDefiner.cancel_btn_clicked"><code class="name flex">
<span>def <span class="ident">cancel_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_btn_clicked(self):
    if hasattr(self.master, &#39;canceled&#39;):
        self.master.canceled()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleLotDefiner.go_btn_clicked"><code class="name flex">
<span>def <span class="ident">go_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set or update the definition of this lot in the target_lddb.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def go_btn_clicked(self):
    &#34;&#34;&#34;
    Set or update the definition of this lot in the target_lddb.
    &#34;&#34;&#34;

    filled = self.sec_grid.filled_qqs()
    if len(filled) == 0:
        confirm = tk.messagebox.askokcancel(
            &#39;Are you sure?&#39;, &#34;Leave this lot undefined?&#34;)

        if not confirm:
            return None

    definition = &#39;,&#39;.join(filled)

    tld = self.target_lddb.get_tld(self.twprge, force_tld_return=True)

    try:
        sec_num = int(self.sec)
    except:
        sec_num = 0
    ld = tld.get_ld(sec_num, force_ld_return=True)
    ld.set_lot(self.lot_num, definition)
    tld.set_section(sec_num, ld)
    self.target_lddb.set_twp(self.twprge, tld)

    if hasattr(self.master, &#39;next_one&#39;):
        self.master.next_one()</code></pre>
</details>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.SingleLotDefiner.leaveit_btn_clicked"><code class="name flex">
<span>def <span class="ident">leaveit_btn_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leaveit_btn_clicked(self):
    if hasattr(self.master, &#39;next_one&#39;):
        self.master.next_one()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyTRSplat.pyTRSplat_app.SectionFiller" href="#pyTRSplat.pyTRSplat_app.SectionFiller">SectionFiller</a></b></code>:
<ul class="hlist">
<li><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked">qq_btn_clicked</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TableRow"><code class="flex name class">
<span>class <span class="ident">TableRow</span></span>
<span>(</span><span>master=None, column_data=None, col_widths=None, col_wraps=None, is_header=False, first_tk_col=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic row in a table.</p>
<p>:param column_data: A list of strings to write in the columns.
The number of elements in the list will dictate how many
columns are created.
:param col_widths: A list of integers, each representing the
width for that column. (List must have the same number of
elements as <code>column_data</code>.)
:param col_wraps: A list of integers, each representing the
textwrap for that column, in Tkinter 'text units'.
(List must have the same number of elements as <code>column_data</code>.)
:param is_header: Whether this row contains headers. (Defaults
to False.)
:param first_tk_col: The first tkinter grid column in which to
place the table (probably only used for TableRow subclasses).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableRow(tk.Frame):
    &#34;&#34;&#34;
    A generic row in a table.
    &#34;&#34;&#34;

    def __init__(
            self, master=None, column_data=None, col_widths=None,
            col_wraps=None, is_header=False, first_tk_col=0):
        &#34;&#34;&#34;
        :param column_data: A list of strings to write in the columns.
        The number of elements in the list will dictate how many
        columns are created.
        :param col_widths: A list of integers, each representing the
        width for that column. (List must have the same number of
        elements as `column_data`.)
        :param col_wraps: A list of integers, each representing the
        textwrap for that column, in Tkinter &#39;text units&#39;.
        (List must have the same number of elements as `column_data`.)
        :param is_header: Whether this row contains headers. (Defaults
        to False.)
        :param first_tk_col: The first tkinter grid column in which to
        place the table (probably only used for TableRow subclasses).
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        self.master = master
        if column_data is None:
            column_data = []
        if col_widths is None:
            col_widths = [None for _ in column_data]
        if col_wraps is None:
            col_wraps = [None for _ in column_data]

        anchor = &#39;nw&#39;
        if is_header:
            anchor = &#39;n&#39;

        for i in range(len(column_data)):
            txt = column_data[i]
            width = col_widths[i]
            wrap = col_wraps[i]
            frm = tk.Frame(
                master=self, highlightbackground=&#39;black&#39;, highlightthickness=1)
            frm.grid(row=0, column=first_tk_col + i, sticky=&#39;ns&#39;)
            lbl = tk.Label(
                master=frm, text=txt, anchor=anchor, width=width,
                wraplength=wrap, justify=&#39;left&#39;)
            lbl.grid(sticky=&#39;nw&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyTRSplat.pyTRSplat_app.LDTableRow" href="#pyTRSplat.pyTRSplat_app.LDTableRow">LDTableRow</a></li>
</ul>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable"><code class="flex name class">
<span>class <span class="ident">TractTable</span></span>
<span>(</span><span>master=None, tract_list=None, more_info=False, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame containing a table of parsed data from a list of
pyTRS.Tract objects.</p>
<p>:param tract_list: A list of pyTRS.Tract objects to display.
:param more_info: Whether the user wants to display 'more info'.
In this case, the <code>.lotQQList</code> attribute of each pyTRS.Tract
object is considered 'more info'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TractTable(tk.Frame):
    &#34;&#34;&#34;
    A frame containing a table of parsed data from a list of
    pyTRS.Tract objects.
    &#34;&#34;&#34;

    trs_col_width = 10
    trs_wraplength = 240

    desc_col_width = 30
    desc_wraplength = 200

    lotqq_col_width = 30
    lotqq_wraplength = 200

    def __init__(
            self, master=None, tract_list=None, more_info=False, **kw):
        &#34;&#34;&#34;
        :param tract_list: A list of pyTRS.Tract objects to display.
        :param more_info: Whether the user wants to display &#39;more info&#39;.
        In this case, the `.lotQQList` attribute of each pyTRS.Tract
        object is considered &#39;more info&#39;.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master, **kw)
        self.master = master
        if tract_list is None:
            tract_list = []
        self.tract_list = tract_list

        self.col_widths = [self.trs_col_width, self.desc_col_width]
        self.col_wraps = [self.trs_wraplength, self.desc_wraplength]

        if more_info:
            self.col_widths.append(self.lotqq_col_width)
            self.col_wraps.append(self.lotqq_wraplength)

        i = 0

        headers = [&#39;TRS&#39;, &#39;Description&#39;]
        if more_info:
            headers = [&#39;TRS&#39;, &#39;Description&#39;, &#39;Identified Lots / QQs&#39;]
        tr = TableRow(
            self, column_data=headers, col_widths=self.col_widths,
            col_wraps=self.col_wraps, is_header=True)
        tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
        i += 1

        rows = []

        for tract_obj in tract_list:
            new_row = [tract_obj.trs, tract_obj.desc]
            if more_info:
                new_row.append(&#39;, &#39;.join(tract_obj.lotQQList))
            rows.append(new_row)

        for row in rows:
            tr = TableRow(
                self, column_data=row, col_widths=self.col_widths,
                col_wraps=self.col_wraps)
            tr.grid(row=i, column=0, sticky=&#39;ew&#39;)
            i += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.desc_col_width"><code class="name">var <span class="ident">desc_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.desc_wraplength"><code class="name">var <span class="ident">desc_wraplength</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.lotqq_col_width"><code class="name">var <span class="ident">lotqq_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.lotqq_wraplength"><code class="name">var <span class="ident">lotqq_wraplength</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.trs_col_width"><code class="name">var <span class="ident">trs_col_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyTRSplat.pyTRSplat_app.TractTable.trs_wraplength"><code class="name">var <span class="ident">trs_wraplength</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyTRSplat" href="index.html">pyTRSplat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.launch_app" href="#pyTRSplat.pyTRSplat_app.launch_app">launch_app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.About" href="#pyTRSplat.pyTRSplat_app.About">About</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.About.about_btn_clicked" href="#pyTRSplat.pyTRSplat_app.About.about_btn_clicked">about_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.About.disclaimer_btn_clicked" href="#pyTRSplat.pyTRSplat_app.About.disclaimer_btn_clicked">disclaimer_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.CustomSettingsEditor" href="#pyTRSplat.pyTRSplat_app.CustomSettingsEditor">CustomSettingsEditor</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.CustomSettingsEditor.ok_btn_clicked" href="#pyTRSplat.pyTRSplat_app.CustomSettingsEditor.ok_btn_clicked">ok_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.DescFrame" href="#pyTRSplat.pyTRSplat_app.DescFrame">DescFrame</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.cf_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.cf_btn_clicked">cf_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.clear_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.clear_btn_clicked">clear_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.editor_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.editor_btn_clicked">editor_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.lddb_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.lddb_btn_clicked">lddb_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.lots_help_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.lots_help_btn_clicked">lots_help_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.manual_lddb_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.manual_lddb_clicked">manual_lddb_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.parse_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescFrame.parse_btn_clicked">parse_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescFrame.trigger_update_preview" href="#pyTRSplat.pyTRSplat_app.DescFrame.trigger_update_preview">trigger_update_preview</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.DescTextEditWindow" href="#pyTRSplat.pyTRSplat_app.DescTextEditWindow">DescTextEditWindow</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.DescTextEditWindow.cancel_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescTextEditWindow.cancel_btn_clicked">cancel_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescTextEditWindow.ok_btn_clicked" href="#pyTRSplat.pyTRSplat_app.DescTextEditWindow.ok_btn_clicked">ok_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor">DescriptionEditor</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_COL" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_COL">SDE_COL</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_ROW" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.SDE_ROW">SDE_ROW</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.collect_plssdesc_objects" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.collect_plssdesc_objects">collect_plssdesc_objects</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.delete_desc_clicked" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.delete_desc_clicked">delete_desc_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.export_to_master" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.export_to_master">export_to_master</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.populate_editors" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.populate_editors">populate_editors</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.restore_clicked" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.restore_clicked">restore_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.scroll_sde" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.scroll_sde">scroll_sde</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.toggle_more_info" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.toggle_more_info">toggle_more_info</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.update_displayed_editor" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.update_displayed_editor">update_displayed_editor</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.DescriptionEditor.update_header" href="#pyTRSplat.pyTRSplat_app.DescriptionEditor.update_header">update_header</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.FlagTable" href="#pyTRSplat.pyTRSplat_app.FlagTable">FlagTable</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.FlagTable.col_widths" href="#pyTRSplat.pyTRSplat_app.FlagTable.col_widths">col_widths</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.FlagTable.col_wraps" href="#pyTRSplat.pyTRSplat_app.FlagTable.col_wraps">col_wraps</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.FlagTable.flag_col_width" href="#pyTRSplat.pyTRSplat_app.FlagTable.flag_col_width">flag_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.FlagTable.flag_wraplength" href="#pyTRSplat.pyTRSplat_app.FlagTable.flag_wraplength">flag_wraplength</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.FullPreviewWindow" href="#pyTRSplat.pyTRSplat_app.FullPreviewWindow">FullPreviewWindow</a></code></h4>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.LDTableRow" href="#pyTRSplat.pyTRSplat_app.LDTableRow">LDTableRow</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.LDTableRow.del_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LDTableRow.del_btn_clicked">del_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LDTableRow.edit_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LDTableRow.edit_btn_clicked">edit_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor" href="#pyTRSplat.pyTRSplat_app.LotDefEditor">LotDefEditor</a></code></h4>
<ul class="two-column">
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.TableSeriesDefiner" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.TableSeriesDefiner">TableSeriesDefiner</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.close_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.close_btn_clicked">close_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.define_all_lots" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.define_all_lots">define_all_lots</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.del_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.del_btn_clicked">del_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.gen_new_table" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.gen_new_table">gen_new_table</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefEditor.toggle_all_lddb" href="#pyTRSplat.pyTRSplat_app.LotDefEditor.toggle_all_lddb">toggle_all_lddb</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable" href="#pyTRSplat.pyTRSplat_app.LotDefTable">LotDefTable</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.col_width" href="#pyTRSplat.pyTRSplat_app.LotDefTable.col_width">col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.col_wrap" href="#pyTRSplat.pyTRSplat_app.LotDefTable.col_wrap">col_wrap</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.del_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LotDefTable.del_btn_clicked">del_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.edit_btn_clicked" href="#pyTRSplat.pyTRSplat_app.LotDefTable.edit_btn_clicked">edit_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.gen_tablerow" href="#pyTRSplat.pyTRSplat_app.LotDefTable.gen_tablerow">gen_tablerow</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.ld_col_width" href="#pyTRSplat.pyTRSplat_app.LotDefTable.ld_col_width">ld_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.ld_wraplength" href="#pyTRSplat.pyTRSplat_app.LotDefTable.ld_wraplength">ld_wraplength</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.lot_name_col_width" href="#pyTRSplat.pyTRSplat_app.LotDefTable.lot_name_col_width">lot_name_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.max_rows_per_page" href="#pyTRSplat.pyTRSplat_app.LotDefTable.max_rows_per_page">max_rows_per_page</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.scroll_page" href="#pyTRSplat.pyTRSplat_app.LotDefTable.scroll_page">scroll_page</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.tbrow_col" href="#pyTRSplat.pyTRSplat_app.LotDefTable.tbrow_col">tbrow_col</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.trs_col_width" href="#pyTRSplat.pyTRSplat_app.LotDefTable.trs_col_width">trs_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.update_displayed_page" href="#pyTRSplat.pyTRSplat_app.LotDefTable.update_displayed_page">update_displayed_page</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.update_header" href="#pyTRSplat.pyTRSplat_app.LotDefTable.update_header">update_header</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotDefTable.update_table" href="#pyTRSplat.pyTRSplat_app.LotDefTable.update_table">update_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.LotRedefiner" href="#pyTRSplat.pyTRSplat_app.LotRedefiner">LotRedefiner</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.LotRedefiner.canceled" href="#pyTRSplat.pyTRSplat_app.LotRedefiner.canceled">canceled</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.LotRedefiner.done" href="#pyTRSplat.pyTRSplat_app.LotRedefiner.done">done</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.MainWindow" href="#pyTRSplat.pyTRSplat_app.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.MainWindow.mpq" href="#pyTRSplat.pyTRSplat_app.MainWindow.mpq">mpq</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.MainWindow.trigger_update_preview" href="#pyTRSplat.pyTRSplat_app.MainWindow.trigger_update_preview">trigger_update_preview</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter" href="#pyTRSplat.pyTRSplat_app.ManualPlatter">ManualPlatter</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.NSEW_WID" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.NSEW_WID">NSEW_WID</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_COL" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_COL">PLATTER_COL</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_ROW" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.PLATTER_ROW">PLATTER_ROW</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.TWPRGE_WID" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.TWPRGE_WID">TWPRGE_WID</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.child_go_btn_clicked" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.child_go_btn_clicked">child_go_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.clear_btn_clicked" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.clear_btn_clicked">clear_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.ManualPlatter.new_platter" href="#pyTRSplat.pyTRSplat_app.ManualPlatter.new_platter">new_platter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.ManualSectionPlatter" href="#pyTRSplat.pyTRSplat_app.ManualSectionPlatter">ManualSectionPlatter</a></code></h4>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.OutputFrame" href="#pyTRSplat.pyTRSplat_app.OutputFrame">OutputFrame</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.OutputFrame.editor_btn_clicked" href="#pyTRSplat.pyTRSplat_app.OutputFrame.editor_btn_clicked">editor_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.OutputFrame.gen_plat" href="#pyTRSplat.pyTRSplat_app.OutputFrame.gen_plat">gen_plat</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.OutputFrame.preview_btn_clicked" href="#pyTRSplat.pyTRSplat_app.OutputFrame.preview_btn_clicked">preview_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.OutputFrame.save_btn_clicked" href="#pyTRSplat.pyTRSplat_app.OutputFrame.save_btn_clicked">save_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview" href="#pyTRSplat.pyTRSplat_app.PlatPreview">PlatPreview</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS" href="#pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS">PREVIEW_SETTINGS</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS_NONE" href="#pyTRSplat.pyTRSplat_app.PlatPreview.PREVIEW_SETTINGS_NONE">PREVIEW_SETTINGS_NONE</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.gen_preview" href="#pyTRSplat.pyTRSplat_app.PlatPreview.gen_preview">gen_preview</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.scroll_preview" href="#pyTRSplat.pyTRSplat_app.PlatPreview.scroll_preview">scroll_preview</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.set_obj" href="#pyTRSplat.pyTRSplat_app.PlatPreview.set_obj">set_obj</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.PlatPreview.update_preview_display" href="#pyTRSplat.pyTRSplat_app.PlatPreview.update_preview_display">update_preview_display</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller" href="#pyTRSplat.pyTRSplat_app.SectionFiller">SectionFiller</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller.go_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SectionFiller.go_btn_clicked">go_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SectionFiller.qq_btn_clicked">qq_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.SeriesLotDefiner" href="#pyTRSplat.pyTRSplat_app.SeriesLotDefiner">SeriesLotDefiner</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.canceled" href="#pyTRSplat.pyTRSplat_app.SeriesLotDefiner.canceled">canceled</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.done" href="#pyTRSplat.pyTRSplat_app.SeriesLotDefiner.done">done</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SeriesLotDefiner.next_one" href="#pyTRSplat.pyTRSplat_app.SeriesLotDefiner.next_one">next_one</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor">SingleDescriptionEditor</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNACTIVATED_COLOR">EDIT_UNACTIVATED_COLOR</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNSAVED_COLOR" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.EDIT_UNSAVED_COLOR">EDIT_UNSAVED_COLOR</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.SAVED_COLOR" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.SAVED_COLOR">SAVED_COLOR</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_descrip" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_descrip">display_new_descrip</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_flags" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_flags">display_new_flags</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_tracts" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.display_new_tracts">display_new_tracts</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.edit_desc_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.edit_desc_btn_clicked">edit_desc_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reconfig_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reconfig_btn_clicked">reconfig_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reparse" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.reparse">reparse</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.restore" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.restore">restore</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.set_more_info" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.set_more_info">set_more_info</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.toggle_more_info" href="#pyTRSplat.pyTRSplat_app.SingleDescriptionEditor.toggle_more_info">toggle_more_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.SingleLotDefiner" href="#pyTRSplat.pyTRSplat_app.SingleLotDefiner">SingleLotDefiner</a></code></h4>
<ul class="">
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleLotDefiner.cancel_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SingleLotDefiner.cancel_btn_clicked">cancel_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleLotDefiner.go_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SingleLotDefiner.go_btn_clicked">go_btn_clicked</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.SingleLotDefiner.leaveit_btn_clicked" href="#pyTRSplat.pyTRSplat_app.SingleLotDefiner.leaveit_btn_clicked">leaveit_btn_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.TableRow" href="#pyTRSplat.pyTRSplat_app.TableRow">TableRow</a></code></h4>
</li>
<li>
<h4><code><a title="pyTRSplat.pyTRSplat_app.TractTable" href="#pyTRSplat.pyTRSplat_app.TractTable">TractTable</a></code></h4>
<ul class="two-column">
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.desc_col_width" href="#pyTRSplat.pyTRSplat_app.TractTable.desc_col_width">desc_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.desc_wraplength" href="#pyTRSplat.pyTRSplat_app.TractTable.desc_wraplength">desc_wraplength</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.lotqq_col_width" href="#pyTRSplat.pyTRSplat_app.TractTable.lotqq_col_width">lotqq_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.lotqq_wraplength" href="#pyTRSplat.pyTRSplat_app.TractTable.lotqq_wraplength">lotqq_wraplength</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.trs_col_width" href="#pyTRSplat.pyTRSplat_app.TractTable.trs_col_width">trs_col_width</a></code></li>
<li><code><a title="pyTRSplat.pyTRSplat_app.TractTable.trs_wraplength" href="#pyTRSplat.pyTRSplat_app.TractTable.trs_wraplength">trs_wraplength</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>